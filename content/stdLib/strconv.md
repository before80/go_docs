+++
title = "strconv"
date = 2023-05-17T09:59:21+08:00
type = "docs"
description = ""
isCJKLanguage = true
draft = false
+++
> åŸæ–‡ï¼š[https://pkg.go.dev/strconv@go1.21.3](https://pkg.go.dev/strconv@go1.21.3)

Package strconv implements conversions to and from string representations of basic data types.

â€‹	`strconv`åŒ…å®ç°äº†åŸºæœ¬æ•°æ®ç±»å‹çš„å­—ç¬¦ä¸²è¡¨ç¤ºä¸å…¶ç›¸äº’è½¬æ¢çš„åŠŸèƒ½ã€‚

## æ•°å­—è½¬æ¢ Numeric Conversions

The most common numeric conversions are Atoi (string to int) and Itoa (int to string).

â€‹	æœ€å¸¸è§çš„æ•°å­—è½¬æ¢æ˜¯Atoi(å­—ç¬¦ä¸²åˆ°æ•´æ•°)å’ŒItoa(æ•´æ•°åˆ°å­—ç¬¦ä¸²)ã€‚

> â€‹	å‡½æ•°å`Atoi`æ˜¯å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºæ•´æ•°çš„ç¼©å†™ï¼Œå…¶ä¸­`A`ä»£è¡¨`ASCII`å­—ç¬¦é›†ï¼Œå³è¯¥å‡½æ•°åªèƒ½å¤„ç†ä½¿ç”¨`ASCII`å­—ç¬¦é›†è¡¨ç¤ºçš„æ•°å­—å­—ç¬¦ï¼Œè€Œä¸èƒ½å¤„ç†ä½¿ç”¨å…¶ä»–å­—ç¬¦é›†è¡¨ç¤ºçš„æ•°å­—å­—ç¬¦ã€‚`toi`åˆ™æ˜¯`to int`çš„ç¼©å†™ï¼Œè¡¨ç¤ºå°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºæ•´æ•°ã€‚å› æ­¤ï¼Œ`Atoi`å‡½æ•°åçš„å«ä¹‰ä¸ºå°†ä½¿ç”¨`ASCII`å­—ç¬¦é›†è¡¨ç¤ºçš„å­—ç¬¦ä¸²è½¬æ¢ä¸ºæ•´æ•°ã€‚

```
i, err := strconv.Atoi("-42")
s := strconv.Itoa(-42)
```

These assume decimal and the Go int type.

â€‹	è¿™äº›å‡è®¾åè¿›åˆ¶å’ŒGo intç±»å‹ã€‚

ParseBool, ParseFloat, ParseInt, and ParseUint convert strings to values:

â€‹	ParseBoolå‡½æ•°ã€ParseFloatå‡½æ•°ã€ParseIntå‡½æ•°å’ŒParseUintå‡½æ•°å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºç›¸åº”çš„æ•°å€¼ï¼š

```
b, err := strconv.ParseBool("true")
f, err := strconv.ParseFloat("3.1415", 64)
i, err := strconv.ParseInt("-42", 10, 64)
u, err := strconv.ParseUint("42", 10, 64)
```

The parse functions return the widest type (float64, int64, and uint64), but if the size argument specifies a narrower width the result can be converted to that narrower type without data loss:

â€‹	è§£æå‡½æ•°è¿”å›æœ€å®½çš„ç±»å‹(float64ã€int64å’Œuint64)ï¼Œä½†å¦‚æœsizeå‚æ•°æŒ‡å®šäº†æ›´çª„çš„å®½åº¦ï¼Œåˆ™ç»“æœå¯ä»¥è½¬æ¢ä¸ºè¯¥æ›´çª„çš„ç±»å‹è€Œä¸ä¼šä¸¢å¤±æ•°æ®ï¼š

```
s := "2147483647" // biggest int32 // æœ€å¤§çš„int32
i64, err := strconv.ParseInt(s, 10, 32)
...
i := int32(i64)
```

FormatBool, FormatFloat, FormatInt, and FormatUint convert values to strings:

â€‹	FormatBoolå‡½æ•°ã€FormatFloatå‡½æ•°ã€FormatIntå‡½æ•°å’ŒFormatUintå‡½æ•°å°†å€¼è½¬æ¢ä¸ºå­—ç¬¦ä¸²ï¼š

```
s := strconv.FormatBool(true)
s := strconv.FormatFloat(3.1415, 'E', -1, 64)
s := strconv.FormatInt(-42, 16)
s := strconv.FormatUint(42, 16)
```

AppendBool, AppendFloat, AppendInt, and AppendUint are similar but append the formatted value to a destination slice.

â€‹	AppendBoolå‡½æ•°ã€AppendFloatå‡½æ•°ã€AppendIntå‡½æ•°å’ŒAppendUintå‡½æ•°ç±»ä¼¼ï¼Œä½†å°†æ ¼å¼åŒ–çš„å€¼é™„åŠ åˆ°ç›®æ ‡åˆ‡ç‰‡ã€‚

## å­—ç¬¦ä¸²è½¬æ¢ String Conversions

Quote and QuoteToASCII convert strings to quoted Go string literals. The latter guarantees that the result is an ASCII string, by escaping any non-ASCII Unicode with \u:

â€‹	Quoteå‡½æ•°å’ŒQuoteToASCIIå‡½æ•°å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºå¸¦å¼•å·çš„Goå­—ç¬¦ä¸²æ–‡å­—ã€‚åè€…é€šè¿‡ä½¿ç”¨`\u`è½¬ä¹‰ä»»ä½•éASCII Unicodeæ¥ä¿è¯ç»“æœæ˜¯ASCIIå­—ç¬¦ä¸²ï¼š

```
q := strconv.Quote("Hello, ä¸–ç•Œ")
q := strconv.QuoteToASCII("Hello, ä¸–ç•Œ")
```

QuoteRune and QuoteRuneToASCII are similar but accept runes and return quoted Go rune literals.

â€‹	QuoteRuneå‡½æ•°å’ŒQuoteRuneToASCIIå‡½æ•°ç±»ä¼¼ï¼Œä½†æ¥å—ç¬¦æ–‡å¹¶è¿”å›å¸¦å¼•å·çš„Goç¬¦æ–‡æ–‡å­—ã€‚

Unquote and UnquoteChar unquote Go string and rune literals.

â€‹	Unquoteå‡½æ•°å’ŒUnquoteCharå‡½æ•°å–æ¶ˆå¼•ç”¨Goå­—ç¬¦ä¸²å’Œç¬¦æ–‡æ–‡å­—ã€‚


## å¸¸é‡ 

[View Source](https://cs.opensource.google/go/go/+/go1.20.1:src/strconv/atoi.go;l=71)

``` go 
const IntSize = intSize
```

IntSize is the size in bits of an int or uint value.

â€‹	IntSize æ˜¯ int æˆ– uint å€¼çš„ä½æ•°å¤§å°ã€‚

## å˜é‡

[View Source](https://cs.opensource.google/go/go/+/go1.20.1:src/strconv/atoi.go;l=18)

``` go 
var ErrRange = errors.New("value out of range")
```

ErrRange indicates that a value is out of range for the target type.

â€‹	ErrRange è¡¨ç¤ºè¯¥å€¼è¶…å‡ºç›®æ ‡ç±»å‹çš„èŒƒå›´ã€‚

[View Source](https://cs.opensource.google/go/go/+/go1.20.1:src/strconv/atoi.go;l=21)

``` go 
var ErrSyntax = errors.New("invalid syntax")
```

ErrSyntax indicates that a value does not have the right syntax for the target type.

â€‹	ErrSyntax è¡¨ç¤ºè¯¥å€¼å¯¹äºç›®æ ‡ç±»å‹æ¥è¯´è¯­æ³•ä¸æ­£ç¡®ã€‚

## å‡½æ•°

### func AppendBool 

``` go 
func AppendBool(dst []byte, b bool) []byte
```

AppendBool appends "true" or "false", according to the value of b, to dst and returns the extended buffer.

â€‹	AppendBoolå‡½æ•°æ ¹æ® b çš„å€¼å°† "true" æˆ– "false" è¿½åŠ åˆ° dst ä¸­å¹¶è¿”å›æ‰©å±•åçš„ç¼“å†²åŒºã€‚

#### AppendBool Example
``` go 
package main

import (
	"fmt"
	"strconv"
)

func main() {
	b := []byte("bool:")
	b = strconv.AppendBool(b, true)
	fmt.Println(string(b))

}
Output:

bool:true
```

### func AppendFloat 

``` go 
func AppendFloat(dst []byte, f float64, fmt byte, prec, bitSize int) []byte
```

AppendFloat appends the string form of the floating-point number f, as generated by FormatFloat, to dst and returns the extended buffer.

â€‹	AppendFloatå‡½æ•°å°†æµ®ç‚¹æ•° f çš„å­—ç¬¦ä¸²å½¢å¼(ç”± FormatFloat ç”Ÿæˆ)è¿½åŠ åˆ° dst ä¸­å¹¶è¿”å›æ‰©å±•åçš„ç¼“å†²åŒºã€‚

#### AppendFloat Example
``` go 
package main

import (
	"fmt"
	"strconv"
)

func main() {
	b32 := []byte("float32:")
	b32 = strconv.AppendFloat(b32, 3.1415926535, 'E', -1, 32)
	fmt.Println(string(b32))

	b64 := []byte("float64:")
	b64 = strconv.AppendFloat(b64, 3.1415926535, 'E', -1, 64)
	fmt.Println(string(b64))

}
Output:

float32:3.1415927E+00
float64:3.1415926535E+00
```

### func AppendInt 

``` go 
func AppendInt(dst []byte, i int64, base int) []byte
```

AppendInt appends the string form of the integer i, as generated by FormatInt, to dst and returns the extended buffer.

â€‹	AppendIntå‡½æ•°å°†æ•´æ•° i çš„å­—ç¬¦ä¸²å½¢å¼(ç”± FormatIntå‡½æ•° ç”Ÿæˆ)è¿½åŠ åˆ° dst ä¸­å¹¶è¿”å›æ‰©å±•åçš„ç¼“å†²åŒºã€‚

#### AppendInt Example
``` go 
package main

import (
	"fmt"
	"strconv"
)

func main() {
	b10 := []byte("int (base 10):")
	b10 = strconv.AppendInt(b10, -42, 10)
	fmt.Println(string(b10))

	b16 := []byte("int (base 16):")
	b16 = strconv.AppendInt(b16, -42, 16)
	fmt.Println(string(b16))

}
Output:

int (base 10):-42
int (base 16):-2a
```

### func AppendQuote 

``` go 
func AppendQuote(dst []byte, s string) []byte
```

AppendQuote appends a double-quoted Go string literal representing s, as generated by Quote, to dst and returns the extended buffer.

â€‹	AppendQuoteå‡½æ•°å°†è¡¨ç¤º s çš„åŒå¼•å· Go å­—ç¬¦ä¸²æ–‡å­—(ç”± Quoteå‡½æ•° ç”Ÿæˆ)è¿½åŠ åˆ° dst ä¸­å¹¶è¿”å›æ‰©å±•åçš„ç¼“å†²åŒºã€‚

#### AppendQuote Example
``` go 
package main

import (
	"fmt"
	"strconv"
)

func main() {
	b := []byte("quote:")
	b = strconv.AppendQuote(b, `"Fran & Freddie's Diner"`)
	fmt.Println(string(b))

}
Output:

quote:"\"Fran & Freddie's Diner\""
```

### func AppendQuoteRune 

``` go 
func AppendQuoteRune(dst []byte, r rune) []byte
```

AppendQuoteRune appends a single-quoted Go character literal representing the rune, as generated by QuoteRune, to dst and returns the extended buffer.

â€‹	AppendQuoteRuneå‡½æ•°å°†è¡¨ç¤ºç¬¦æ–‡çš„å•å¼•å· Go å­—ç¬¦æ–‡å­—(ç”± QuoteRuneå‡½æ•° ç”Ÿæˆ)è¿½åŠ åˆ° dst ä¸­å¹¶è¿”å›æ‰©å±•åçš„ç¼“å†²åŒºã€‚

#### AppendQuoteRune Example
``` go 
package main

import (
	"fmt"
	"strconv"
)

func main() {
	b := []byte("rune:")
	b = strconv.AppendQuoteRune(b, 'â˜º')
	fmt.Println(string(b))

}
Output:

rune:'â˜º'
```

### func AppendQuoteRuneToASCII 

``` go 
func AppendQuoteRuneToASCII(dst []byte, r rune) []byte
```

AppendQuoteRuneToASCII appends a single-quoted Go character literal representing the rune, as generated by QuoteRuneToASCII, to dst and returns the extended buffer.

â€‹	AppendQuoteRuneToASCIIå‡½æ•°å°†è¡¨ç¤ºruneçš„å•å¼•å·Goå­—ç¬¦æ–‡æœ¬(ç”±QuoteRuneToASCIIç”Ÿæˆ)é™„åŠ åˆ°dstå¹¶è¿”å›æ‰©å±•çš„ç¼“å†²åŒºã€‚

#### AppendQuoteRuneToASCII Example
``` go 
package main

import (
	"fmt"
	"strconv"
)

func main() {
	b := []byte("rune (ascii):")
	b = strconv.AppendQuoteRuneToASCII(b, 'â˜º')
	fmt.Println(string(b))

}
Output:

rune (ascii):'\u263a'
```

### func AppendQuoteRuneToGraphic  <- go1.6

``` go 
func AppendQuoteRuneToGraphic(dst []byte, r rune) []byte
```

AppendQuoteRuneToGraphic appends a single-quoted Go character literal representing the rune, as generated by QuoteRuneToGraphic, to dst and returns the extended buffer.

â€‹	AppendQuoteRuneToGraphicå‡½æ•°å°†è¡¨ç¤ºruneçš„å•å¼•å·Goå­—ç¬¦æ–‡æœ¬(ç”±QuoteRuneToGraphicå‡½æ•°ç”Ÿæˆ)é™„åŠ åˆ°dstå¹¶è¿”å›æ‰©å±•çš„ç¼“å†²åŒºã€‚

### func AppendQuoteToASCII 

``` go 
func AppendQuoteToASCII(dst []byte, s string) []byte
```

AppendQuoteToASCII appends a double-quoted Go string literal representing s, as generated by QuoteToASCII, to dst and returns the extended buffer.

â€‹	AppendQuoteToASCIIå‡½æ•°å°†è¡¨ç¤ºsçš„åŒå¼•å·Goå­—ç¬¦ä¸²æ–‡æœ¬(ç”±QuoteToASCIIå‡½æ•°ç”Ÿæˆ)é™„åŠ åˆ°dstå¹¶è¿”å›æ‰©å±•çš„ç¼“å†²åŒºã€‚

#### AppendQuoteToASCII Example
``` go 
package main

import (
	"fmt"
	"strconv"
)

func main() {
	b := []byte("quote (ascii):")
	b = strconv.AppendQuoteToASCII(b, `"Fran & Freddie's Diner"`)
	fmt.Println(string(b))

}
Output:

quote (ascii):"\"Fran & Freddie's Diner\""
```

### func AppendQuoteToGraphic  <- go1.6

``` go 
func AppendQuoteToGraphic(dst []byte, s string) []byte
```

AppendQuoteToGraphic appends a double-quoted Go string literal representing s, as generated by QuoteToGraphic, to dst and returns the extended buffer.

â€‹	AppendQuoteToGraphicå‡½æ•°å°†è¡¨ç¤ºsçš„åŒå¼•å·Goå­—ç¬¦ä¸²æ–‡æœ¬(ç”±QuoteToGraphicå‡½æ•°ç”Ÿæˆ)é™„åŠ åˆ°dstå¹¶è¿”å›æ‰©å±•çš„ç¼“å†²åŒºã€‚

### func AppendUint 

``` go 
func AppendUint(dst []byte, i uint64, base int) []byte
```

AppendUint appends the string form of the unsigned integer i, as generated by FormatUint, to dst and returns the extended buffer.

â€‹	AppendUintå‡½æ•°å°†ç”Ÿæˆçš„æ— ç¬¦å·æ•´æ•°içš„å­—ç¬¦ä¸²å½¢å¼(ç”±FormatUintå‡½æ•°ç”Ÿæˆ)é™„åŠ åˆ°dstå¹¶è¿”å›æ‰©å±•çš„ç¼“å†²åŒºã€‚

#### AppendUint Example
``` go 
package main

import (
	"fmt"
	"strconv"
)

func main() {
	b10 := []byte("uint (base 10):")
	b10 = strconv.AppendUint(b10, 42, 10)
	fmt.Println(string(b10))

	b16 := []byte("uint (base 16):")
	b16 = strconv.AppendUint(b16, 42, 16)
	fmt.Println(string(b16))

}
Output:

uint (base 10):42
uint (base 16):2a
```

### func Atoi 

``` go 
func Atoi(s string) (int, error)
```

Atoi is equivalent to ParseInt(s, 10, 0), converted to type int.

â€‹	Atoiå‡½æ•°ç­‰ä»·äºParseInt(sï¼Œ10ï¼Œ0)ï¼Œè½¬æ¢ä¸ºintç±»å‹ã€‚

#### Atoi Example
``` go 
package main

import (
	"fmt"
	"strconv"
)

func main() {
	v := "10"
	if s, err := strconv.Atoi(v); err == nil {
		fmt.Printf("%T, %v", s, s)
	}

}
Output:

int, 10
```

### func CanBackquote 

``` go 
func CanBackquote(s string) bool
```

CanBackquote reports whether the string s can be represented unchanged as a single-line backquoted string without control characters other than tab.

â€‹	CanBackquoteå‡½æ•°æŠ¥å‘Šå­—ç¬¦ä¸²sæ˜¯å¦å¯ä»¥è¡¨ç¤ºä¸ºå•è¡Œåå¼•å·å­—ç¬¦ä¸²è€Œä¸å¸¦æ§åˆ¶å­—ç¬¦(é™¤åˆ¶è¡¨ç¬¦ä¹‹å¤–)ã€‚

> `CanBackquote`å‡½æ•°ä¼šè¿”å›ä¸€ä¸ªå¸ƒå°”å€¼ï¼ŒæŒ‡ç¤ºæ˜¯å¦å¯ä»¥ä½¿ç”¨Goè¯­è¨€ä¸­çš„åå¼•å·æ¥åŒ…è£¹ç»™å®šçš„å­—ç¬¦ä¸²ã€‚å¦‚æœå¯ä»¥ä½¿ç”¨åå¼•å·ï¼Œåˆ™è¿”å›`true`ï¼Œå¦åˆ™è¿”å›`false`ã€‚

#### CanBackquote Example
``` go 
package main

import (
	"fmt"
	"strconv"
)

func main() {
	fmt.Println(strconv.CanBackquote("Fran & Freddie's Diner â˜º"))
	fmt.Println(strconv.CanBackquote("`can't backquote this`"))

}
Output:

true
false
```

### func FormatBool 

``` go 
func FormatBool(b bool) string
```

FormatBool returns "true" or "false" according to the value of b.

â€‹	FormatBoolå‡½æ•°æ ¹æ® b çš„å€¼è¿”å› "true" æˆ– "false"ã€‚

#### FormatBool Example
``` go 
package main

import (
	"fmt"
	"strconv"
)

func main() {
	v := true
	s := strconv.FormatBool(v)
	fmt.Printf("%T, %v\n", s, s)

}
Output:

string, true
```

### func FormatComplex  <- go1.15

``` go 
func FormatComplex(c complex128, fmt byte, prec, bitSize int) string
```

FormatComplex converts the complex number c to a string of the form (a+bi) where a and b are the real and imaginary parts, formatted according to the format fmt and precision prec.

â€‹	FormatComplexå‡½æ•°å°†å¤æ•° c æ ¼å¼åŒ–ä¸º (a+bi) å½¢å¼çš„å­—ç¬¦ä¸²ï¼Œå…¶ä¸­ a å’Œ b æ˜¯å®éƒ¨å’Œè™šéƒ¨ï¼Œæ ¹æ®æ ¼å¼fmtå’Œç²¾åº¦precè¿›è¡Œæ ¼å¼åŒ–ã€‚

The format fmt and precision prec have the same meaning as in FormatFloat. It rounds the result assuming that the original was obtained from a complex value of bitSize bits, which must be 64 for complex64 and 128 for complex128.

â€‹	æ ¼å¼ fmt å’Œç²¾åº¦ prec çš„å«ä¹‰ä¸ FormatFloatå‡½æ•° ç›¸åŒã€‚å®ƒå‡å®šåŸå§‹å€¼æ˜¯ä» bitSize ä½çš„å¤æ•°å€¼(complex64 çš„ bitSize å¿…é¡»æ˜¯ 64ï¼Œè€Œ complex128 çš„ bitSize å¿…é¡»æ˜¯ 128)è·å¾—çš„ï¼Œå››èˆäº”å…¥ç»“æœã€‚

### func FormatFloat 

``` go 
func FormatFloat(f float64, fmt byte, prec, bitSize int) string
```

FormatFloat converts the floating-point number f to a string, according to the format fmt and precision prec. It rounds the result assuming that the original was obtained from a floating-point value of bitSize bits (32 for float32, 64 for float64).

â€‹	FormatFloatå‡½æ•°å°†æµ®ç‚¹æ•° f æ ¼å¼åŒ–ä¸ºå­—ç¬¦ä¸²ï¼Œæ ¼å¼ç”± fmt å’Œç²¾åº¦ prec æŒ‡å®šã€‚å®ƒå‡å®šåŸå§‹å€¼æ˜¯ä» bitSize ä½(float32 ä¸º 32ï¼Œfloat64 ä¸º 64)çš„æµ®ç‚¹æ•°å€¼è·å¾—çš„ã€‚

The format fmt is one of 'b' (-ddddpÂ±ddd, a binary exponent), 'e' (-d.ddddeÂ±dd, a decimal exponent), 'E' (-d.ddddEÂ±dd, a decimal exponent), 'f' (-ddd.dddd, no exponent), 'g' ('e' for large exponents, 'f' otherwise), 'G' ('E' for large exponents, 'f' otherwise), 'x' (-0xd.ddddpÂ±ddd, a hexadecimal fraction and binary exponent), or 'X' (-0Xd.ddddPÂ±ddd, a hexadecimal fraction and binary exponent).

â€‹	æ ¼å¼ fmt æ˜¯ 'b'(-ddddpÂ±dddï¼ŒäºŒè¿›åˆ¶æŒ‡æ•°)ã€'e'(-d.ddddeÂ±ddï¼Œåè¿›åˆ¶æŒ‡æ•°)ã€'E'(-d.ddddEÂ±ddï¼Œåè¿›åˆ¶æŒ‡æ•°)ã€'f'(-ddd.ddddï¼Œæ— æŒ‡æ•°)ã€'g'(å¤§æŒ‡æ•°æ—¶ä¸º 'e'ï¼Œå¦åˆ™ä¸º 'f')ã€'G'(å¤§æŒ‡æ•°æ—¶ä¸º 'E'ï¼Œå¦åˆ™ä¸º 'f')ã€'x'(-0xd.ddddpÂ±dddï¼Œåå…­è¿›åˆ¶å°æ•°å’ŒäºŒè¿›åˆ¶æŒ‡æ•°)æˆ– 'X'(-0Xd.ddddPÂ±dddï¼Œåå…­è¿›åˆ¶å°æ•°å’ŒäºŒè¿›åˆ¶æŒ‡æ•°)ä¹‹ä¸€ã€‚

The precision prec controls the number of digits (excluding the exponent) printed by the 'e', 'E', 'f', 'g', 'G', 'x', and 'X' formats. For 'e', 'E', 'f', 'x', and 'X', it is the number of digits after the decimal point. For 'g' and 'G' it is the maximum number of significant digits (trailing zeros are removed). The special precision -1 uses the smallest number of digits necessary such that ParseFloat will return f exactly.

â€‹	ç²¾åº¦ prec æ§åˆ¶ç”± 'e'ã€'E'ã€'f'ã€'g'ã€'G'ã€'x' å’Œ 'X' æ ¼å¼æ‰“å°çš„æ•°å­—çš„ä½æ•°(ä¸åŒ…æ‹¬æŒ‡æ•°)ã€‚å¯¹äº 'e'ã€'E'ã€'f'ã€'x' å’Œ 'X'ï¼Œå®ƒæ˜¯å°æ•°ç‚¹åçš„æ•°å­—ä½æ•°ã€‚å¯¹äº 'g' å’Œ 'G'ï¼Œå®ƒæ˜¯æœ€å¤§çš„æœ‰æ•ˆæ•°å­—ä½æ•°(å°¾éšé›¶è¢«åˆ é™¤)ã€‚ç‰¹æ®Šç²¾åº¦ -1 ä½¿ç”¨æœ€å°‘æ•°é‡çš„ä½æ•°ï¼Œä½¿ ParseFloat ç²¾ç¡®è¿”å› fã€‚

#### FormatFloat Example
``` go 
package main

import (
	"fmt"
	"strconv"
)

func main() {
	v := 3.1415926535

	s32 := strconv.FormatFloat(v, 'E', -1, 32)
	fmt.Printf("%T, %v\n", s32, s32)

	s64 := strconv.FormatFloat(v, 'E', -1, 64)
	fmt.Printf("%T, %v\n", s64, s64)

}
Output:

string, 3.1415927E+00
string, 3.1415926535E+00
```

### func FormatInt 

``` go 
func FormatInt(i int64, base int) string
```

FormatInt returns the string representation of i in the given base, for 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z' for digit values >= 10.

â€‹	FormatIntå‡½æ•°è¿”å›åŸºäºç»™å®šè¿›åˆ¶ base ä¸­ i çš„å­—ç¬¦ä¸²è¡¨ç¤ºå½¢å¼ï¼Œ2 <= base <= 36ã€‚ç»“æœå¯¹äºå€¼ >= 10 çš„æ•°å­—ä½¿ç”¨å°å†™å­—æ¯ 'a' åˆ° 'z'ã€‚

#### FormatInt Example
``` go 
package main

import (
	"fmt"
	"strconv"
)

func main() {
	v := int64(-42)

	s10 := strconv.FormatInt(v, 10)
	fmt.Printf("%T, %v\n", s10, s10)

	s16 := strconv.FormatInt(v, 16)
	fmt.Printf("%T, %v\n", s16, s16)

}
Output:

string, -42
string, -2a
```

### func FormatUint 

``` go 
func FormatUint(i uint64, base int) string
```

FormatUint returns the string representation of i in the given base, for 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z' for digit values >= 10.

â€‹	FormatUintå‡½æ•°è¿”å›åŸºäºç»™å®šè¿›åˆ¶ base ä¸­ i çš„å­—ç¬¦ä¸²è¡¨ç¤ºå½¢å¼ï¼Œ2 <= base <= 36ã€‚ç»“æœå¯¹äºå€¼ >= 10 çš„æ•°å­—ä½¿ç”¨å°å†™å­—æ¯ 'a' åˆ° 'z'ã€‚

#### FormatUint Example
``` go 
package main

import (
	"fmt"
	"strconv"
)

func main() {
	v := uint64(42)

	s10 := strconv.FormatUint(v, 10)
	fmt.Printf("%T, %v\n", s10, s10)

	s16 := strconv.FormatUint(v, 16)
	fmt.Printf("%T, %v\n", s16, s16)

}
Output:

string, 42
string, 2a
```

### func IsGraphic  <- go1.6

``` go 
func IsGraphic(r rune) bool
```

IsGraphic reports whether the rune is defined as a Graphic by Unicode. Such characters include letters, marks, numbers, punctuation, symbols, and spaces, from categories L, M, N, P, S, and Zs.

â€‹	IsGraphicå‡½æ•°æŠ¥å‘Š r æ˜¯å¦è¢« Unicode å®šä¹‰ä¸ºå›¾å½¢å­—ç¬¦ã€‚è¿™äº›å­—ç¬¦åŒ…æ‹¬ç±»åˆ« Lã€Mã€Nã€Pã€Så’ŒZã€‚

#### IsGraphic Example
``` go 
package main

import (
	"fmt"
	"strconv"
)

func main() {
	shamrock := strconv.IsGraphic('â˜˜')
	fmt.Println(shamrock)

	a := strconv.IsGraphic('a')
	fmt.Println(a)

	bel := strconv.IsGraphic('\007')
	fmt.Println(bel)

}
Output:

true
true
false
```

### func IsPrint 

``` go 
func IsPrint(r rune) bool
```

IsPrint reports whether the rune is defined as printable by Go, with the same definition as unicode.IsPrint: letters, numbers, punctuation, symbols and ASCII space.

â€‹	IsPrint å‡½æ•°åˆ¤æ–­ rune æ˜¯å¦å¯æ‰“å°ï¼Œå…¶å®šä¹‰ä¸ unicode.IsPrint ç›¸åŒï¼šå­—æ¯ã€æ•°å­—ã€æ ‡ç‚¹ç¬¦å·ã€ç¬¦å·å’Œ ASCII ç©ºæ ¼éƒ½æ˜¯å¯æ‰“å°çš„ã€‚

#### IsPrint Example
``` go 
package main

import (
	"fmt"
	"strconv"
)

func main() {
	c := strconv.IsPrint('\u263a')
	fmt.Println(c)

	bel := strconv.IsPrint('\007')
	fmt.Println(bel)

}
Output:

true
false
```

### func Itoa 

``` go 
func Itoa(i int) string
```

Itoa is equivalent to FormatInt(int64(i), 10).

â€‹	Itoaå‡½æ•°å°† int ç±»å‹çš„ i è½¬æ¢æˆå¯¹åº”çš„åè¿›åˆ¶å­—ç¬¦ä¸²ã€‚

â€‹	Itoaå‡½æ•°ç­‰åŒäºFormatInt(int64(i), 10)ã€‚

#### Itoa Example
``` go 
package main

import (
	"fmt"
	"strconv"
)

func main() {
	i := 10
	s := strconv.Itoa(i)
	fmt.Printf("%T, %v\n", s, s)

}
Output:

string, 10
```

### func ParseBool 

``` go 
func ParseBool(str string) (bool, error)
```

ParseBool returns the boolean value represented by the string. It accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False. Any other value returns an error.

â€‹	ParseBool å‡½æ•°å°†å­—ç¬¦ä¸² str è§£æä¸º bool ç±»å‹çš„å€¼ã€‚å®ƒæ¥å— 1ã€tã€Tã€TRUEã€trueã€Trueã€0ã€fã€Fã€FALSEã€falseã€Falseï¼Œå…¶ä»–ä»»ä½•å€¼éƒ½ä¼šè¿”å›ä¸€ä¸ªé”™è¯¯ã€‚

#### ParseBool Example
``` go 
package main

import (
	"fmt"
	"strconv"
)

func main() {
	v := "true"
	if s, err := strconv.ParseBool(v); err == nil {
		fmt.Printf("%T, %v\n", s, s)
	}

}
Output:

bool, true
```

### func ParseComplex  <- go1.15

``` go 
func ParseComplex(s string, bitSize int) (complex128, error)
```

ParseComplex converts the string s to a complex number with the precision specified by bitSize: 64 for complex64, or 128 for complex128. When bitSize=64, the result still has type complex128, but it will be convertible to complex64 without changing its value.

â€‹	ParseComplexå‡½æ•°å°†å­—ç¬¦ä¸²sè½¬æ¢ä¸ºå¤æ•°ï¼Œç²¾åº¦ç”±bitSizeæŒ‡å®šï¼š64è¡¨ç¤ºcomplex64ï¼Œ128è¡¨ç¤ºcomplex128ã€‚å½“bitSize=64æ—¶ï¼Œç»“æœä»ä¸ºcomplex128ç±»å‹ï¼Œä½†å¯ä»¥è½¬æ¢ä¸ºcomplex64è€Œä¸æ”¹å˜å…¶å€¼ã€‚

The number represented by s must be of the form N, Ni, or NÂ±Ni, where N stands for a floating-point number as recognized by ParseFloat, and i is the imaginary component. If the second N is unsigned, a + sign is required between the two components as indicated by the Â±. If the second N is NaN, only a + sign is accepted. The form may be parenthesized and cannot contain any spaces. The resulting complex number consists of the two components converted by ParseFloat.

â€‹	sè¡¨ç¤ºä¸ºNã€Niæˆ–NÂ±Niçš„å½¢å¼ï¼Œå…¶ä¸­Nè¡¨ç¤ºç”±ParseFloatå‡½æ•°è¯†åˆ«çš„æµ®ç‚¹æ•°ï¼Œiæ˜¯è™šéƒ¨ã€‚å¦‚æœç¬¬äºŒä¸ªNæ˜¯æ— ç¬¦å·çš„ï¼Œåˆ™éœ€è¦+ç¬¦å·å°†ä¸¤ä¸ªç»„ä»¶è¿æ¥èµ·æ¥ï¼Œå¦‚Â±æ‰€ç¤ºã€‚å¦‚æœç¬¬äºŒä¸ªNæ˜¯NaNï¼Œåˆ™åªæ¥å—+ç¬¦å·ã€‚è¯¥å½¢å¼å¯ä»¥æ‹¬åœ¨æ‹¬å·ä¸­ï¼Œä¸èƒ½åŒ…å«ä»»ä½•ç©ºæ ¼ã€‚ç”±ParseFloatå‡½æ•°è½¬æ¢çš„ä¸¤ä¸ªç»„ä»¶æ„æˆçš„ç»“æœå¤æ•°ã€‚

The errors that ParseComplex returns have concrete type *NumError and include err.Num = s.

â€‹	ParseComplexå‡½æ•°è¿”å›çš„é”™è¯¯å…·æœ‰å…·ä½“ç±»å‹`*NumError`ï¼Œå¹¶åŒ…æ‹¬err.Num = sã€‚

If s is not syntactically well-formed, ParseComplex returns err.Err = ErrSyntax.

â€‹	å¦‚æœsçš„è¯­æ³•ä¸æ­£ç¡®ï¼Œåˆ™ParseComplexå‡½æ•°è¿”å›err.Err = ErrSyntaxã€‚

If s is syntactically well-formed but either component is more than 1/2 ULP away from the largest floating point number of the given component's size, ParseComplex returns err.Err = ErrRange and c = Â±Inf for the respective component.

â€‹	å¦‚æœsçš„è¯­æ³•æ­£ç¡®ï¼Œä½†ä»»ä¸€ç»„ä»¶è·ç¦»ç»™å®šç»„ä»¶å¤§å°çš„æœ€å¤§æµ®ç‚¹æ•°è¶…è¿‡1/2 ULPï¼Œåˆ™ParseComplexå‡½æ•°è¿”å›err.Err = ErrRangeå’Œc =Â±Infï¼Œåˆ†åˆ«å¯¹åº”äºç»„ä»¶ã€‚

### func ParseFloat 

``` go 
func ParseFloat(s string, bitSize int) (float64, error)
```

ParseFloat converts the string s to a floating-point number with the precision specified by bitSize: 32 for float32, or 64 for float64. When bitSize=32, the result still has type float64, but it will be convertible to float32 without changing its value.

â€‹	ParseFloatå‡½æ•°å°†å­—ç¬¦ä¸²sè½¬æ¢ä¸ºæµ®ç‚¹æ•°ï¼Œç²¾åº¦ç”±bitSizeæŒ‡å®šï¼š32è¡¨ç¤ºfloat32ï¼Œ64è¡¨ç¤ºfloat64ã€‚å½“bitSize=32æ—¶ï¼Œç»“æœä»ä¸ºfloat64ç±»å‹ï¼Œä½†å¯ä»¥è½¬æ¢ä¸ºfloat32è€Œä¸æ”¹å˜å…¶å€¼ã€‚

ParseFloat accepts decimal and hexadecimal floating-point numbers as defined by the Go syntax for [floating-point literals](https://go.dev/ref/spec#Floating-point_literals). If s is well-formed and near a valid floating-point number, ParseFloat returns the nearest floating-point number rounded using IEEE754 unbiased rounding. (Parsing a hexadecimal floating-point value only rounds when there are more bits in the hexadecimal representation than will fit in the mantissa.)

â€‹	ParseFloatå‡½æ•°æ¥å—åè¿›åˆ¶å’Œåå…­è¿›åˆ¶çš„æµ®ç‚¹æ•°ï¼Œè¿™æ˜¯Goè¯­æ³•å¯¹æµ®ç‚¹æ•°å­—é¢çš„å®šä¹‰ã€‚å¦‚æœsæ˜¯æ ¼å¼è‰¯å¥½ä¸”æ¥è¿‘æœ‰æ•ˆçš„æµ®ç‚¹æ•°ï¼ŒParseFloatå‡½æ•°ä¼šè¿”å›æœ€è¿‘çš„æµ®ç‚¹æ•°ï¼Œå¹¶ä½¿ç”¨IEEE754æ— åå·®å››èˆäº”å…¥ã€‚(è§£æåå…­è¿›åˆ¶æµ®ç‚¹æ•°æ—¶ï¼Œåªæœ‰å½“åå…­è¿›åˆ¶è¡¨ç¤ºçš„ä½æ•°å¤šäºå°¾æ•°æ—¶æ‰ä¼šè¿›è¡Œå››èˆäº”å…¥)ã€‚

The errors that ParseFloat returns have concrete type *NumError and include err.Num = s.

â€‹	ParseFloatå‡½æ•°è¿”å›çš„é”™è¯¯å…·æœ‰å…·ä½“ç±»å‹`*NumError`ï¼Œå¹¶åŒ…æ‹¬err.Num = sã€‚

If s is not syntactically well-formed, ParseFloat returns err.Err = ErrSyntax.

â€‹	å¦‚æœsçš„è¯­æ³•ä¸æ­£ç¡®ï¼Œåˆ™ParseFloatå‡½æ•°è¿”å›err.Err = ErrSyntaxã€‚

If s is syntactically well-formed but is more than 1/2 ULP away from the largest floating point number of the given size, ParseFloat returns f = Â±Inf, err.Err = ErrRange.

â€‹	å¦‚æœsçš„è¯­æ³•æ­£ç¡®ï¼Œä½†è·ç¦»ç»™å®šå¤§å°çš„æœ€å¤§æµ®ç‚¹æ•°è¶…è¿‡1/2 ULPï¼Œåˆ™ParseFloatå‡½æ•°è¿”å›f =Â±Infï¼Œerr.Err = ErrRangeã€‚

ParseFloat recognizes the string "NaN", and the (possibly signed) strings "Inf" and "Infinity" as their respective special floating point values. It ignores case when matching.

â€‹	ParseFloatå‡½æ•°å°†å­—ç¬¦ä¸²"NaN"å’Œ(å¯èƒ½å¸¦ç¬¦å·çš„)å­—ç¬¦ä¸²"Inf"å’Œ"Infinity"è¯†åˆ«ä¸ºå®ƒä»¬å„è‡ªçš„ç‰¹æ®Šæµ®ç‚¹å€¼ã€‚å®ƒåœ¨åŒ¹é…æ—¶å¿½ç•¥å¤§å°å†™ã€‚

#### ParseFloat Example
``` go 
package main

import (
	"fmt"
	"strconv"
)

func main() {
	v32 := "-354634382"
	if s, err := strconv.ParseInt(v32, 10, 32); err == nil {
		fmt.Printf("%T, %v\n", s, s)
	}
	if s, err := strconv.ParseInt(v32, 16, 32); err == nil {
		fmt.Printf("%T, %v\n", s, s)
	}

	v64 := "-3546343826724305832"
	if s, err := strconv.ParseInt(v64, 10, 64); err == nil {
		fmt.Printf("%T, %v\n", s, s)
	}
	if s, err := strconv.ParseInt(v64, 16, 64); err == nil {
		fmt.Printf("%T, %v\n", s, s)
	}

}

```

### func ParseInt 

``` go 
func ParseInt(s string, base int, bitSize int) (i int64, err error)
```

ParseInt interprets a string s in the given base (0, 2 to 36) and bit size (0 to 64) and returns the corresponding value i.

â€‹	ParseIntå‡½æ•°å°†ç»™å®šè¿›åˆ¶(0ã€2åˆ°36)å’Œä½å¤§å°(0åˆ°64)çš„å­—ç¬¦ä¸²sè§£é‡Šä¸ºå¯¹åº”çš„å€¼iå¹¶è¿”å›ã€‚

The string may begin with a leading sign: "+" or "-".

â€‹	å­—ç¬¦ä¸²å¯èƒ½ä»¥ç¬¦å·"+"æˆ–"-"å¼€å¤´ã€‚

If the base argument is 0, the true base is implied by the string's prefix following the sign (if present): 2 for "0b", 8 for "0" or "0o", 16 for "0x", and 10 otherwise. Also, for argument base 0 only, underscore characters are permitted as defined by the Go syntax for [integer literals](https://go.dev/ref/spec#Integer_literals).

â€‹	å¦‚æœbaseå‚æ•°ä¸º0ï¼Œåˆ™çœŸå®åŸºæ•°æ˜¯ç”±å­—ç¬¦ä¸²å‰ç¼€éšåçš„ç¬¦å·(å¦‚æœå­˜åœ¨)éšå«æŒ‡å®šçš„ï¼šå¯¹äº"0b"ï¼ŒåŸºæ•°ä¸º2ï¼›å¯¹äº"0"æˆ–"0o"ï¼ŒåŸºæ•°ä¸º8ï¼›å¯¹äº"0x"ï¼ŒåŸºæ•°ä¸º16ï¼›å¦åˆ™åŸºæ•°ä¸º10ã€‚æ­¤å¤–ï¼Œä»…é’ˆå¯¹baseä¸º0çš„æƒ…å†µï¼Œæ ¹æ®Goæ•´æ•°å­—é¢é‡çš„è¯­æ³•ï¼Œä¸‹åˆ’çº¿å­—ç¬¦æ˜¯å…è®¸çš„ã€‚

The bitSize argument specifies the integer type that the result must fit into. Bit sizes 0, 8, 16, 32, and 64 correspond to int, int8, int16, int32, and int64. If bitSize is below 0 or above 64, an error is returned.

â€‹	bitSizeå‚æ•°æŒ‡å®šç»“æœå¿…é¡»é€‚åˆçš„æ•´æ•°ç±»å‹ã€‚ä½å¤§å°0ã€8ã€16ã€32å’Œ64å¯¹åº”äºintã€int8ã€int16ã€int32å’Œint64ã€‚å¦‚æœbitSizeå°äº0æˆ–å¤§äº64ï¼Œåˆ™ä¼šè¿”å›é”™è¯¯ã€‚

The errors that ParseInt returns have concrete type *NumError and include err.Num = s. If s is empty or contains invalid digits, err.Err = ErrSyntax and the returned value is 0; if the value corresponding to s cannot be represented by a signed integer of the given size, err.Err = ErrRange and the returned value is the maximum magnitude integer of the appropriate bitSize and sign.

â€‹	ParseIntå‡½æ•°è¿”å›çš„é”™è¯¯å…·æœ‰å…·ä½“ç±»å‹`*NumError`ï¼Œå¹¶åŒ…æ‹¬err.Num = sã€‚å¦‚æœsä¸ºç©ºæˆ–åŒ…å«æ— æ•ˆæ•°å­—ï¼Œåˆ™err.Err = ErrSyntaxï¼Œè¿”å›å€¼ä¸º0ï¼›å¦‚æœså¯¹åº”çš„å€¼æ— æ³•ç”±ç»™å®šå¤§å°çš„æœ‰ç¬¦å·æ•´æ•°è¡¨ç¤ºï¼Œåˆ™err.Err = ErrRangeï¼Œè¿”å›å€¼ä¸ºé€‚å½“çš„bitSizeå’Œç¬¦å·çš„æœ€å¤§å¹…åº¦æ•´æ•°ã€‚

#### ParseInt Example
``` go 
package main

import (
	"fmt"
	"strconv"
)

func main() {
	v := "42"
	if s, err := strconv.ParseUint(v, 10, 32); err == nil {
		fmt.Printf("%T, %v\n", s, s)
	}
	if s, err := strconv.ParseUint(v, 10, 64); err == nil {
		fmt.Printf("%T, %v\n", s, s)
	}

}
Output:

uint64, 42
uint64, 42
```

### func ParseUint 

``` go 
func ParseUint(s string, base int, bitSize int) (uint64, error)
```

ParseUint is like ParseInt but for unsigned numbers.

â€‹	ParseUintå‡½æ•°ç±»ä¼¼äºParseIntå‡½æ•°ï¼Œä½†ç”¨äºæ— ç¬¦å·æ•°å­—ã€‚

A sign prefix is not permitted.

â€‹	ä¸å…è®¸ç¬¦å·å‰ç¼€ã€‚

#### ParseUint Example
``` go 
package main

import (
	"fmt"
	"strconv"
)

func main() {
	// This string literal contains a tab character.
	s := strconv.Quote(`"Fran & Freddie's Diner	â˜º"`)
	fmt.Println(s)

}
Output:

"\"Fran & Freddie's Diner\tâ˜º\""
```

### func Quote 

``` go 
func Quote(s string) string
```

Quote returns a double-quoted Go string literal representing s. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for control characters and non-printable characters as defined by IsPrint.

â€‹	Quoteå‡½æ•°è¿”å›è¡¨ç¤ºå­—ç¬¦ä¸²sçš„åŒå¼•å·Goå­—ç¬¦ä¸²æ–‡æœ¬ã€‚è¿”å›çš„å­—ç¬¦ä¸²ä½¿ç”¨Goè½¬ä¹‰åºåˆ—(\tï¼Œ\nï¼Œ\xFFï¼Œ\u0100)è¡¨ç¤ºæ§åˆ¶å­—ç¬¦å’Œéå¯æ‰“å°å­—ç¬¦ï¼Œå¦‚IsPrintå®šä¹‰çš„ã€‚

#### Quote Example
``` go 
package main

import (
	"fmt"
	"strconv"
)

func main() {
	// This string literal contains a tab character.
	s := strconv.Quote(`"Fran & Freddie's Diner	â˜º"`)
	fmt.Println(s)

}
Output:

"\"Fran & Freddie's Diner\tâ˜º\""
```

### func QuoteRune 

``` go 
func QuoteRune(r rune) string
```

QuoteRune returns a single-quoted Go character literal representing the rune. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for control characters and non-printable characters as defined by IsPrint. If r is not a valid Unicode code point, it is interpreted as the Unicode replacement character U+FFFD.

â€‹	QuoteRuneå‡½æ•°è¿”å›è¡¨ç¤ºç¬¦æ–‡çš„å•å¼•å·Goå­—ç¬¦æ–‡æœ¬ã€‚è¿”å›çš„å­—ç¬¦ä¸²ä½¿ç”¨Goè½¬ä¹‰åºåˆ—(\tï¼Œ\nï¼Œ\xFFï¼Œ\u0100)è¡¨ç¤ºæ§åˆ¶å­—ç¬¦å’Œéå¯æ‰“å°å­—ç¬¦ï¼Œå¦‚IsPrintå‡½æ•°å®šä¹‰çš„ã€‚å¦‚æœrä¸æ˜¯æœ‰æ•ˆçš„Unicodeä»£ç ç‚¹ï¼Œåˆ™å°†å…¶è§£é‡Šä¸ºUnicodeæ›¿æ¢å­—ç¬¦U+FFFDã€‚

> `\u`å’Œ`\U`è½¬ä¹‰å­—ç¬¦è¡¨ç¤ºUnicodeç¼–ç æ—¶ï¼Œåé¢å¿…é¡»è·Ÿç€4ä¸ª(`\u`)æˆ–8ä¸ª(`\U`)åå…­è¿›åˆ¶æ•°å­—æ¥è¡¨ç¤ºè¯¥å­—ç¬¦çš„Unicodeç¼–ç ï¼Œä¾‹å¦‚`\u4E2D`è¡¨ç¤ºä¸­æ–‡å­—ç¬¦"ä¸­"çš„Unicodeç¼–ç ï¼Œ`\U0001F600`è¡¨ç¤ºç¬‘è„¸è¡¨æƒ…çš„Unicodeç¼–ç ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œ`\u`åªèƒ½ç”¨æ¥è¡¨ç¤ºç ä½åœ¨BMP(åŸºæœ¬å¤šæ–‡ç§å¹³é¢ï¼Œå³Unicodeçš„ç¬¬0å¹³é¢)ä¸­çš„å­—ç¬¦ï¼Œè€Œ`\U`å¯ä»¥ç”¨æ¥è¡¨ç¤ºç ä½åœ¨ä»»æ„å¹³é¢çš„å­—ç¬¦ã€‚
>
> â€‹	U+æ•°å­—è¡¨ç¤ºUnicodeç¼–ç æ—¶ï¼ŒUåé¢ç´§è·Ÿç€çš„æ•°å­—è¡¨ç¤ºè¯¥å­—ç¬¦çš„Unicodeç¼–ç å€¼ï¼Œä¾‹å¦‚U+4E2Dè¡¨ç¤ºä¸­æ–‡å­—ç¬¦"ä¸­"çš„Unicodeç¼–ç ï¼ŒU+1F600è¡¨ç¤ºç¬‘è„¸è¡¨æƒ…çš„Unicodeç¼–ç ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒU+æ•°å­—åªèƒ½ç”¨æ¥è¡¨ç¤ºç ä½åœ¨BMPä¸­çš„å­—ç¬¦ï¼Œè€Œä¸èƒ½è¡¨ç¤ºç ä½åœ¨å…¶ä»–å¹³é¢ä¸­çš„å­—ç¬¦ï¼Œéœ€è¦ä½¿ç”¨`\U`æˆ–è€…ä¸“é—¨çš„éBMPç¼–ç æ–¹å¼æ¥è¡¨ç¤ºã€‚
>
> â€‹	æ€»ä¹‹ï¼Œ`\u`å’Œ`\U`æ˜¯è¡¨ç¤ºUnicodeç¼–ç çš„é€šç”¨è½¬ä¹‰å­—ç¬¦ï¼Œé€‚ç”¨äºä»»ä½•å­—ç¬¦ï¼Œè€ŒU+æ•°å­—åªé€‚ç”¨äºç ä½åœ¨BMPä¸­çš„å­—ç¬¦ã€‚

> BMP(Basic Multilingual Planeï¼ŒåŸºæœ¬å¤šæ–‡ç§å¹³é¢)æ˜¯ Unicode æ ‡å‡†ä¸­çš„ä¸€ä¸ªå­—ç¬¦ç¼–ç å¹³é¢ï¼Œå…¶ä¸­åŒ…å«äº† 0x0000 è‡³ 0xFFFF è¿™ 65536 ä¸ªå­—ç¬¦çš„ç¼–ç ã€‚è¿™ä¸ªç¼–ç èŒƒå›´å†…åŒ…å«äº†å¤§éƒ¨åˆ†å¸¸ç”¨çš„å­—ç¬¦ï¼Œå¦‚ ASCII ç ä¸­çš„å­—ç¬¦ã€æ‹‰ä¸å­—æ¯ã€å¸Œè…Šå­—æ¯ã€è¥¿é‡Œå°”å­—æ¯ã€æ±‰å­—ç­‰ç­‰ã€‚å› æ­¤ï¼ŒBMP å¹³é¢ä¹Ÿè¢«ç§°ä¸º Unicode å­—ç¬¦é›†çš„æ ¸å¿ƒåŒºåŸŸã€‚
>
> åœ¨ Go è¯­è¨€ä¸­ï¼Œä½¿ç”¨ `\u`+å››ä½åå…­è¿›åˆ¶æ•°æ¥è¡¨ç¤º BMP å¹³é¢ä¸­çš„ Unicode å­—ç¬¦ã€‚ä¾‹å¦‚ï¼Œ`\u4e2d`è¡¨ç¤ºæ±‰å­—"ä¸­"çš„ Unicode ç¼–ç  U+4E2Dã€‚è€Œä½¿ç”¨ `\U`+å…«ä½åå…­è¿›åˆ¶æ•°æ¥è¡¨ç¤º Unicode å­—ç¬¦ï¼Œè¿™ç§è¡¨ç¤ºæ–¹å¼å¯ä»¥ç”¨æ¥è¡¨ç¤º BMP å¹³é¢ä»¥å¤–çš„å­—ç¬¦ï¼Œä¾‹å¦‚ `\U0001F600` è¡¨ç¤ºä¸€ä¸ªç¬‘è„¸è¡¨æƒ…"ğŸ˜€"ï¼Œå®ƒçš„ Unicode ç¼–ç ä¸º U+1F600ï¼Œè¶…å‡ºäº† BMP å¹³é¢çš„ç¼–ç èŒƒå›´ã€‚

#### QuoteRune Example
``` go 
package main

import (
	"fmt"
	"strconv"
)

func main() {
	s := strconv.QuoteRune('â˜º')
	fmt.Println(s)

}
Output:

'â˜º'
```

### func QuoteRuneToASCII 

``` go 
func QuoteRuneToASCII(r rune) string
```

QuoteRuneToASCII returns a single-quoted Go character literal representing the rune. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for non-ASCII characters and non-printable characters as defined by IsPrint. If r is not a valid Unicode code point, it is interpreted as the Unicode replacement character U+FFFD.

â€‹	QuoteRuneToASCIIå‡½æ•°è¿”å›è¡¨ç¤ºç¬¦æ–‡çš„ Go å•å¼•å·å­—ç¬¦å­—é¢é‡ã€‚è¿”å›çš„å­—ç¬¦ä¸²ä½¿ç”¨ Go è½¬ä¹‰åºåˆ— (\t, \n, \xFF, \u0100) è¡¨ç¤ºé ASCII å­—ç¬¦å’Œç”± IsPrint å®šä¹‰çš„ä¸å¯æ‰“å°å­—ç¬¦ã€‚å¦‚æœ r ä¸æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„ Unicode ä»£ç ç‚¹ï¼Œåˆ™å°†å…¶è§£é‡Šä¸º Unicode æ›¿æ¢å­—ç¬¦ U+FFFDã€‚

#### QuoteRuneToASCII Example
``` go 
package main

import (
	"fmt"
	"strconv"
)

func main() {
	s := strconv.QuoteRuneToASCII('â˜º')
	fmt.Println(s)

}
Output:

'\u263a'
```

### func QuoteRuneToGraphic  <- go1.6

``` go 
func QuoteRuneToGraphic(r rune) string
```

QuoteRuneToGraphic returns a single-quoted Go character literal representing the rune. If the rune is not a Unicode graphic character, as defined by IsGraphic, the returned string will use a Go escape sequence (\t, \n, \xFF, \u0100). If r is not a valid Unicode code point, it is interpreted as the Unicode replacement character U+FFFD.

â€‹	QuoteRuneToGraphicå‡½æ•°è¿”å›è¡¨ç¤ºç¬¦æ–‡çš„ Go å•å¼•å·å­—ç¬¦å­—é¢é‡ã€‚å¦‚æœç¬¦æ–‡ä¸æ˜¯ä¸€ä¸ª Unicode å›¾å½¢å­—ç¬¦ï¼Œå¦‚ç”± IsGraphicå‡½æ•°å®šä¹‰ï¼Œè¿”å›çš„å­—ç¬¦ä¸²å°†ä½¿ç”¨ Go è½¬ä¹‰åºåˆ— (\t, \n, \xFF, \u0100)ã€‚å¦‚æœ r ä¸æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„ Unicode ä»£ç ç‚¹ï¼Œåˆ™å°†å…¶è§£é‡Šä¸º Unicode æ›¿æ¢å­—ç¬¦ U+FFFDã€‚

#### QuoteRuneToGraphic Example
``` go 
package main

import (
	"fmt"
	"strconv"
)

func main() {
	s := strconv.QuoteRuneToGraphic('â˜º')
	fmt.Println(s)

	s = strconv.QuoteRuneToGraphic('\u263a')
	fmt.Println(s)

	s = strconv.QuoteRuneToGraphic('\u000a')
	fmt.Println(s)

	s = strconv.QuoteRuneToGraphic('	') // tab character
	fmt.Println(s)

}
Output:

'â˜º'
'â˜º'
'\n'
'\t'
```

### func QuoteToASCII 

``` go 
func QuoteToASCII(s string) string
```

QuoteToASCII returns a double-quoted Go string literal representing s. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for non-ASCII characters and non-printable characters as defined by IsPrint.

â€‹	QuoteToASCIIå‡½æ•°è¿”å›è¡¨ç¤ºå­—ç¬¦ä¸² s çš„ Go åŒå¼•å·å­—ç¬¦ä¸²å­—é¢é‡ã€‚è¿”å›çš„å­—ç¬¦ä¸²ä½¿ç”¨ Go è½¬ä¹‰åºåˆ— (\t, \n, \xFF, \u0100) è¡¨ç¤ºé ASCII å­—ç¬¦å’Œç”± IsPrintå‡½æ•°å®šä¹‰çš„ä¸å¯æ‰“å°å­—ç¬¦ã€‚

#### QuoteToASCII Example
``` go 
package main

import (
	"fmt"
	"strconv"
)

func main() {
	// è¿™ä¸ªå­—ç¬¦ä¸²å­—é¢é‡åŒ…å«ä¸€ä¸ªåˆ¶è¡¨ç¬¦ã€‚
	s := strconv.QuoteToASCII(`"Fran & Freddie's Diner	â˜º"`)
	fmt.Println(s)

}
Output:

"\"Fran & Freddie's Diner\t\u263a\""
```

### func QuoteToGraphic  <- go1.6

``` go 
func QuoteToGraphic(s string) string
```

QuoteToGraphic returns a double-quoted Go string literal representing s. The returned string leaves Unicode graphic characters, as defined by IsGraphic, unchanged and uses Go escape sequences (\t, \n, \xFF, \u0100) for non-graphic characters.

â€‹	QuoteToGraphicå‡½æ•°è¿”å›è¡¨ç¤ºå­—ç¬¦ä¸² s çš„ Go åŒå¼•å·å­—ç¬¦ä¸²å­—é¢é‡ã€‚è¿”å›çš„å­—ç¬¦ä¸²ä¿ç•™ Unicode å›¾å½¢å­—ç¬¦(ç”± IsGraphicå‡½æ•°å®šä¹‰)ï¼Œå¯¹äºéå›¾å½¢å­—ç¬¦ä½¿ç”¨ Go è½¬ä¹‰åºåˆ— (\t, \n, \xFF, \u0100)ã€‚

#### QuoteToGraphic Example
``` go 
package main

import (
	"fmt"
	"strconv"
)

func main() {
	s := strconv.QuoteToGraphic("â˜º")
	fmt.Println(s)

	// This string literal contains a tab character.
	s = strconv.QuoteToGraphic("This is a \u263a	\u000a")
	fmt.Println(s)

	s = strconv.QuoteToGraphic(`" This is a â˜º \n "`)
	fmt.Println(s)

}
Output:

"â˜º"
"This is a â˜º\t\n"
"\" This is a â˜º \\n \""
```

### func QuotedPrefix  <- go1.17

``` go 
func QuotedPrefix(s string) (string, error)
```

QuotedPrefix returns the quoted string (as understood by Unquote) at the prefix of s. If s does not start with a valid quoted string, QuotedPrefix returns an error.

â€‹	QuotedPrefixå‡½æ•°è¿”å› s çš„å‰ç¼€å¤„çš„å¸¦å¼•å·å­—ç¬¦ä¸²(å¦‚ Unquoteå‡½æ•°ç†è§£çš„é‚£æ ·)ã€‚å¦‚æœ s ä¸ä»¥æœ‰æ•ˆçš„å¸¦å¼•å·å­—ç¬¦ä¸²å¼€å¤´ï¼Œåˆ™ QuotedPrefixå‡½æ•°è¿”å›ä¸€ä¸ªé”™è¯¯ã€‚

### func Unquote 

``` go 
func Unquote(s string) (string, error)
```

Unquote interprets s as a single-quoted, double-quoted, or backquoted Go string literal, returning the string value that s quotes. (If s is single-quoted, it would be a Go character literal; Unquote returns the corresponding one-character string.)

â€‹	Unquoteå‡½æ•°å°† s è§£é‡Šä¸ºå•å¼•å·ã€åŒå¼•å·æˆ–åå¼•å·åŒ…è£¹çš„ Go å­—ç¬¦ä¸²å­—é¢é‡ï¼Œå¹¶è¿”å› s å¼•ç”¨çš„å­—ç¬¦ä¸²å€¼ã€‚(å¦‚æœ s æ˜¯å•å¼•å·å¼•ç”¨çš„ï¼Œåˆ™å®ƒæ˜¯ä¸€ä¸ª Go å­—ç¬¦å­—é¢é‡ï¼›Unquoteå‡½æ•°è¿”å›ç›¸åº”çš„å•ä¸ªå­—ç¬¦å­—ç¬¦ä¸²ã€‚)

> â€‹	Unquote å‡½æ•°æ¥æ”¶ä¸€ä¸ªå­—ç¬¦ä¸²å‚æ•° sï¼Œå¹¶è¿”å›ä¸€ä¸ªè§£æåçš„å­—ç¬¦ä¸²å€¼å’Œä¸€ä¸ªé”™è¯¯ã€‚å¦‚æœè§£ææˆåŠŸï¼Œåˆ™è¯¥é”™è¯¯ä¸º nilï¼›å¦åˆ™ï¼Œé”™è¯¯åŒ…å«ä¸€ä¸ªå…·ä½“çš„é”™è¯¯æ¶ˆæ¯ã€‚
>
> â€‹	Unquote å‡½æ•°æ”¯æŒä¸‰ç§å¼•å·ç±»å‹ï¼šå•å¼•å·ã€åŒå¼•å·å’Œåå¼•å·ã€‚å…¶ä¸­ï¼Œå•å¼•å·è¡¨ç¤º Go è¯­è¨€å­—ç¬¦å­—é¢å€¼ï¼ŒåŒå¼•å·è¡¨ç¤º Go è¯­è¨€å­—ç¬¦ä¸²å­—é¢å€¼ï¼Œåå¼•å·è¡¨ç¤º Go è¯­è¨€åŸå§‹å­—ç¬¦ä¸²å­—é¢å€¼ã€‚
>
> â€‹	åœ¨è§£æå­—ç¬¦ä¸²å­—é¢å€¼æ—¶ï¼ŒUnquote å‡½æ•°ä¼šè‡ªåŠ¨å¤„ç†è½¬ä¹‰å­—ç¬¦ï¼Œä¾‹å¦‚ \tã€\nã€" å’Œ ' ç­‰ã€‚åŒæ—¶ï¼Œå®ƒè¿˜æ”¯æŒ Unicode è½¬ä¹‰ï¼Œä¾‹å¦‚ \uXXXX å’Œ \UXXXXXXXXã€‚

#### Unquote Example
``` go 
package main

import (
	"fmt"
	"strconv"
)

func main() {
    s, err := strconv.Unquote(`"You can unquote a string with quotes"`)
	fmt.Printf("%q, %v\n", s, err)
	s, err := strconv.Unquote("You can't unquote a string without quotes")
	fmt.Printf("%q, %v\n", s, err)
	s, err = strconv.Unquote("\"The string must be either double-quoted\"")
	fmt.Printf("%q, %v\n", s, err)
	s, err = strconv.Unquote("`or backquoted.`")
	fmt.Printf("%q, %v\n", s, err)
	s, err = strconv.Unquote("'\u263a'") // single character only allowed in single quotes
	fmt.Printf("%q, %v\n", s, err)
	s, err = strconv.Unquote("'\u2639\u2639'")
	fmt.Printf("%q, %v\n", s, err)

}
Output:
"You can unquote a string with quotes",<nil>
"", invalid syntax
"The string must be either double-quoted", <nil>
"or backquoted.", <nil>
"â˜º", <nil>
"", invalid syntax
```

### func UnquoteChar 

``` go 
func UnquoteChar(s string, quote byte) (value rune, multibyte bool, tail string, err error)
```

UnquoteChar decodes the first character or byte in the escaped string or character literal represented by the string s. It returns four values:

â€‹	UnquoteCharå‡½æ•°è§£ç å­—ç¬¦ä¸² s ä¸­è½¬ä¹‰çš„å­—ç¬¦ä¸²æˆ–å­—ç¬¦å­—é¢å€¼è¡¨ç¤ºçš„ç¬¬ä¸€ä¸ªå­—ç¬¦æˆ–å­—èŠ‚ã€‚å®ƒè¿”å›å››ä¸ªå€¼ï¼š

1. value, the decoded Unicode code point or byte value;
2. valueï¼Œè§£ç åçš„ Unicode ç ç‚¹æˆ–å­—èŠ‚å€¼ï¼› 
3. multibyte, a boolean indicating whether the decoded character requires a multibyte UTF-8 representation;
4. multibyteï¼Œä¸€ä¸ªå¸ƒå°”å€¼ï¼ŒæŒ‡ç¤ºè§£ç åçš„å­—ç¬¦æ˜¯å¦éœ€è¦å¤šå­—èŠ‚ UTF-8 è¡¨ç¤ºå½¢å¼ï¼› 
5. tail, the remainder of the string after the character; and
6. tailï¼Œå­—ç¬¦ä¹‹åå‰©ä½™çš„å­—ç¬¦ä¸²ï¼› 
7. an error that will be nil if the character is syntactically valid.
8. ä¸€ä¸ªé”™è¯¯ï¼Œå¦‚æœå­—ç¬¦åœ¨è¯­æ³•ä¸Šæœ‰æ•ˆï¼Œåˆ™ä¸º nilã€‚

The second argument, quote, specifies the type of literal being parsed and therefore which escaped quote character is permitted. If set to a single quote, it permits the sequence \' and disallows unescaped '. If set to a double quote, it permits \" and disallows unescaped ". If set to zero, it does not permit either escape and allows both quote characters to appear unescaped.

â€‹	ç¬¬äºŒä¸ªå‚æ•° quote æŒ‡å®šè¦è§£æçš„æ–‡æœ¬ç±»å‹ï¼Œå› æ­¤å…è®¸å“ªä¸ªè½¬ä¹‰å¼•å·å­—ç¬¦ã€‚å¦‚æœè®¾ç½®ä¸ºå•å¼•å·ï¼Œåˆ™å…è®¸åºåˆ— `'`ï¼Œå¹¶ç¦æ­¢æœªè½¬ä¹‰çš„`'`ã€‚å¦‚æœè®¾ç½®ä¸ºåŒå¼•å·ï¼Œåˆ™å…è®¸ `"` å¹¶ç¦æ­¢æœªè½¬ä¹‰çš„`"`ã€‚å¦‚æœè®¾ç½®ä¸ºé›¶å€¼ï¼Œåˆ™ä¸å…è®¸ä»»ä½•è½¬ä¹‰ï¼Œä¸”å…è®¸ä¸¤ä¸ªå¼•å·å­—ç¬¦æœªè½¬ä¹‰å‡ºç°ã€‚

#### UnquoteChar Example
``` go 
package main

import (
	"fmt"
	"log"
	"strconv"
)

func main() {
	v, mb, t, err := strconv.UnquoteChar(`\"Fran & Freddie's Diner\"`, '"')
	if err != nil {
		log.Fatal(err)
	}

	fmt.Println("value:", string(v))
	fmt.Println("multibyte:", mb)
	fmt.Println("tail:", t)
    // è§£ç è½¬ä¹‰å­—ç¬¦
    s := `\"hello\"`
    value, multibyte, tail, err := strconv.UnquoteChar(s, '"')
    if err != nil {
        fmt.Println(err)
    }
    fmt.Println(value, multibyte, tail)
	// è§£ç Unicodeå­—ç¬¦
	s = `\u0048\u0065\u006c\u006c\u006f\u0020\u0057\u006f\u0072\u006c\u0064`
    value, multibyte, tail, err = strconv.UnquoteChar(s, '\'')
    if err != nil {
        fmt.Println(err)
    }
    fmt.Printf("%c %t %s", value, multibyte, tail)

}
Output:

value: "
multibyte: false
tail: Fran & Freddie's Diner\"
34 false hello\"
H true \u0065\u006c\u006c\u006f\u0020\u0057\u006f\u0072\u006c\u0064
```

## ç±»å‹

### type NumError 

``` go 
type NumError struct {
	Func string // å¤±è´¥çš„å‡½æ•°(ParseBool, ParseInt, ParseUint, ParseFloat, ParseComplex) the failing function (ParseBool, ParseInt, ParseUint, ParseFloat, ParseComplex)
	Num  string // è¾“å…¥çš„æ•°æ® the input
	Err  error  // è½¬æ¢å¤±è´¥çš„åŸå› (ä¾‹å¦‚ ErrRange, ErrSyntax, ç­‰)ã€‚ the reason the conversion failed (e.g. ErrRange, ErrSyntax, etc.)
}
```

A NumError records a failed conversion.

â€‹	NumErrorå‡½æ•°è®°å½•äº†è½¬æ¢å¤±è´¥çš„æƒ…å†µã€‚

#### Example
``` go 
package main

import (
	"fmt"
	"strconv"
)

func main() {
	str := "Not a number"
	if _, err := strconv.ParseFloat(str, 64); err != nil {
		e := err.(*strconv.NumError)
		fmt.Println("Func:", e.Func)
		fmt.Println("Num:", e.Num)
		fmt.Println("Err:", e.Err)
		fmt.Println(err)
	}

}
Output:

Func: ParseFloat
Num: Not a number
Err: invalid syntax
strconv.ParseFloat: parsing "Not a number": invalid syntax
```

#### (*NumError) Error 

``` go 
func (e *NumError) Error() string
```

#### (*NumError) Unwrap  <- go1.14

``` go 
func (e *NumError) Unwrap() error
```