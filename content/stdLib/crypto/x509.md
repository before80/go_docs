+++
title = "x509"
date = 2023-05-17T11:11:20+08:00
type = "docs"
description = ""
isCJKLanguage = true
draft = false
+++
> 原文：[https://pkg.go.dev/crypto/x509@go1.21.3](https://pkg.go.dev/crypto/x509@go1.21.3)

Package x509 implements a subset of the X.509 standard.

​	x509 包实现 X.509 标准的子集。

It allows parsing and generating certificates, certificate signing requests, certificate revocation lists, and encoded public and private keys. It provides a certificate verifier, complete with a chain builder.

​	它允许解析和生成证书、证书签名请求、证书吊销列表以及编码的公钥和私钥。它提供了一个证书验证器，并配有一个链构建器。

The package targets the X.509 technical profile defined by the IETF ([RFC 2459](https://rfc-editor.org/rfc/rfc2459.html)/3280/5280), and as further restricted by the CA/Browser Forum Baseline Requirements. There is minimal support for features outside of these profiles, as the primary goal of the package is to provide compatibility with the publicly trusted TLS certificate ecosystem and its policies and constraints.

​	该包针对 IETF（RFC 2459/3280/5280）定义的 X.509 技术规范，并进一步受到 CA/浏览器论坛基线要求的限制。对这些配置文件之外的功能的支持最少，因为该包的主要目标是提供与公认的受信任 TLS 证书生态系统及其策略和约束的兼容性。

On macOS and Windows, certificate verification is handled by system APIs, but the package aims to apply consistent validation rules across operating systems.

​	在 macOS 和 Windows 上，证书验证由系统 API 处理，但该包旨在跨操作系统应用一致的验证规则。

## 常量 

This section is empty.

## 变量

[View Source](https://cs.opensource.google/go/go/+/go1.20.1:src/crypto/x509/x509.go;l=780)

``` go
var ErrUnsupportedAlgorithm = errors.New("x509: cannot verify signature: algorithm unimplemented")
```

ErrUnsupportedAlgorithm results from attempting to perform an operation that involves algorithms that are not currently implemented.

​	ErrUnsupportedAlgorithm 是由于尝试执行涉及尚未实现的算法的操作而导致的。

[View Source](https://cs.opensource.google/go/go/+/go1.20.1:src/crypto/x509/pem_decrypt.go;l=110)

``` go
var IncorrectPasswordError = errors.New("x509: decryption password incorrect")
```

IncorrectPasswordError is returned when an incorrect password is detected.

​	检测到密码不正确时，将返回 IncorrectPasswordError。

## 函数

### func CreateCertificate 

``` go
func CreateCertificate(rand io.Reader, template, parent *Certificate, pub, priv any) ([]byte, error)
```

CreateCertificate creates a new X.509 v3 certificate based on a template. The following members of template are currently used:

​	CreateCertificate 根据模板创建一个新的 X.509 v3 证书。模板的以下成员当前正在使用：

- AuthorityKeyId
- BasicConstraintsValid
- CRLDistributionPoints
- DNSNames
- EmailAddresses
- ExcludedDNSDomains
- ExcludedEmailAddresses
- ExcludedIPRanges
- ExcludedURIDomains
- ExtKeyUsage
- ExtraExtensions
- IPAddresses
- IsCA
- IssuingCertificateURL
- KeyUsage
- MaxPathLen
- MaxPathLenZero
- NotAfter
- NotBefore
- OCSPServer
- PermittedDNSDomains
- PermittedDNSDomainsCritical
- PermittedEmailAddresses
- PermittedIPRanges
- PermittedURIDomains
- PolicyIdentifiers
- SerialNumber
- SignatureAlgorithm
- Subject
- SubjectKeyId
- URIs
- UnknownExtKeyUsage

The certificate is signed by parent. If parent is equal to template then the certificate is self-signed. The parameter pub is the public key of the certificate to be generated and priv is the private key of the signer.

​	证书由父级签名。如果父级等于模板，则证书是自签名的。参数 pub 是要生成的证书的公钥，priv 是签名者的私钥。

The returned slice is the certificate in DER encoding.

​	返回的切片是 DER 编码的证书。

The currently supported key types are `*rsa.PublicKey`, `*ecdsa.PublicKey` and `ed25519.PublicKey`. pub must be a supported key type, and priv must be a crypto.Signer with a supported public key.

​	当前支持的密钥类型有 `*rsa.PublicKey`、`*ecdsa.PublicKey` 和 `ed25519.PublicKey`。pub 必须是受支持的密钥类型，priv 必须是具有受支持公钥的 crypto.Signer。

The AuthorityKeyId will be taken from the SubjectKeyId of parent, if any, unless the resulting certificate is self-signed. Otherwise the value from template will be used.

​	AuthorityKeyId 将从父级的 SubjectKeyId（如果有）中获取，除非生成的证书是自签名的。否则将使用模板中的值。

If SubjectKeyId from template is empty and the template is a CA, SubjectKeyId will be generated from the hash of the public key.

​	如果模板中的 SubjectKeyId 为空且模板是 CA，则 SubjectKeyId 将从公钥的哈希中生成。

###  func CreateCertificateRequest <- go1.3

```go
func CreateCertificateRequest(rand io.Reader, template *CertificateRequest, priv any) (csr []byte, err error)
```

CreateCertificateRequest creates a new certificate request based on a template. The following members of template are used:

​	CreateCertificateRequest 根据模板创建一个新的证书请求。模板的以下成员被使用：

- SignatureAlgorithm
- Subject
- DNSNames
- EmailAddresses
- IPAddresses
- URIs
- ExtraExtensions
- Attributes (deprecated)
  Attributes（已弃用）

priv is the private key to sign the CSR with, and the corresponding public key will be included in the CSR. It must implement crypto.Signer and its Public() method must return a *rsa.PublicKey or a *ecdsa.PublicKey or a ed25519.PublicKey. (A *rsa.PrivateKey, *ecdsa.PrivateKey or ed25519.PrivateKey satisfies this.)

​	priv 是用于对 CSR 进行签名的私钥，并且相应的公钥将包含在 CSR 中。它必须实现 crypto.Signer，并且其 Public() 方法必须返回一个 *rsa.PublicKey 或一个 *ecdsa.PublicKey 或一个 ed25519.PublicKey。（一个 *rsa.PrivateKey、*ecdsa.PrivateKey 或 ed25519.PrivateKey 满足此条件。）

The returned slice is the certificate request in DER encoding.

​	返回的切片是 DER 编码中的证书请求。

### func CreateRevocationList <- go1.15

```go
func CreateRevocationList(rand io.Reader, template *RevocationList, issuer *Certificate, priv crypto.Signer) ([]byte, error)
```

CreateRevocationList creates a new X.509 v2 Certificate Revocation List, according to [RFC 5280](https://rfc-editor.org/rfc/rfc5280.html), based on template.

​	CreateRevocationList 根据 RFC 5280 创建新的 X.509 v2 证书吊销列表，该列表基于模板。

The CRL is signed by priv which should be the private key associated with the public key in the issuer certificate.

​	CRL 由 priv 签名，priv 应为与颁发者证书中的公钥关联的私钥。

The issuer may not be nil, and the crlSign bit must be set in KeyUsage in order to use it as a CRL issuer.

​	颁发者不得为 nil，并且必须在 KeyUsage 中设置 crlSign 位才能将其用作 CRL 颁发者。

The issuer distinguished name CRL field and authority key identifier extension are populated using the issuer certificate. issuer must have SubjectKeyId set.

​	颁发者专有名称 CRL 字段和授权密钥标识符扩展名使用颁发者证书填充。颁发者必须设置 SubjectKeyId。

### func DecryptPEMBlock <- DEPRECATED

```go
func DecryptPEMBlock(b *pem.Block, password []byte) ([]byte, error)
```

DecryptPEMBlock takes a PEM block encrypted according to [RFC 1423](https://rfc-editor.org/rfc/rfc1423.html) and the password used to encrypt it and returns a slice of decrypted DER encoded bytes. It inspects the DEK-Info header to determine the algorithm used for decryption. If no DEK-Info header is present, an error is returned. If an incorrect password is detected an IncorrectPasswordError is returned. Because of deficiencies in the format, it’s not always possible to detect an incorrect password. In these cases no error will be returned but the decrypted DER bytes will be random noise.

​	DecryptPEMBlock 获取根据 RFC 1423 加密的 PEM 块和用于加密该块的密码，并返回解密的 DER 编码字节切片。它检查 DEK-Info 头以确定用于解密的算法。如果不存在 DEK-Info 头，则返回错误。如果检测到密码不正确，则返回 IncorrectPasswordError。由于格式存在缺陷，因此无法始终检测到密码不正确。在这些情况下，不会返回错误，但解密的 DER 字节将是随机噪声。

Deprecated: Legacy PEM encryption as specified in [RFC 1423](https://rfc-editor.org/rfc/rfc1423.html) is insecure by design. Since it does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.

​	已弃用：RFC 1423 中指定的旧版 PEM 加密在设计上不安全。由于它不会对密文进行身份验证，因此容易受到填充预言攻击，攻击者可利用该攻击恢复明文。

### func EncryptPEMBlock <- DEPRECATED

```go
func EncryptPEMBlock(rand io.Reader, blockType string, data, password []byte, alg PEMCipher) (*pem.Block, error)
```

EncryptPEMBlock returns a PEM block of the specified type holding the given DER encoded data encrypted with the specified algorithm and password according to [RFC 1423](https://rfc-editor.org/rfc/rfc1423.html).

​	EncryptPEMBlock 返回一个指定类型的 PEM 块，其中包含使用指定算法和密码根据 RFC 1423 加密的给定 DER 编码数据。

Deprecated: Legacy PEM encryption as specified in [RFC 1423](https://rfc-editor.org/rfc/rfc1423.html) is insecure by design. Since it does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.

​	已弃用：RFC 1423 中指定的旧版 PEM 加密在设计上不安全。由于它不会对密文进行身份验证，因此容易受到填充预言攻击，攻击者可利用该攻击恢复明文。

### func IsEncryptedPEMBlock <- DEPRECATED

```go
func IsEncryptedPEMBlock(b *pem.Block) bool
```

IsEncryptedPEMBlock returns whether the PEM block is password encrypted according to [RFC 1423](https://rfc-editor.org/rfc/rfc1423.html).

​	IsEncryptedPEMBlock 返回 PEM 块是否根据 RFC 1423 使用密码加密。

Deprecated: Legacy PEM encryption as specified in [RFC 1423](https://rfc-editor.org/rfc/rfc1423.html) is insecure by design. Since it does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext.

​	已弃用：RFC 1423 中指定的旧版 PEM 加密在设计上不安全。由于它不会对密文进行身份验证，因此容易受到填充预言攻击，攻击者可利用该攻击恢复明文。

### func MarshalECPrivateKey <- go1.2

```go
func MarshalECPrivateKey(key *ecdsa.PrivateKey) ([]byte, error)
```

MarshalECPrivateKey converts an EC private key to SEC 1, ASN.1 DER form.

​	MarshalECPrivateKey 将 EC 私钥转换为 SEC 1、ASN.1 DER 形式。

This kind of key is commonly encoded in PEM blocks of type “EC PRIVATE KEY”. For a more flexible key format which is not EC specific, use MarshalPKCS8PrivateKey.

​	这种类型的密钥通常以“EC PRIVATE KEY”类型的 PEM 块进行编码。对于不是 EC 特定的更灵活的密钥格式，请使用 MarshalPKCS8PrivateKey。

### func MarshalPKCS1PrivateKey

```go
func MarshalPKCS1PrivateKey(key *rsa.PrivateKey) []byte
```

MarshalPKCS1PrivateKey converts an RSA private key to PKCS #1, ASN.1 DER form.

​	MarshalPKCS1PrivateKey 将 RSA 私钥转换为 PKCS #1，ASN.1 DER 形式。

This kind of key is commonly encoded in PEM blocks of type “RSA PRIVATE KEY”. For a more flexible key format which is not RSA specific, use MarshalPKCS8PrivateKey.

​	这种类型的密钥通常以“RSA PRIVATE KEY”类型的 PEM 块进行编码。对于不是 RSA 特定的更灵活的密钥格式，请使用 MarshalPKCS8PrivateKey。

### func MarshalPKCS1PublicKey <- go1.10

```go
func MarshalPKCS1PublicKey(key *rsa.PublicKey) []byte
```

MarshalPKCS1PublicKey converts an RSA public key to PKCS #1, ASN.1 DER form.

​	MarshalPKCS1PublicKey 将 RSA 公钥转换为 PKCS #1，ASN.1 DER 形式。

This kind of key is commonly encoded in PEM blocks of type “RSA PUBLIC KEY”.

​	这种类型的密钥通常以“RSA PUBLIC KEY”类型的 PEM 块进行编码。

### func MarshalPKCS8PrivateKey <- go1.10

```go
func MarshalPKCS8PrivateKey(key any) ([]byte, error)
```

MarshalPKCS8PrivateKey converts a private key to PKCS #8, ASN.1 DER form.

​	MarshalPKCS8PrivateKey 将私钥转换为 PKCS #8、ASN.1 DER 形式。

The following key types are currently supported: `*rsa.PrivateKey`, `*ecdsa.PrivateKey`, `ed25519.PrivateKey` (not a pointer), and *ecdh.PrivateKey. Unsupported key types result in an error.

​	当前支持以下密钥类型：`*rsa.PrivateKey`、`*ecdsa.PrivateKey`、`ed25519.PrivateKey`（不是指针）和 *ecdh.PrivateKey。不支持的密钥类型会导致错误。

This kind of key is commonly encoded in PEM blocks of type “PRIVATE KEY”.

​	这种类型的密钥通常以“PRIVATE KEY”类型的 PEM 块进行编码。

### func MarshalPKIXPublicKey

```go
func MarshalPKIXPublicKey(pub any) ([]byte, error)
```

MarshalPKIXPublicKey converts a public key to PKIX, ASN.1 DER form. The encoded public key is a SubjectPublicKeyInfo structure (see [RFC 5280, Section 4.1](https://rfc-editor.org/rfc/rfc5280.html#section-4.1)).

​	MarshalPKIXPublicKey 将公钥转换为 PKIX、ASN.1 DER 形式。编码的公钥是 SubjectPublicKeyInfo 结构（请参阅 RFC 5280 第 4.1 节）。

The following key types are currently supported: `*rsa.PublicKey`, `*ecdsa.PublicKey`, `ed25519.PublicKey` (not a pointer), and *ecdh.PublicKey. Unsupported key types result in an error.

​	当前支持以下密钥类型：`*rsa.PublicKey`、`*ecdsa.PublicKey`、`ed25519.PublicKey`（不是指针）和 *ecdh.PublicKey。不支持的密钥类型会导致错误。

This kind of key is commonly encoded in PEM blocks of type “PUBLIC KEY”.

​	这种类型的密钥通常以“PUBLIC KEY”类型的 PEM 块进行编码。

### func ParseCRL <- DEPRECATED

```go
func ParseCRL(crlBytes []byte) (*pkix.CertificateList, error)
```

ParseCRL parses a CRL from the given bytes. It’s often the case that PEM encoded CRLs will appear where they should be DER encoded, so this function will transparently handle PEM encoding as long as there isn’t any leading garbage.

​	ParseCRL 从给定的字节中解析 CRL。通常情况下，PEM 编码的 CRL 会出现在应该使用 DER 编码的地方，因此只要没有前导垃圾，此函数就会透明地处理 PEM 编码。

Deprecated: Use ParseRevocationList instead.

​	已弃用：请改用 ParseRevocationList。

### func ParseDERCRL <- DEPRECATED

```go
func ParseDERCRL(derBytes []byte) (*pkix.CertificateList, error)
```

ParseDERCRL parses a DER encoded CRL from the given bytes.

​	ParseDERCRL 从给定的字节中解析 DER 编码的 CRL。

Deprecated: Use ParseRevocationList instead.

​	已弃用：请改用 ParseRevocationList。

### func ParseECPrivateKey <- go1.1

```go
func ParseECPrivateKey(der []byte) (*ecdsa.PrivateKey, error)
```

ParseECPrivateKey parses an EC private key in SEC 1, ASN.1 DER form.

​	ParseECPrivateKey 解析 SEC 1、ASN.1 DER 形式的 EC 私钥。

This kind of key is commonly encoded in PEM blocks of type “EC PRIVATE KEY”.

​	这种类型的密钥通常以“EC PRIVATE KEY”类型的 PEM 块进行编码。

### func ParsePKCS1PrivateKey

```go
func ParsePKCS1PrivateKey(der []byte) (*rsa.PrivateKey, error)
```

ParsePKCS1PrivateKey parses an RSA private key in PKCS #1, ASN.1 DER form.

​	ParsePKCS1PrivateKey 解析 PKCS #1、ASN.1 DER 形式的 RSA 私钥。

This kind of key is commonly encoded in PEM blocks of type “RSA PRIVATE KEY”.

​	这种类型的密钥通常以“RSA 私钥”类型的 PEM 块进行编码。

### func ParsePKCS1PublicKey <- go1.10

```go
func ParsePKCS1PublicKey(der []byte) (*rsa.PublicKey, error)
```

ParsePKCS1PublicKey parses an RSA public key in PKCS #1, ASN.1 DER form.

​	ParsePKCS1PublicKey 解析 PKCS #1、ASN.1 DER 格式的 RSA 公钥。

This kind of key is commonly encoded in PEM blocks of type “RSA PUBLIC KEY”.

​	这种类型的密钥通常以“RSA 公钥”类型的 PEM 块进行编码。

### func ParsePKCS8PrivateKey

```go
func ParsePKCS8PrivateKey(der []byte) (key any, err error)
```

ParsePKCS8PrivateKey parses an unencrypted private key in PKCS #8, ASN.1 DER form.

​	ParsePKCS8PrivateKey 解析 PKCS #8、ASN.1 DER 格式的未加密私钥。

It returns a `*rsa.PrivateKey`, a `*ecdsa.PrivateKey`, a `ed25519.PrivateKey` (not a pointer), or a *ecdh.PublicKey (for X25519). More types might be supported in the future.

​	它返回一个 `*rsa.PrivateKey`、一个 `*ecdsa.PrivateKey`、一个 `ed25519.PrivateKey`（不是一个指针）或一个 *ecdh.PublicKey（对于 X25519）。未来可能会支持更多类型。

This kind of key is commonly encoded in PEM blocks of type “PRIVATE KEY”.

​	这种类型的密钥通常编码在“PRIVATE KEY”类型的 PEM 块中。

### func ParsePKIXPublicKey

```go
func ParsePKIXPublicKey(derBytes []byte) (pub any, err error)
```

ParsePKIXPublicKey parses a public key in PKIX, ASN.1 DER form. The encoded public key is a SubjectPublicKeyInfo structure (see [RFC 5280, Section 4.1](https://rfc-editor.org/rfc/rfc5280.html#section-4.1)).

​	ParsePKIXPublicKey 解析 PKIX、ASN.1 DER 形式的公钥。编码的公钥是一个 SubjectPublicKeyInfo 结构（参见 RFC 5280，第 4.1 节）。

It returns a `*rsa.PublicKey`, `*dsa.PublicKey`, `*ecdsa.PublicKey`, `ed25519.PublicKey` (not a pointer), or *ecdh.PublicKey (for X25519). More types might be supported in the future.

​	它返回一个 `*rsa.PublicKey`、`*dsa.PublicKey`、`*ecdsa.PublicKey`、`ed25519.PublicKey`（不是一个指针）或 *ecdh.PublicKey（对于 X25519）。未来可能会支持更多类型。

This kind of key is commonly encoded in PEM blocks of type “PUBLIC KEY”.

​	这种类型的密钥通常编码在“PUBLIC KEY”类型的 PEM 块中。

#### ParsePKIXPublicKey Example

```go
package main

import (
	"crypto/dsa"
	"crypto/ecdsa"
	"crypto/ed25519"
	"crypto/rsa"
	"crypto/x509"
	"encoding/pem"
	"fmt"
)

func main() {
	const pubPEM = `
-----BEGIN PUBLIC KEY-----
MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAlRuRnThUjU8/prwYxbty
WPT9pURI3lbsKMiB6Fn/VHOKE13p4D8xgOCADpdRagdT6n4etr9atzDKUSvpMtR3
CP5noNc97WiNCggBjVWhs7szEe8ugyqF23XwpHQ6uV1LKH50m92MbOWfCtjU9p/x
qhNpQQ1AZhqNy5Gevap5k8XzRmjSldNAFZMY7Yv3Gi+nyCwGwpVtBUwhuLzgNFK/
yDtw2WcWmUU7NuC8Q6MWvPebxVtCfVp/iQU6q60yyt6aGOBkhAX0LpKAEhKidixY
nP9PNVBvxgu3XZ4P36gZV6+ummKdBVnc3NqwBLu5+CcdRdusmHPHd5pHf4/38Z3/
6qU2a/fPvWzceVTEgZ47QjFMTCTmCwNt29cvi7zZeQzjtwQgn4ipN9NibRH/Ax/q
TbIzHfrJ1xa2RteWSdFjwtxi9C20HUkjXSeI4YlzQMH0fPX6KCE7aVePTOnB69I/
a9/q96DiXZajwlpq3wFctrs1oXqBp5DVrCIj8hU2wNgB7LtQ1mCtsYz//heai0K9
PhE4X6hiE0YmeAZjR0uHl8M/5aW9xCoJ72+12kKpWAa0SFRWLy6FejNYCYpkupVJ
yecLk/4L1W0l6jQQZnWErXZYe0PNFcmwGXy1Rep83kfBRNKRy5tvocalLlwXLdUk
AIU+2GKjyT3iMuzZxxFxPFMCAwEAAQ==
-----END PUBLIC KEY-----`

	block, _ := pem.Decode([]byte(pubPEM))
	if block == nil {
		panic("failed to parse PEM block containing the public key")
	}

	pub, err := x509.ParsePKIXPublicKey(block.Bytes)
	if err != nil {
		panic("failed to parse DER encoded public key: " + err.Error())
	}

	switch pub := pub.(type) {
	case *rsa.PublicKey:
		fmt.Println("pub is of type RSA:", pub)
	case *dsa.PublicKey:
		fmt.Println("pub is of type DSA:", pub)
	case *ecdsa.PublicKey:
		fmt.Println("pub is of type ECDSA:", pub)
	case ed25519.PublicKey:
		fmt.Println("pub is of type Ed25519:", pub)
	default:
		panic("unknown type of public key")
	}
}
```

### func SetFallbackRoots <- go1.20

```go
func SetFallbackRoots(roots *CertPool)
```

SetFallbackRoots sets the roots to use during certificate verification, if no custom roots are specified and a platform verifier or a system certificate pool is not available (for instance in a container which does not have a root certificate bundle). SetFallbackRoots will panic if roots is nil.

​	SetFallbackRoots 设置在证书验证期间使用的根，如果没有指定自定义根并且平台验证器或系统证书池不可用（例如在没有根证书包的容器中）。如果 roots 为 nil，SetFallbackRoots 将引发 panic。

SetFallbackRoots may only be called once, if called multiple times it will panic.

​	SetFallbackRoots 只能调用一次，如果多次调用，它将引发 panic。

The fallback behavior can be forced on all platforms, even when there is a system certificate pool, by setting GODEBUG=x509usefallbackroots=1 (note that on Windows and macOS this will disable usage of the platform verification APIs and cause the pure Go verifier to be used). Setting x509usefallbackroots=1 without calling SetFallbackRoots has no effect.

​	可以通过设置 GODEBUG=x509usefallbackroots=1 来强制所有平台上的回退行为，即使存在系统证书池（请注意，在 Windows 和 macOS 上，这将禁用平台验证 API 的使用，并导致使用纯 Go 验证器）。在不调用 SetFallbackRoots 的情况下设置 x509usefallbackroots=1 不起作用。

## 类型

### type CertPool

```go
type CertPool struct {
	// contains filtered or unexported fields
}
```

CertPool is a set of certificates.

​	CertPool 是证书集。

#### func NewCertPool

```go
func NewCertPool() *CertPool
```

NewCertPool returns a new, empty CertPool.

​	NewCertPool 返回一个新的空 CertPool。

#### func SystemCertPool <- go1.7

```go
func SystemCertPool() (*CertPool, error)
```

SystemCertPool returns a copy of the system cert pool.

​	SystemCertPool 返回系统证书池的副本。

On Unix systems other than macOS the environment variables SSL_CERT_FILE and SSL_CERT_DIR can be used to override the system default locations for the SSL certificate file and SSL certificate files directory, respectively. The latter can be a colon-separated list.

​	在除 macOS 以外的 Unix 系统上，环境变量 SSL_CERT_FILE 和 SSL_CERT_DIR 可用于分别覆盖 SSL 证书文件和 SSL 证书文件目录的系统默认位置。后者可以是冒号分隔的列表。

Any mutations to the returned pool are not written to disk and do not affect any other pool returned by SystemCertPool.

​	对返回池的任何更改都不会写入磁盘，也不会影响 SystemCertPool 返回的任何其他池。

New changes in the system cert pool might not be reflected in subsequent calls.

​	系统证书池中的任何新更改可能不会反映在后续调用中。

#### (*CertPool) AddCert

```go
func (s *CertPool) AddCert(cert *Certificate)
```

AddCert adds a certificate to a pool.

​	AddCert 将证书添加到池中。

#### (*CertPool) AddCertWithConstraint <- go1.22.0

```
func (s *CertPool) AddCertWithConstraint(cert *Certificate, constraint func([]*Certificate) error)
```

AddCertWithConstraint adds a certificate to the pool with the additional constraint. When Certificate.Verify builds a chain which is rooted by cert, it will additionally pass the whole chain to constraint to determine its validity. If constraint returns a non-nil error, the chain will be discarded. constraint may be called concurrently from multiple goroutines.

​	AddCertWithConstraint 会将一个证书添加到证书池中，并附加额外的约束条件。当 Certificate.Verify 构建出以该证书为根的链时，它会将整个链传递给约束函数来确定其有效性。如果约束函数返回非 nil 的错误，该链将被丢弃。约束函数可能会被多个 goroutine 并发调用。

#### (*CertPool) AppendCertsFromPEM

```go
func (s *CertPool) AppendCertsFromPEM(pemCerts []byte) (ok bool)
```

AppendCertsFromPEM attempts to parse a series of PEM encoded certificates. It appends any certificates found to s and reports whether any certificates were successfully parsed.

​	AppendCertsFromPEM 尝试解析一系列 PEM 编码的证书。它将找到的任何证书追加到 s，并报告是否成功解析了任何证书。

On many Linux systems, /etc/ssl/cert.pem will contain the system wide set of root CAs in a format suitable for this function.

​	在许多 Linux 系统上，/etc/ssl/cert.pem 将包含适用于此函数的格式的系统范围的根 CA。

#### (*CertPool) Clone <- go1.19

```go
func (s *CertPool) Clone() *CertPool
```

Clone returns a copy of s.

​	Clone 返回 s 的副本。

#### (*CertPool) Equal <- go1.19

```go
func (s *CertPool) Equal(other *CertPool) bool
```

Equal reports whether s and other are equal.

​	Equal 报告 s 和 other 是否相等。

#### (*CertPool) Subjects <- DEPRECATED 

```go
func (s *CertPool) Subjects() [][]byte
```

Subjects returns a list of the DER-encoded subjects of all of the certificates in the pool.

​	Subjects 返回池中所有证书的 DER 编码主题的列表。

Deprecated: if s was returned by SystemCertPool, Subjects will not include the system roots.

​	已弃用：如果 s 由 SystemCertPool 返回，Subjects 将不包括系统根。

### type Certificate

```go
type Certificate struct {
	Raw                     []byte // Complete ASN.1 DER content (certificate, signature algorithm and signature).
	RawTBSCertificate       []byte // Certificate part of raw ASN.1 DER content.
	RawSubjectPublicKeyInfo []byte // DER encoded SubjectPublicKeyInfo.
	RawSubject              []byte // DER encoded Subject
	RawIssuer               []byte // DER encoded Issuer

	Signature          []byte
	SignatureAlgorithm SignatureAlgorithm

	PublicKeyAlgorithm PublicKeyAlgorithm
	PublicKey          any

	Version             int
	SerialNumber        *big.Int
	Issuer              pkix.Name
	Subject             pkix.Name
	NotBefore, NotAfter time.Time // Validity bounds.
	KeyUsage            KeyUsage

	// Extensions contains raw X.509 extensions. When parsing certificates,
	// this can be used to extract non-critical extensions that are not
	// parsed by this package. When marshaling certificates, the Extensions
	// field is ignored, see ExtraExtensions.
	Extensions []pkix.Extension

	// ExtraExtensions contains extensions to be copied, raw, into any
	// marshaled certificates. Values override any extensions that would
	// otherwise be produced based on the other fields. The ExtraExtensions
	// field is not populated when parsing certificates, see Extensions.
	ExtraExtensions []pkix.Extension

	// UnhandledCriticalExtensions contains a list of extension IDs that
	// were not (fully) processed when parsing. Verify will fail if this
	// slice is non-empty, unless verification is delegated to an OS
	// library which understands all the critical extensions.
	//
	// Users can access these extensions using Extensions and can remove
	// elements from this slice if they believe that they have been
	// handled.
	UnhandledCriticalExtensions []asn1.ObjectIdentifier

	ExtKeyUsage        []ExtKeyUsage           // Sequence of extended key usages.
	UnknownExtKeyUsage []asn1.ObjectIdentifier // Encountered extended key usages unknown to this package.

	// BasicConstraintsValid indicates whether IsCA, MaxPathLen,
	// and MaxPathLenZero are valid.
	BasicConstraintsValid bool
	IsCA                  bool

	// MaxPathLen and MaxPathLenZero indicate the presence and
	// value of the BasicConstraints' "pathLenConstraint".
	//
	// When parsing a certificate, a positive non-zero MaxPathLen
	// means that the field was specified, -1 means it was unset,
	// and MaxPathLenZero being true mean that the field was
	// explicitly set to zero. The case of MaxPathLen==0 with MaxPathLenZero==false
	// should be treated equivalent to -1 (unset).
	//
	// When generating a certificate, an unset pathLenConstraint
	// can be requested with either MaxPathLen == -1 or using the
	// zero value for both MaxPathLen and MaxPathLenZero.
	MaxPathLen int
	// MaxPathLenZero indicates that BasicConstraintsValid==true
	// and MaxPathLen==0 should be interpreted as an actual
	// maximum path length of zero. Otherwise, that combination is
	// interpreted as MaxPathLen not being set.
	MaxPathLenZero bool

	SubjectKeyId   []byte
	AuthorityKeyId []byte

	// RFC 5280, 4.2.2.1 (Authority Information Access)
	OCSPServer            []string
	IssuingCertificateURL []string

	// Subject Alternate Name values. (Note that these values may not be valid
	// if invalid values were contained within a parsed certificate. For
	// example, an element of DNSNames may not be a valid DNS domain name.)
	DNSNames       []string
	EmailAddresses []string
	IPAddresses    []net.IP
	URIs           []*url.URL

	// Name constraints
	PermittedDNSDomainsCritical bool // if true then the name constraints are marked critical.
	PermittedDNSDomains         []string
	ExcludedDNSDomains          []string
	PermittedIPRanges           []*net.IPNet
	ExcludedIPRanges            []*net.IPNet
	PermittedEmailAddresses     []string
	ExcludedEmailAddresses      []string
	PermittedURIDomains         []string
	ExcludedURIDomains          []string

	// CRL Distribution Points
	CRLDistributionPoints []string

	// PolicyIdentifiers contains asn1.ObjectIdentifiers, the components
	// of which are limited to int32. If a certificate contains a policy which
	// cannot be represented by asn1.ObjectIdentifier, it will not be included in
	// PolicyIdentifiers, but will be present in Policies, which contains all parsed
	// policy OIDs.
	PolicyIdentifiers []asn1.ObjectIdentifier

	// Policies contains all policy identifiers included in the certificate.
	// In Go 1.22, encoding/gob cannot handle and ignores this field.
	Policies []OID
}
```

A Certificate represents an X.509 certificate.

​	Certificate 表示 X.509 证书。

#### func ParseCertificate

```go
func ParseCertificate(der []byte) (*Certificate, error)
```

ParseCertificate parses a single certificate from the given ASN.1 DER data.

​	ParseCertificate 从给定的 ASN.1 DER 数据中解析单个证书。

Before Go 1.23, ParseCertificate accepted certificates with negative serial numbers. This behavior can be restored by including "x509negativeserial=1" in the GODEBUG environment variable.

#### func ParseCertificates

```go
func ParseCertificates(der []byte) ([]*Certificate, error)
```

ParseCertificates parses one or more certificates from the given ASN.1 DER data. The certificates must be concatenated with no intermediate padding.

​	ParseCertificates 从给定的 ASN.1 DER 数据中解析一个或多个证书。必须将证书连接起来，中间没有填充。

#### (*Certificate) CheckCRLSignature <- DEPRECATED 

```go
func (c *Certificate) CheckCRLSignature(crl *pkix.CertificateList) error
```

CheckCRLSignature checks that the signature in crl is from c.

​	CheckCRLSignature 检查 crl 中的签名是否来自 c。

Deprecated: Use RevocationList.CheckSignatureFrom instead.

​	已弃用：请改用 RevocationList.CheckSignatureFrom。

#### (*Certificate) CheckSignature

```go
func (c *Certificate) CheckSignature(algo SignatureAlgorithm, signed, signature []byte) error
```

CheckSignature verifies that signature is a valid signature over signed from c’s public key.

​	CheckSignature 验证签名是否为 c 的公钥对 signed 进行的有效签名。

This is a low-level API that performs no validity checks on the certificate.

​	这是一个低级别的 API，不会对证书执行任何有效性检查。

[MD5WithRSA](https://pkg.go.dev/crypto/x509@go1.20.1#MD5WithRSA) signatures are rejected, while [SHA1WithRSA](https://pkg.go.dev/crypto/x509@go1.20.1#SHA1WithRSA) and [ECDSAWithSHA1](https://pkg.go.dev/crypto/x509@go1.20.1#ECDSAWithSHA1) signatures are currently accepted.

​	MD5WithRSA 签名被拒绝，而 SHA1WithRSA 和 ECDSAWithSHA1 签名目前被接受。

#### (*Certificate) CheckSignatureFrom

```go
func (c *Certificate) CheckSignatureFrom(parent *Certificate) error
```

CheckSignatureFrom verifies that the signature on c is a valid signature from parent.

​	CheckSignatureFrom 验证 c 上的签名是否为父级发出的有效签名。

This is a low-level API that performs very limited checks, and not a full path verifier. Most users should use [Certificate.Verify](https://pkg.go.dev/crypto/x509@go1.20.1#Certificate.Verify) instead.

​	这是一个低级别的 API，执行非常有限的检查，而不是一个完整的路径验证器。大多数用户应该改用 Certificate.Verify。

#### (*Certificate) CreateCRL <- DEPRECATED 

```go
func (c *Certificate) CreateCRL(rand io.Reader, priv any, revokedCerts []pkix.RevokedCertificate, now, expiry time.Time) (crlBytes []byte, err error)
```

CreateCRL returns a DER encoded CRL, signed by this Certificate, that contains the given list of revoked certificates.

​	CreateCRL 返回一个 DER 编码的 CRL，由该证书签名，其中包含给定的吊销证书列表。

Deprecated: this method does not generate an [RFC 5280](https://rfc-editor.org/rfc/rfc5280.html) conformant X.509 v2 CRL. To generate a standards compliant CRL, use CreateRevocationList instead.

​	已弃用：此方法不会生成符合 RFC 5280 的 X.509 v2 CRL。要生成符合标准的 CRL，请改用 CreateRevocationList。

#### (*Certificate) Equal 

```go
func (c *Certificate) Equal(other *Certificate) bool
```

#### (*Certificate) Verify

```go
func (c *Certificate) Verify(opts VerifyOptions) (chains [][]*Certificate, err error)
```

Verify attempts to verify c by building one or more chains from c to a certificate in opts.Roots, using certificates in opts.Intermediates if needed. If successful, it returns one or more chains where the first element of the chain is c and the last element is from opts.Roots.

​	验证尝试通过使用 opts.Intermediates 中的证书（如果需要）从 c 构建一个或多个链到 opts.Roots 中的证书来验证 c。如果成功，它将返回一个或多个链，其中链的第一个元素是 c，最后一个元素来自 opts.Roots。

If opts.Roots is nil, the platform verifier might be used, and verification details might differ from what is described below. If system roots are unavailable the returned error will be of type SystemRootsError.

​	如果 opts.Roots 为 nil，则可以使用平台验证器，并且验证详细信息可能与以下描述的内容不同。如果系统根不可用，则返回的错误将为 SystemRootsError 类型。

Name constraints in the intermediates will be applied to all names claimed in the chain, not just opts.DNSName. Thus it is invalid for a leaf to claim example.com if an intermediate doesn’t permit it, even if example.com is not the name being validated. Note that DirectoryName constraints are not supported.

​	中间证书中的名称约束将应用于链中声明的所有名称，而不仅仅是 opts.DNSName。因此，如果中间证书不允许，则叶子证书声明 example.com 无效，即使 example.com 不是正在验证的名称也是如此。请注意，不支持 DirectoryName 约束。

Name constraint validation follows the rules from [RFC 5280](https://rfc-editor.org/rfc/rfc5280.html), with the addition that DNS name constraints may use the leading period format defined for emails and URIs. When a constraint has a leading period it indicates that at least one additional label must be prepended to the constrained name to be considered valid.

​	名称约束验证遵循 RFC 5280 中的规则，此外，DNS 名称约束可以使用为电子邮件和 URI 定义的前导点格式。当约束具有前导点时，表示必须将至少一个其他标签前置到受约束的名称才能被视为有效。

Extended Key Usage values are enforced nested down a chain, so an intermediate or root that enumerates EKUs prevents a leaf from asserting an EKU not in that list. (While this is not specified, it is common practice in order to limit the types of certificates a CA can issue.)

​	扩展密钥用法值在链中嵌套强制执行，因此枚举 EKU 的中间或根证书会阻止叶证书声明不在该列表中的 EKU。（虽然未指定，但这是为了限制 CA 可以颁发的证书类型而采用的常见做法。）

Certificates that use SHA1WithRSA and ECDSAWithSHA1 signatures are not supported, and will not be used to build chains.

​	不支持使用 SHA1WithRSA 和 ECDSAWithSHA1 签名的证书，并且不会使用它们来构建链。

Certificates other than c in the returned chains should not be modified.

​	不应修改返回的链中的 c 以外的证书。

WARNING: this function doesn’t do any revocation checking.

​	警告：此函数不执行任何吊销检查。

##### Verify Example 

```go
package main

import (
	"crypto/x509"
	"encoding/pem"
)

func main() {
	// Verifying with a custom list of root certificates.

	const rootPEM = `
-----BEGIN CERTIFICATE-----
MIIEBDCCAuygAwIBAgIDAjppMA0GCSqGSIb3DQEBBQUAMEIxCzAJBgNVBAYTAlVT
MRYwFAYDVQQKEw1HZW9UcnVzdCBJbmMuMRswGQYDVQQDExJHZW9UcnVzdCBHbG9i
YWwgQ0EwHhcNMTMwNDA1MTUxNTU1WhcNMTUwNDA0MTUxNTU1WjBJMQswCQYDVQQG
EwJVUzETMBEGA1UEChMKR29vZ2xlIEluYzElMCMGA1UEAxMcR29vZ2xlIEludGVy
bmV0IEF1dGhvcml0eSBHMjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEB
AJwqBHdc2FCROgajguDYUEi8iT/xGXAaiEZ+4I/F8YnOIe5a/mENtzJEiaB0C1NP
VaTOgmKV7utZX8bhBYASxF6UP7xbSDj0U/ck5vuR6RXEz/RTDfRK/J9U3n2+oGtv
h8DQUB8oMANA2ghzUWx//zo8pzcGjr1LEQTrfSTe5vn8MXH7lNVg8y5Kr0LSy+rE
ahqyzFPdFUuLH8gZYR/Nnag+YyuENWllhMgZxUYi+FOVvuOAShDGKuy6lyARxzmZ
EASg8GF6lSWMTlJ14rbtCMoU/M4iarNOz0YDl5cDfsCx3nuvRTPPuj5xt970JSXC
DTWJnZ37DhF5iR43xa+OcmkCAwEAAaOB+zCB+DAfBgNVHSMEGDAWgBTAephojYn7
qwVkDBF9qn1luMrMTjAdBgNVHQ4EFgQUSt0GFhu89mi1dvWBtrtiGrpagS8wEgYD
VR0TAQH/BAgwBgEB/wIBADAOBgNVHQ8BAf8EBAMCAQYwOgYDVR0fBDMwMTAvoC2g
K4YpaHR0cDovL2NybC5nZW90cnVzdC5jb20vY3Jscy9ndGdsb2JhbC5jcmwwPQYI
KwYBBQUHAQEEMTAvMC0GCCsGAQUFBzABhiFodHRwOi8vZ3RnbG9iYWwtb2NzcC5n
ZW90cnVzdC5jb20wFwYDVR0gBBAwDjAMBgorBgEEAdZ5AgUBMA0GCSqGSIb3DQEB
BQUAA4IBAQA21waAESetKhSbOHezI6B1WLuxfoNCunLaHtiONgaX4PCVOzf9G0JY
/iLIa704XtE7JW4S615ndkZAkNoUyHgN7ZVm2o6Gb4ChulYylYbc3GrKBIxbf/a/
zG+FA1jDaFETzf3I93k9mTXwVqO94FntT0QJo544evZG0R0SnU++0ED8Vf4GXjza
HFa9llF7b1cq26KqltyMdMKVvvBulRP/F/A8rLIQjcxz++iPAsbw+zOzlTvjwsto
WHPbqCRiOwY1nQ2pM714A5AuTHhdUDqB1O6gyHA43LL5Z/qHQF1hwFGPa4NrzQU6
yuGnBXj8ytqU0CwIPX4WecigUCAkVDNx
-----END CERTIFICATE-----`

	const certPEM = `
-----BEGIN CERTIFICATE-----
MIIDujCCAqKgAwIBAgIIE31FZVaPXTUwDQYJKoZIhvcNAQEFBQAwSTELMAkGA1UE
BhMCVVMxEzARBgNVBAoTCkdvb2dsZSBJbmMxJTAjBgNVBAMTHEdvb2dsZSBJbnRl
cm5ldCBBdXRob3JpdHkgRzIwHhcNMTQwMTI5MTMyNzQzWhcNMTQwNTI5MDAwMDAw
WjBpMQswCQYDVQQGEwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwN
TW91bnRhaW4gVmlldzETMBEGA1UECgwKR29vZ2xlIEluYzEYMBYGA1UEAwwPbWFp
bC5nb29nbGUuY29tMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEfRrObuSW5T7q
5CnSEqefEmtH4CCv6+5EckuriNr1CjfVvqzwfAhopXkLrq45EQm8vkmf7W96XJhC
7ZM0dYi1/qOCAU8wggFLMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAa
BgNVHREEEzARgg9tYWlsLmdvb2dsZS5jb20wCwYDVR0PBAQDAgeAMGgGCCsGAQUF
BwEBBFwwWjArBggrBgEFBQcwAoYfaHR0cDovL3BraS5nb29nbGUuY29tL0dJQUcy
LmNydDArBggrBgEFBQcwAYYfaHR0cDovL2NsaWVudHMxLmdvb2dsZS5jb20vb2Nz
cDAdBgNVHQ4EFgQUiJxtimAuTfwb+aUtBn5UYKreKvMwDAYDVR0TAQH/BAIwADAf
BgNVHSMEGDAWgBRK3QYWG7z2aLV29YG2u2IaulqBLzAXBgNVHSAEEDAOMAwGCisG
AQQB1nkCBQEwMAYDVR0fBCkwJzAloCOgIYYfaHR0cDovL3BraS5nb29nbGUuY29t
L0dJQUcyLmNybDANBgkqhkiG9w0BAQUFAAOCAQEAH6RYHxHdcGpMpFE3oxDoFnP+
gtuBCHan2yE2GRbJ2Cw8Lw0MmuKqHlf9RSeYfd3BXeKkj1qO6TVKwCh+0HdZk283
TZZyzmEOyclm3UGFYe82P/iDFt+CeQ3NpmBg+GoaVCuWAARJN/KfglbLyyYygcQq
0SgeDh8dRKUiaW3HQSoYvTvdTuqzwK4CXsr3b5/dAOY8uMuG/IAR3FgwTbZ1dtoW
RvOTa8hYiU6A475WuZKyEHcwnGYe57u2I2KbMgcKjPniocj4QzgYsVAVKW3IwaOh
yE+vPxsiUkvQHdO2fojCkY8jg70jxM+gu59tPDNbw3Uh/2Ij310FgTHsnGQMyA==
-----END CERTIFICATE-----`

	// First, create the set of root certificates. For this example we only
	// have one. It's also possible to omit this in order to use the
	// default root set of the current operating system.
	roots := x509.NewCertPool()
	ok := roots.AppendCertsFromPEM([]byte(rootPEM))
	if !ok {
		panic("failed to parse root certificate")
	}

	block, _ := pem.Decode([]byte(certPEM))
	if block == nil {
		panic("failed to parse certificate PEM")
	}
	cert, err := x509.ParseCertificate(block.Bytes)
	if err != nil {
		panic("failed to parse certificate: " + err.Error())
	}

	opts := x509.VerifyOptions{
		DNSName: "mail.google.com",
		Roots:   roots,
	}

	if _, err := cert.Verify(opts); err != nil {
		panic("failed to verify certificate: " + err.Error())
	}
}
Output:
```

#### (*Certificate) VerifyHostname

```go
func (c *Certificate) VerifyHostname(h string) error
```

VerifyHostname returns nil if c is a valid certificate for the named host. Otherwise it returns an error describing the mismatch.

​	如果 c 是指定主机的有效证书，则 VerifyHostname 返回 nil。否则，它会返回描述不匹配的错误。

IP addresses can be optionally enclosed in square brackets and are checked against the IPAddresses field. Other names are checked case insensitively against the DNSNames field. If the names are valid hostnames, the certificate fields can have a wildcard as the left-most label.

​	IP 地址可以放在方括号中，并与 IPAddresses 字段进行比较。其他名称与 DNSNames 字段不区分大小写地进行比较。如果名称是有效的域名，则证书字段可以将通配符作为最左边的标签。

Note that the legacy Common Name field is ignored.

​	请注意，旧版公用名称字段被忽略。

### type CertificateInvalidError

```go
type CertificateInvalidError struct {
	Cert   *Certificate
	Reason InvalidReason
	Detail string
}
```

CertificateInvalidError results when an odd error occurs. Users of this library probably want to handle all these errors uniformly.

​	当出现奇怪的错误时，会产生 CertificateInvalidError。此库的用户可能希望统一处理所有这些错误。

#### (CertificateInvalidError) Error

```go
func (e CertificateInvalidError) Error() string
```

### type CertificateRequest <- go1.3

```go
type CertificateRequest struct {
	Raw                      []byte // Complete ASN.1 DER content (CSR, signature algorithm and signature).
	RawTBSCertificateRequest []byte // Certificate request info part of raw ASN.1 DER content.
	RawSubjectPublicKeyInfo  []byte // DER encoded SubjectPublicKeyInfo.
	RawSubject               []byte // DER encoded Subject.

	Version            int
	Signature          []byte
	SignatureAlgorithm SignatureAlgorithm

	PublicKeyAlgorithm PublicKeyAlgorithm
	PublicKey          any

	Subject pkix.Name

	// Attributes contains the CSR attributes that can parse as
	// pkix.AttributeTypeAndValueSET.
	//
	// Deprecated: Use Extensions and ExtraExtensions instead for parsing and
	// generating the requestedExtensions attribute.
	Attributes []pkix.AttributeTypeAndValueSET

	// Extensions contains all requested extensions, in raw form. When parsing
	// CSRs, this can be used to extract extensions that are not parsed by this
	// package.
	Extensions []pkix.Extension

	// ExtraExtensions contains extensions to be copied, raw, into any CSR
	// marshaled by CreateCertificateRequest. Values override any extensions
	// that would otherwise be produced based on the other fields but are
	// overridden by any extensions specified in Attributes.
	//
	// The ExtraExtensions field is not populated by ParseCertificateRequest,
	// see Extensions instead.
	ExtraExtensions []pkix.Extension

	// Subject Alternate Name values.
	DNSNames       []string
	EmailAddresses []string
	IPAddresses    []net.IP
	URIs           []*url.URL
}
```

CertificateRequest represents a PKCS #10, certificate signature request.

​	CertificateRequest 表示 PKCS #10 证书签名请求。

#### func ParseCertificateRequest <- go1.3

```go
func ParseCertificateRequest(asn1Data []byte) (*CertificateRequest, error)
```

ParseCertificateRequest parses a single certificate request from the given ASN.1 DER data.

​	ParseCertificateRequest 从给定的 ASN.1 DER 数据中解析单个证书请求。

#### (*CertificateRequest) CheckSignature <- go1.5

```go
func (c *CertificateRequest) CheckSignature() error
```

CheckSignature reports whether the signature on c is valid.

​	CheckSignature 报告 c 上的签名是否有效。

### type ConstraintViolationError

```go
type ConstraintViolationError struct{}
```

ConstraintViolationError results when a requested usage is not permitted by a certificate. For example: checking a signature when the public key isn’t a certificate signing key.

​	当证书不允许请求的使用时，将导致 ConstraintViolationError。例如：在公钥不是证书签名密钥时检查签名。

#### (ConstraintViolationError) Error

```go
func (ConstraintViolationError) Error() string
```

### type ExtKeyUsage

```go
type ExtKeyUsage int
```

ExtKeyUsage represents an extended set of actions that are valid for a given key. Each of the ExtKeyUsage* constants define a unique action.

​	ExtKeyUsage 表示对给定密钥有效的扩展操作集。每个 ExtKeyUsage* 常量定义一个唯一操作。

```go
const (
	ExtKeyUsageAny ExtKeyUsage = iota
	ExtKeyUsageServerAuth
	ExtKeyUsageClientAuth
	ExtKeyUsageCodeSigning
	ExtKeyUsageEmailProtection
	ExtKeyUsageIPSECEndSystem
	ExtKeyUsageIPSECTunnel
	ExtKeyUsageIPSECUser
	ExtKeyUsageTimeStamping
	ExtKeyUsageOCSPSigning
	ExtKeyUsageMicrosoftServerGatedCrypto
	ExtKeyUsageNetscapeServerGatedCrypto
	ExtKeyUsageMicrosoftCommercialCodeSigning
	ExtKeyUsageMicrosoftKernelCodeSigning
)
```

### type HostnameError

```go
type HostnameError struct {
	Certificate *Certificate
	Host        string
}
```

HostnameError results when the set of authorized names doesn’t match the requested name.

​	当授权名称集与请求的名称不匹配时，会产生 HostnameError 结果。

#### (HostnameError) Error

```go
func (h HostnameError) Error() string
```

### type InsecureAlgorithmError <- go1.6

```go
type InsecureAlgorithmError SignatureAlgorithm
```

An InsecureAlgorithmError indicates that the SignatureAlgorithm used to generate the signature is not secure, and the signature has been rejected.

​	InsecureAlgorithmError 指示用于生成签名的 SignatureAlgorithm 不安全，并且签名已被拒绝。

To temporarily restore support for SHA-1 signatures, include the value “x509sha1=1” in the GODEBUG environment variable. Note that this option will be removed in a future release.

​	要暂时恢复对 SHA-1 签名的支持，请在 GODEBUG 环境变量中包含值“x509sha1=1”。请注意，此选项将在未来版本中删除。

#### (InsecureAlgorithmError) Error <- go1.6

```go
func (e InsecureAlgorithmError) Error() string
```

### type InvalidReason

```go
type InvalidReason int
const (
	// NotAuthorizedToSign results when a certificate is signed by another
	// which isn't marked as a CA certificate.
	NotAuthorizedToSign InvalidReason = iota
	// Expired results when a certificate has expired, based on the time
	// given in the VerifyOptions.
	Expired
	// CANotAuthorizedForThisName results when an intermediate or root
	// certificate has a name constraint which doesn't permit a DNS or
	// other name (including IP address) in the leaf certificate.
	CANotAuthorizedForThisName
	// TooManyIntermediates results when a path length constraint is
	// violated.
	TooManyIntermediates
	// IncompatibleUsage results when the certificate's key usage indicates
	// that it may only be used for a different purpose.
	IncompatibleUsage
	// NameMismatch results when the subject name of a parent certificate
	// does not match the issuer name in the child.
	NameMismatch
	// NameConstraintsWithoutSANs is a legacy error and is no longer returned.
	NameConstraintsWithoutSANs
	// UnconstrainedName results when a CA certificate contains permitted
	// name constraints, but leaf certificate contains a name of an
	// unsupported or unconstrained type.
	UnconstrainedName
	// TooManyConstraints results when the number of comparison operations
	// needed to check a certificate exceeds the limit set by
	// VerifyOptions.MaxConstraintComparisions. This limit exists to
	// prevent pathological certificates can consuming excessive amounts of
	// CPU time to verify.
	TooManyConstraints
	// CANotAuthorizedForExtKeyUsage results when an intermediate or root
	// certificate does not permit a requested extended key usage.
	CANotAuthorizedForExtKeyUsage
)
```

### type KeyUsage

```go
type KeyUsage int
```

KeyUsage represents the set of actions that are valid for a given key. It’s a bitmap of the KeyUsage* constants.

​	KeyUsage 表示对给定密钥有效的操作集。它是 KeyUsage* 常量的位图。

```go
const (
	KeyUsageDigitalSignature KeyUsage = 1 << iota
	KeyUsageContentCommitment
	KeyUsageKeyEncipherment
	KeyUsageDataEncipherment
	KeyUsageKeyAgreement
	KeyUsageCertSign
	KeyUsageCRLSign
	KeyUsageEncipherOnly
	KeyUsageDecipherOnly
)
```

### type OID <- go1.22.0

```
type OID struct {
	// contains filtered or unexported fields
}
```

An OID represents an ASN.1 OBJECT IDENTIFIER.

​	OID 代表一个 ASN.1 对象标识符 (OBJECT IDENTIFIER)。

#### func OIDFromInts <- go1.22.0

```
func OIDFromInts(oid []uint64) (OID, error)
```

OIDFromInts creates a new OID using ints, each integer is a separate component.

​	OIDFromInts 使用整数创建一个新的 OID，每个整数是一个独立的组件。

#### func ParseOID <- go1.23.0

```
func ParseOID(oid string) (OID, error)
```

ParseOID parses a Object Identifier string, represented by ASCII numbers separated by dots.

​	ParseOID 解析由 ASCII 数字组成的对象标识符字符串，这些数字之间用点分隔。

#### (OID) Equal <- go1.22.0

```
func (oid OID) Equal(other OID) bool
```

Equal returns true when oid and other represents the same Object Identifier.

​	当 `oid` 和 `other` 表示相同的对象标识符时，Equal 返回 true。

#### (OID) EqualASN1OID <- go1.22.0

```
func (oid OID) EqualASN1OID(other asn1.ObjectIdentifier) bool
```

EqualASN1OID returns whether an OID equals an asn1.ObjectIdentifier. If asn1.ObjectIdentifier cannot represent the OID specified by oid, because a component of OID requires more than 31 bits, it returns false.

​	EqualASN1OID 返回一个 OID 是否等于一个 asn1.ObjectIdentifier。如果 asn1.ObjectIdentifier 无法表示由 `oid` 指定的 OID（因为某个 OID 组件需要超过 31 位），则返回 false。

#### (OID) MarshalBinary <- go1.23.0

```
func (o OID) MarshalBinary() ([]byte, error)
```

MarshalBinary implements [encoding.BinaryMarshaler](https://pkg.go.dev/encoding#BinaryMarshaler)

​	MarshalBinary 实现了 [encoding.BinaryMarshaler](https://pkg.go.dev/encoding#BinaryMarshaler)。

#### (OID) MarshalText <- go1.23.0

```
func (o OID) MarshalText() ([]byte, error)
```

MarshalText implements [encoding.TextMarshaler](https://pkg.go.dev/encoding#TextMarshaler)

​	MarshalText 实现了 [encoding.TextMarshaler](https://pkg.go.dev/encoding#TextMarshaler)。

#### (OID) String <- go1.22.0

```
func (oid OID) String() string
```

Strings returns the string representation of the Object Identifier.

​	String 返回对象标识符的字符串表示形式。

#### (*OID) UnmarshalBinary <- go1.23.0

```
func (o *OID) UnmarshalBinary(b []byte) error
```

UnmarshalBinary implements [encoding.BinaryUnmarshaler](https://pkg.go.dev/encoding#BinaryUnmarshaler)

​	UnmarshalBinary 实现了 [encoding.BinaryUnmarshaler](https://pkg.go.dev/encoding#BinaryUnmarshaler)。

#### (*OID) UnmarshalText <- go1.23.0

```
func (o *OID) UnmarshalText(text []byte) error
```

UnmarshalText implements [encoding.TextUnmarshaler](https://pkg.go.dev/encoding#TextUnmarshaler)

​	UnmarshalText 实现了 [encoding.TextUnmarshaler](https://pkg.go.dev/encoding#TextUnmarshaler)。

### type PEMCipher <- go1.1

```go
type PEMCipher int
const (
	PEMCipherDES PEMCipher
	PEMCipher3DES
	PEMCipherAES128
	PEMCipherAES192
	PEMCipherAES256
)
```

Possible values for the EncryptPEMBlock encryption algorithm.

​	EncryptPEMBlock 加密算法的可能值。

### type PublicKeyAlgorithm

```go
type PublicKeyAlgorithm int
const (
	UnknownPublicKeyAlgorithm PublicKeyAlgorithm = iota
	RSA
	DSA // Only supported for parsing.
	ECDSA
	Ed25519
)
```

#### (PublicKeyAlgorithm) String <- go1.10

```go
func (algo PublicKeyAlgorithm) String() string
```

### type RevocationList <- go1.15

```go
type RevocationList struct {
	// Raw contains the complete ASN.1 DER content of the CRL (tbsCertList,
	// signatureAlgorithm, and signatureValue.)
	Raw []byte
	// RawTBSRevocationList contains just the tbsCertList portion of the ASN.1
	// DER.
	RawTBSRevocationList []byte
	// RawIssuer contains the DER encoded Issuer.
	RawIssuer []byte

	// Issuer contains the DN of the issuing certificate.
	Issuer pkix.Name
	// AuthorityKeyId is used to identify the public key associated with the
	// issuing certificate. It is populated from the authorityKeyIdentifier
	// extension when parsing a CRL. It is ignored when creating a CRL; the
	// extension is populated from the issuing certificate itself.
	AuthorityKeyId []byte

	Signature []byte
	// SignatureAlgorithm is used to determine the signature algorithm to be
	// used when signing the CRL. If 0 the default algorithm for the signing
	// key will be used.
	SignatureAlgorithm SignatureAlgorithm

	// RevokedCertificates is used to populate the revokedCertificates
	// sequence in the CRL, it may be empty. RevokedCertificates may be nil,
	// in which case an empty CRL will be created.
	RevokedCertificates []pkix.RevokedCertificate

	// Number is used to populate the X.509 v2 cRLNumber extension in the CRL,
	// which should be a monotonically increasing sequence number for a given
	// CRL scope and CRL issuer. It is also populated from the cRLNumber
	// extension when parsing a CRL.
	Number *big.Int

	// ThisUpdate is used to populate the thisUpdate field in the CRL, which
	// indicates the issuance date of the CRL.
	ThisUpdate time.Time
	// NextUpdate is used to populate the nextUpdate field in the CRL, which
	// indicates the date by which the next CRL will be issued. NextUpdate
	// must be greater than ThisUpdate.
	NextUpdate time.Time

	// Extensions contains raw X.509 extensions. When creating a CRL,
	// the Extensions field is ignored, see ExtraExtensions.
	Extensions []pkix.Extension

	// ExtraExtensions contains any additional extensions to add directly to
	// the CRL.
	ExtraExtensions []pkix.Extension
}
```

RevocationList contains the fields used to create an X.509 v2 Certificate Revocation list with CreateRevocationList.

​	RevocationList 包含用于使用 CreateRevocationList 创建 X.509 v2 证书吊销列表的字段。

#### func ParseRevocationList <- go1.19

```go
func ParseRevocationList(der []byte) (*RevocationList, error)
```

ParseRevocationList parses a X509 v2 Certificate Revocation List from the given ASN.1 DER data.

​	ParseRevocationList 从给定的 ASN.1 DER 数据解析 X509 v2 证书吊销列表。

#### (*RevocationList) CheckSignatureFrom <- go1.19

```go
func (rl *RevocationList) CheckSignatureFrom(parent *Certificate) error
```

CheckSignatureFrom verifies that the signature on rl is a valid signature from issuer.

​	CheckSignatureFrom 验证 rl 上的签名是否来自 issuer 的有效签名。

### type RevocationListEntry <- go1.21.0

```
type RevocationListEntry struct {
	// Raw contains the raw bytes of the revokedCertificates entry. It is set when
	// parsing a CRL; it is ignored when generating a CRL.
	Raw []byte

	// SerialNumber represents the serial number of a revoked certificate. It is
	// both used when creating a CRL and populated when parsing a CRL. It must not
	// be nil.
	SerialNumber *big.Int
	// RevocationTime represents the time at which the certificate was revoked. It
	// is both used when creating a CRL and populated when parsing a CRL. It must
	// not be the zero time.
	RevocationTime time.Time
	// ReasonCode represents the reason for revocation, using the integer enum
	// values specified in RFC 5280 Section 5.3.1. When creating a CRL, the zero
	// value will result in the reasonCode extension being omitted. When parsing a
	// CRL, the zero value may represent either the reasonCode extension being
	// absent (which implies the default revocation reason of 0/Unspecified), or
	// it may represent the reasonCode extension being present and explicitly
	// containing a value of 0/Unspecified (which should not happen according to
	// the DER encoding rules, but can and does happen anyway).
	ReasonCode int

	// Extensions contains raw X.509 extensions. When parsing CRL entries,
	// this can be used to extract non-critical extensions that are not
	// parsed by this package. When marshaling CRL entries, the Extensions
	// field is ignored, see ExtraExtensions.
	Extensions []pkix.Extension
	// ExtraExtensions contains extensions to be copied, raw, into any
	// marshaled CRL entries. Values override any extensions that would
	// otherwise be produced based on the other fields. The ExtraExtensions
	// field is not populated when parsing CRL entries, see Extensions.
	ExtraExtensions []pkix.Extension
}
```

RevocationListEntry represents an entry in the revokedCertificates sequence of a CRL.

### type SignatureAlgorithm

```go
type SignatureAlgorithm int
const (
	UnknownSignatureAlgorithm SignatureAlgorithm = iota

	MD2WithRSA  // Unsupported.
	MD5WithRSA  // Only supported for signing, not verification.
	SHA1WithRSA // Only supported for signing, and verification of CRLs, CSRs, and OCSP responses.
	SHA256WithRSA
	SHA384WithRSA
	SHA512WithRSA
	DSAWithSHA1   // Unsupported.
	DSAWithSHA256 // Unsupported.
	ECDSAWithSHA1 // Only supported for signing, and verification of CRLs, CSRs, and OCSP responses.
	ECDSAWithSHA256
	ECDSAWithSHA384
	ECDSAWithSHA512
	SHA256WithRSAPSS
	SHA384WithRSAPSS
	SHA512WithRSAPSS
	PureEd25519
)
```

#### (SignatureAlgorithm) String <- go1.6

```go
func (algo SignatureAlgorithm) String() string
```

### type SystemRootsError <- go1.1

```go
type SystemRootsError struct {
	Err error
}
```

SystemRootsError results when we fail to load the system root certificates.

​	当我们无法加载系统根证书时，会产生 SystemRootsError。

#### (SystemRootsError) Error <- go1.1

```go
func (se SystemRootsError) Error() string
```

#### (SystemRootsError) Unwrap <- go1.16

```go
func (se SystemRootsError) Unwrap() error
```

### type UnhandledCriticalExtension 

```go
type UnhandledCriticalExtension struct{}
```

#### (UnhandledCriticalExtension) Error 

```go
func (h UnhandledCriticalExtension) Error() string
```

### type UnknownAuthorityError 

```go
type UnknownAuthorityError struct {
	Cert *Certificate
	// contains filtered or unexported fields
}
```

UnknownAuthorityError results when the certificate issuer is unknown

​	当证书颁发机构未知时，会产生 UnknownAuthorityError

#### (UnknownAuthorityError) Error 

```go
func (e UnknownAuthorityError) Error() string
```

### type VerifyOptions 

```go
type VerifyOptions struct {
	// DNSName, if set, is checked against the leaf certificate with
	// Certificate.VerifyHostname or the platform verifier.
	DNSName string

	// Intermediates is an optional pool of certificates that are not trust
	// anchors, but can be used to form a chain from the leaf certificate to a
	// root certificate.
	Intermediates *CertPool
	// Roots is the set of trusted root certificates the leaf certificate needs
	// to chain up to. If nil, the system roots or the platform verifier are used.
	Roots *CertPool

	// CurrentTime is used to check the validity of all certificates in the
	// chain. If zero, the current time is used.
	CurrentTime time.Time

	// KeyUsages specifies which Extended Key Usage values are acceptable. A
	// chain is accepted if it allows any of the listed values. An empty list
	// means ExtKeyUsageServerAuth. To accept any key usage, include ExtKeyUsageAny.
	KeyUsages []ExtKeyUsage

	// MaxConstraintComparisions is the maximum number of comparisons to
	// perform when checking a given certificate's name constraints. If
	// zero, a sensible default is used. This limit prevents pathological
	// certificates from consuming excessive amounts of CPU time when
	// validating. It does not apply to the platform verifier.
	MaxConstraintComparisions int
}
```

VerifyOptions contains parameters for Certificate.Verify.

​	VerifyOptions 包含 Certificate.Verify 的参数。