+++
title = "go"
date = 2024-09-06T21:04:40+08:00
weight = 3
type = "docs"
description = ""
isCJKLanguage = true
draft = false

+++

### Overview

Go is a tool for managing Go source code.

​	Go 是一个用于管理 Go 源代码的工具。

Usage:

```
go <command> [arguments]
```

The commands are:

​	可用的命令有：

```
bug         开始一个错误报告  start a bug report
build       编译包及其依赖项 compile packages and dependencies
clean       移除目标文件和缓存文件 remove object files and cached files
doc         显示包或符号的文档 show documentation for package or symbol
env         打印 Go 环境信息 print Go environment information
fix         更新包以使用新的 API update packages to use new APIs
fmt         使用 gofmt 重新格式化包源代码 gofmt (reformat) package sources
generate    通过处理源代码生成 Go 文件 generate Go files by processing source
get         添加依赖项到当前模块并安装它们 add dependencies to current module and install them
install     编译并安装包及其依赖项 compile and install packages and dependencies
list        列出包或模块 list packages or modules
mod         模块维护 module maintenance
work        工作区维护 workspace maintenance
run         编译并运行 Go 程序 compile and run Go program
telemetry   管理遥测数据和设置 manage telemetry data and settings
test        测试包 test packages
tool        运行指定的 go 工具 run specified go tool
version     打印 Go 版本 print Go version
vet         报告包中可能的错误 report likely mistakes in packages
```

Use "go help <command>" for more information about a command.

​	使用 "go help <命令>" 获取更多关于某个命令的信息。

Additional help topics:

​	其他帮助主题：

```
buildconstraint 构建约束 build constraints
buildmode       构建模式 build modes
c               Go 与 C 之间的调用 calling between Go and C
cache           构建和测试缓存 build and test caching
environment     环境变量 environment variables
filetype        文件类型 file types
go.mod          go.mod 文件 the go.mod file
gopath          GOPATH 环境变量 GOPATH environment variable
goproxy         模块代理协议 module proxy protocol
importpath      导入路径语法 import path syntax
modules         模块、模块版本等 modules, module versions, and more
module-auth     使用 go.sum 进行模块认证 module authentication using go.sum
packages        包列表和模式 package lists and patterns
private         下载非公共代码的配置 configuration for downloading non-public code
testflag        测试标志 testing flags
testfunc        测试函数 testing functions
vcs             使用 GOVCS 控制版本管理 controlling version control with GOVCS
```

Use "go help <topic>" for more information about that topic.

​	使用 "go help <主题>" 获取更多关于该主题的信息。

#### 启动错误报告 Start a bug report 

Usage:

```
go bug
```

Bug opens the default browser and starts a new bug report. The report includes useful system information.

​	Bug 会打开默认浏览器并开始一个新的错误报告。该报告包含有用的系统信息。

#### 编译包及其依赖项 Compile packages and dependencies 

Usage:

```
go build [-o output] [build flags] [packages]
```

Build compiles the packages named by the import paths, along with their dependencies, but it does not install the results.

​	Build 编译由导入路径指定的包及其依赖项，但不会安装编译结果。

If the arguments to build are a list of .go files from a single directory, build treats them as a list of source files specifying a single package.

​	如果 build 的参数是来自单个目录的一组 .go 文件，build 会将它们视为指定单个包的源文件列表。

When compiling packages, build ignores files that end in '_test.go'.

​	在编译包时，build 会忽略以 '_test.go' 结尾的文件。

When compiling a single main package, build writes the resulting executable to an output file named after the last non-major-version component of the package import path. The '.exe' suffix is added when writing a Windows executable. So 'go build example/sam' writes 'sam' or 'sam.exe'. 'go build example.com/foo/v2' writes 'foo' or 'foo.exe', not 'v2.exe'.

​	当编译单个主包时，build 会将生成的可执行文件写入一个以包导入路径中最后一个非主版本组件命名的输出文件。写入 Windows 可执行文件时会添加 '.exe' 后缀。例如，'go build example/sam' 会生成 'sam' 或 'sam.exe'。'go build example.com/foo/v2' 会生成 'foo' 或 'foo.exe'，而不是 'v2.exe'。

When compiling a package from a list of .go files, the executable is named after the first source file. 'go build ed.go rx.go' writes 'ed' or 'ed.exe'.

​	当从一组 .go 文件编译一个包时，生成的可执行文件会以第一个源文件命名。例如，'go build ed.go rx.go' 会生成 'ed' 或 'ed.exe'。

When compiling multiple packages or a single non-main package, build compiles the packages but discards the resulting object, serving only as a check that the packages can be built.

​	当编译多个包或单个非主包时，build 会编译这些包，但丢弃生成的对象文件，仅用于检查这些包是否可以成功编译。

The -o flag forces build to write the resulting executable or object to the named output file or directory, instead of the default behavior described in the last two paragraphs. If the named output is an existing directory or ends with a slash or backslash, then any resulting executables will be written to that directory.

​	-o 标志会强制 build 将生成的可执行文件或对象文件写入指定的输出文件或目录，而不是默认行为。如果指定的输出是一个已存在的目录或以斜杠或反斜杠结尾，则任何生成的可执行文件将写入该目录。

The build flags are shared by the build, clean, get, install, list, run, and test commands:

​	构建标志由 `build`、`clean`、`get`、`install`、`list`、`run` 和 `test` 命令共享：

```
-C dir
	Change to dir before running the command.
	Any files named on the command line are interpreted after
	changing directories.
	If used, this flag must be the first one in the command line.
	在运行命令之前切换到目录 dir。
	命令行中指定的文件在切换目录之后进行解释。
	如果使用该标志，它必须是命令行中的第一个。
-a
	force rebuilding of packages that are already up-to-date.
	强制重新构建已经是最新的包。
-n
	print the commands but do not run them.
	打印命令但不执行它们。
-p n
	the number of programs, such as build commands or
	test binaries, that can be run in parallel.
	The default is GOMAXPROCS, normally the number of CPUs available.
	可以并行运行的程序数量，例如构建命令或测试二进制文件。
	默认值是 GOMAXPROCS，通常为可用的 CPU 数量。
	
-race
	enable data race detection.
	Supported only on linux/amd64, freebsd/amd64, darwin/amd64, darwin/arm64, windows/amd64,
	linux/ppc64le and linux/arm64 (only for 48-bit VMA).
	启用数据竞争检测。
	仅在以下平台支持：linux/amd64、freebsd/amd64、darwin/amd64、darwin/arm64、windows/amd64、
	linux/ppc64le 和 linux/arm64（仅适用于 48 位 VMA）。
	
-msan
	enable interoperation with memory sanitizer.
	Supported only on linux/amd64, linux/arm64, linux/loong64, freebsd/amd64
	and only with Clang/LLVM as the host C compiler.
	PIE build mode will be used on all platforms except linux/amd64.
	启用与内存消毒器的协作。
	仅在以下平台支持：linux/amd64、linux/arm64、linux/loong64、freebsd/amd64，
	并且仅在主机 C 编译器为 Clang/LLVM 时支持。
	除 linux/amd64 外，所有平台都将使用 PIE 构建模式。
	
-asan
	enable interoperation with address sanitizer.
	Supported only on linux/arm64, linux/amd64, linux/loong64.
	Supported on linux/amd64 or linux/arm64 and only with GCC 7 and higher
	or Clang/LLVM 9 and higher.
	And supported on linux/loong64 only with Clang/LLVM 16 and higher.
	启用与地址消毒器的协作。
	仅在以下平台支持：linux/arm64、linux/amd64、linux/loong64。
	在 linux/amd64 或 linux/arm64 平台上支持，并且仅支持 GCC 7 及以上版本
	或 Clang/LLVM 9 及以上版本。
	在 linux/loong64 平台上仅支持 Clang/LLVM 16 及以上版本。
	
-cover
	enable code coverage instrumentation.
	启用代码覆盖率检测。
	
-covermode set,count,atomic
	set the mode for coverage analysis.
	The default is "set" unless -race is enabled,
	in which case it is "atomic".
	The values:
	set: bool: does this statement run?
	count: int: how many times does this statement run?
	atomic: int: count, but correct in multithreaded tests;
		significantly more expensive.
	Sets -cover.
	设置覆盖率分析模式。
	默认模式为 "set"，除非启用了 -race，在这种情况下默认为 "atomic"。
	值包括：
	set: bool: 该语句是否运行？
	count: int: 该语句运行了多少次？
	atomic: int: 计数，但在多线程测试中是正确的；
		显著更昂贵。
	设置 -cover。
	
-coverpkg pattern1,pattern2,pattern3
	For a build that targets package 'main' (e.g. building a Go
	executable), apply coverage analysis to each package matching
	the patterns. The default is to apply coverage analysis to
	packages in the main Go module. See 'go help packages' for a
	description of package patterns.  Sets -cover.
	对于目标为包 'main'（例如构建 Go 可执行文件）的构建，应用覆盖率分析
	到与模式匹配的每个包。默认情况下，覆盖率分析应用于主 Go 模块中的包。
	参见 'go help packages' 了解包模式的描述。设置 -cover。
	
-v
	print the names of packages as they are compiled.
	在编译时打印包的名称。
	
-work
	print the name of the temporary work directory and
	do not delete it when exiting.
	打印临时工作目录的名称，并在退出时不删除它。
	
-x
	print the commands.
	打印命令。
	
-asmflags '[pattern=]arg list'
	arguments to pass on each go tool asm invocation.
	传递给每个 go 工具 asm 调用的参数。
	
-buildmode mode
	build mode to use. See 'go help buildmode' for more.
	使用的构建模式。参见 'go help buildmode' 了解更多信息。
	
-buildvcs
	Whether to stamp binaries with version control information
	("true", "false", or "auto"). By default ("auto"), version control
	information is stamped into a binary if the main package, the main module
	containing it, and the current directory are all in the same repository.
	Use -buildvcs=false to always omit version control information, or
	-buildvcs=true to error out if version control information is available but
	cannot be included due to a missing tool or ambiguous directory structure.
	是否在二进制文件中加入版本控制信息
	("true"、"false" 或 "auto")。默认情况下 ("auto")，如果主包、包含它的主模块
	和当前目录都在同一个仓库中，版本控制信息会被加入到二进制文件中。
	使用 -buildvcs=false 总是省略版本控制信息，或者
	使用 -buildvcs=true 当版本控制信息可用但由于缺少工具或目录结构不明确
	无法包含时会报错。
	
-compiler name
	name of compiler to use, as in runtime.Compiler (gccgo or gc).
	要使用的编译器名称，如 runtime.Compiler 所示（gccgo 或 gc）。
	
-gccgoflags '[pattern=]arg list'
	arguments to pass on each gccgo compiler/linker invocation.
	传递给每个 gccgo 编译器/链接器调用的参数。
	
-gcflags '[pattern=]arg list'
	arguments to pass on each go tool compile invocation.
	传递给每个 go 工具编译调用的参数。
	
-installsuffix suffix
	a suffix to use in the name of the package installation directory,
	in order to keep output separate from default builds.
	If using the -race flag, the install suffix is automatically set to race
	or, if set explicitly, has _race appended to it. Likewise for the -msan
	and -asan flags. Using a -buildmode option that requires non-default compile
	flags has a similar effect.
	用于包安装目录名称的后缀，以便将输出与默认构建区分开。
	如果使用了 -race 标志，安装后缀会自动设置为 race，或者如果明确设置，
	会在其后追加 _race。同样适用于 -msan 和 -asan 标志。使用需要非默认编译标志的
	-buildmode 选项也会产生类似的效果。
	
-ldflags '[pattern=]arg list'
	arguments to pass on each go tool link invocation.
	传递给每个 go 工具链接调用的参数。
	
-linkshared
	build code that will be linked against shared libraries previously
	created with -buildmode=shared.
	构建将链接到以前使用 -buildmode=shared 创建的共享库的代码。
	
-mod mode
	module download mode to use: readonly, vendor, or mod.
	By default, if a vendor directory is present and the go version in go.mod
	is 1.14 or higher, the go command acts as if -mod=vendor were set.
	Otherwise, the go command acts as if -mod=readonly were set.
	See https://golang.org/ref/mod#build-commands for details.
	要使用的模块下载模式：readonly、vendor 或 mod。
	默认情况下，如果存在 vendor 目录并且 go.mod 中的 go 版本是 1.14 或更高版本，
	go 命令的行为就像设置了 -mod=vendor。
	否则，go 命令的行为就像设置了 -mod=readonly。
	详情参见 https://golang.org/ref/mod#build-commands。
	
-modcacherw
	leave newly-created directories in the module cache read-write
	instead of making them read-only.
	使新创建的模块缓存目录保持读写状态，而不是将其设为只读。
	
-modfile file
	in module aware mode, read (and possibly write) an alternate go.mod
	file instead of the one in the module root directory. A file named
	"go.mod" must still be present in order to determine the module root
	directory, but it is not accessed. When -modfile is specified, an
	alternate go.sum file is also used: its path is derived from the
	-modfile flag by trimming the ".mod" extension and appending ".sum".
	在模块感知模式下，读取（并可能写入）一个替代的 go.mod 文件，
	而不是模块根目录中的文件。必须仍然存在一个名为 "go.mod" 的文件，以便确定模块根目录，
	但它不会被访问。当指定了 -modfile 时，也会使用一个替代的 go.sum 文件：
	其路径是通过从 -modfile 标志中去掉 ".mod" 扩展名并追加 ".sum" 得到的。
	
-overlay file
	read a JSON config file that provides an overlay for build operations.
	The file is a JSON struct with a single field, named 'Replace', that
	maps each disk file path (a string) to its backing file path, so that
	a build will run as if the disk file path exists with the contents
	given by the backing file paths, or as if the disk file path does not
	exist if its backing file path is empty. Support for the -overlay flag
	has some limitations: importantly, cgo files included from outside the
	include path must be in the same directory as the Go package they are
	included from, and overlays will not appear when binaries and tests are
	run through go run and go test respectively.
	读取一个 JSON 配置文件，该文件为构建操作提供了一个覆盖层。
	该文件是一个具有单个字段 'Replace' 的 JSON 结构体，该字段将每个磁盘文件路径
	（字符串）映射到其后备文件路径，这样构建操作将运行得好像磁盘文件路径存在，
	其内容由后备文件路径提供，或者如果后备文件路径为空，则好像磁盘文件路径不存在一样。
	对 -overlay 标志的支持有一些限制：重要的是，来自包含路径之外的 cgo 文件
	必须与包含它们的 Go 包在同一目录中，并且覆盖层不会在通过 go run 和 go test
	分别运行二进制文件和测试时出现。
	
-pgo file
	specify the file path of a profile for profile-guided optimization (PGO).
	When the special name "auto" is specified, for each main package in the
	build, the go command selects a file named "default.pgo" in the package's
	directory if that file exists, and applies it to the (transitive)
	dependencies of the main package (other packages are not affected).
	Special name "off" turns off PGO. The default is "auto".
	指定用于配置文件引导优化 (PGO) 的配置文件路径。
	当指定特殊名称 "auto" 时，对于构建中的每个主包，go 命令会在包目录中选择名为
	"default.pgo" 的文件（如果该文件存在），并将其应用于主包的（传递的）依赖项
	（其他包不会受到影响）。特殊名称 "off" 会关闭 PGO。默认值为 "auto"。
	
-pkgdir dir
	install and load all packages from dir instead of the usual locations.
	For example, when building with a non-standard configuration,
	use -pkgdir to keep generated packages in a separate location.
	从 dir 安装并加载所有包，而不是使用通常的位置。
	例如，当使用非标准配置进行构建时，使用 -pkgdir 将生成的包保存在单独的位置。
	
-tags tag,list
	a comma-separated list of additional build tags to consider satisfied
	during the build. For more information about build tags, see
	'go help buildconstraint'. (Earlier versions of Go used a
	space-separated list, and that form is deprecated but still recognized.)
	在构建期间要考虑满足的一组额外构建标签（用逗号分隔的列表）。
	关于构建标签的更多信息，参见 'go help buildconstraint'。
	（早期版本的 Go 使用了空格分隔的列表，这种形式已经被弃用但仍然被识别。）
	
-trimpath
	remove all file system paths from the resulting executable.
	Instead of absolute file system paths, the recorded file names
	will begin either a module path@version (when using modules),
	or a plain import path (when using the standard library, or GOPATH).
	从生成的可执行文件中移除所有文件系统路径。
	而不是绝对的文件系统路径，记录的文件名将从模块路径@版本（使用模块时）
	或简单的导入路径（使用标准库或 GOPATH 时）开始。
	
-toolexec 'cmd args'
	a program to use to invoke toolchain programs like vet and asm.
	For example, instead of running asm, the go command will run
	'cmd args /path/to/asm <arguments for asm>'.
	The TOOLEXEC_IMPORTPATH environment variable will be set,
	matching 'go list -f {{.ImportPath}}' for the package being built.
	用于调用工具链程序（如 vet 和 asm）的程序。
	例如，go 命令将运行 'cmd args /path/to/asm <asm 的参数>'，而不是运行 asm。
	TOOLEXEC_IMPORTPATH 环境变量将被设置，与 'go list -f {{.ImportPath}}' 对应于被构建的包。
```

The -asmflags, -gccgoflags, -gcflags, and -ldflags flags accept a space-separated list of arguments to pass to an underlying tool during the build. To embed spaces in an element in the list, surround it with either single or double quotes. The argument list may be preceded by a package pattern and an equal sign, which restricts the use of that argument list to the building of packages matching that pattern (see 'go help packages' for a description of package patterns). Without a pattern, the argument list applies only to the packages named on the command line. The flags may be repeated with different patterns in order to specify different arguments for different sets of packages. If a package matches patterns given in multiple flags, the latest match on the command line wins. For example, 'go build -gcflags=-S fmt' prints the disassembly only for package fmt, while 'go build -gcflags=all=-S fmt' prints the disassembly for fmt and all its dependencies.

​	`-asmflags`、`-gccgoflags`、`-gcflags` 和 `-ldflags` 标志接受一个空格分隔的参数列表，传递给构建期间的底层工具。要在列表中的元素中嵌入空格，可以使用单引号或双引号将其括起来。参数列表可以由包模式和等号前缀，这限制了参数列表仅用于构建与该模式匹配的包（参见 'go help packages' 了解包模式的描述）。如果没有模式，参数列表仅适用于命令行上指定的包。可以使用不同的模式重复这些标志，以便为不同的包集指定不同的参数。如果一个包与多个标志中的模式匹配，则命令行上最新的匹配优先。例如，`go build -gcflags=-S fmt` 仅打印包 fmt 的反汇编信息，而 `go build -gcflags=all=-S fmt` 会打印 fmt 及其所有依赖项的反汇编信息。

For more about specifying packages, see 'go help packages'. For more about where packages and binaries are installed, run 'go help gopath'. For more about calling between Go and C/C++, run 'go help c'.

​	有关如何指定包的更多信息，请参阅 'go help packages'。有关包和二进制文件安装位置的更多信息，请运行 'go help gopath'。有关 Go 与 C/C++ 之间调用的更多信息，请参阅 'go help c'。

Note: Build adheres to certain conventions such as those described by 'go help gopath'. Not all projects can follow these conventions, however. Installations that have their own conventions or that use a separate software build system may choose to use lower-level invocations such as 'go tool compile' and 'go tool link' to avoid some of the overheads and design decisions of the build tool.

​	注意：构建遵循某些约定，例如 'go help gopath' 中描述的那些。然而，并非所有项目都能遵循这些约定。使用自定义约定或单独的软件构建系统的安装可能会选择使用较低级的调用，例如 'go tool compile' 和 'go tool link'，以避免构建工具的一些开销和设计决策。

See also: go install, go get, go clean.

​	另请参阅：go install、go get、go clean。

#### 删除目标文件和缓存文件 Remove object files and cached files 

Usage:

```
go clean [-i] [-r] [-cache] [-testcache] [-modcache] [-fuzzcache] [build flags] [packages]
```

Clean removes object files from package source directories. The go command builds most objects in a temporary directory, so go clean is mainly concerned with object files left by other tools or by manual invocations of go build.

​	clean 会从包的源文件目录中删除目标文件。`go` 命令会将大多数目标文件构建到一个临时目录中，因此 `go clean` 主要关注其他工具或手动调用 `go build` 留下的目标文件。

If a package argument is given or the -i or -r flag is set, clean removes the following files from each of the source directories corresponding to the import paths:

​	如果指定了包参数或设置了 `-i` 或 `-r` 标志，`clean` 会从与导入路径相对应的源目录中删除以下文件：

```
_obj/            旧的对象文件目录，遗留自 Makefile - old object directory, left from Makefiles
_test/           旧的测试目录，遗留自 Makefile - old test directory, left from Makefiles
_testmain.go     旧的 gotest 文件，遗留自 Makefile - old gotest file, left from Makefiles
test.out         旧的测试日志，遗留自 Makefile - old test log, left from Makefiles
build.out        旧的构建日志，遗留自 Makefile - old test log, left from Makefiles
*.[568ao]        对象文件，遗留自 Makefile - object files, left from Makefiles

DIR(.exe)        来自 `go build` from go build
DIR.test(.exe)   来自 `go test -c` from go test -c
MAINFILE(.exe)   来自 `go build MAINFILE.go` from go build MAINFILE.go
*.so             来自 SWIG from SWIG
```

In the list, DIR represents the final path element of the directory, and MAINFILE is the base name of any Go source file in the directory that is not included when building the package.

​	在列表中，`DIR` 代表目录的最后路径元素，`MAINFILE` 是目录中任意 Go 源文件的基本名称，且这些文件在构建包时不包括在内。

The -i flag causes clean to remove the corresponding installed archive or binary (what 'go install' would create).

​	`-i` 标志会导致 clean 删除相应的已安装归档或二进制文件（即 `go install` 会创建的内容）。

The -n flag causes clean to print the remove commands it would execute, but not run them.

​	`-n` 标志会导致 clean 打印它将执行的删除命令，但不实际运行这些命令。

The -r flag causes clean to be applied recursively to all the dependencies of the packages named by the import paths.

​	`-r` 标志会导致 clean 递归应用到导入路径指定的包的所有依赖项。

The -x flag causes clean to print remove commands as it executes them.

​	`-x` 标志会导致 clean 在执行时打印删除命令。

The -cache flag causes clean to remove the entire go build cache.

​	`-cache` 标志会导致 clean 删除整个 `go` 构建缓存。

The -testcache flag causes clean to expire all test results in the go build cache.

​	`-testcache` 标志会导致 clean 使 `go` 构建缓存中的所有测试结果失效。

The -modcache flag causes clean to remove the entire module download cache, including unpacked source code of versioned dependencies.

​	`-modcache` 标志会导致 clean 删除整个模块下载缓存，包括解压的版本依赖的源代码。

The -fuzzcache flag causes clean to remove files stored in the Go build cache for fuzz testing. The fuzzing engine caches files that expand code coverage, so removing them may make fuzzing less effective until new inputs are found that provide the same coverage. These files are distinct from those stored in testdata directory; clean does not remove those files.

​	`-fuzzcache` 标志会导致 clean 删除 `go` 构建缓存中用于模糊测试的文件。模糊测试引擎会缓存扩展代码覆盖率的文件，因此删除这些文件可能会使模糊测试效果减弱，直到找到新的输入来提供相同的覆盖率为止。这些文件与存储在 `testdata` 目录中的文件不同；`clean` 不会删除那些文件。

For more about build flags, see 'go help build'.

​	有关构建标志的更多信息，请参阅 'go help build'。

For more about specifying packages, see 'go help packages'.

​	有关指定包的更多信息，请参阅 'go help packages'。

#### 显示包或符号的文档 Show documentation for package or symbol 

Usage:

```
go doc [doc flags] [package|[package.]symbol[.methodOrField]]
```

Doc prints the documentation comments associated with the item identified by its arguments (a package, const, func, type, var, method, or struct field) followed by a one-line summary of each of the first-level items "under" that item (package-level declarations for a package, methods for a type, etc.).

​	`doc` 打印与其参数标识的项目（包、常量、函数、类型、变量、方法或结构字段）相关的文档注释，然后显示该项目 "下" 的每个顶级项目的单行摘要（包级声明对于包、方法对于类型等）。

Doc accepts zero, one, or two arguments.

​	`doc` 接受零个、一个或两个参数。

Given no arguments, that is, when run as

​	如果没有参数，即运行：

```
go doc
```

it prints the package documentation for the package in the current directory. If the package is a command (package main), the exported symbols of the package are elided from the presentation unless the -cmd flag is provided.

​	它会打印当前目录中包的文档。如果包是一个命令（`main` 包），则包中的导出符号将从展示中省略，除非提供了 `-cmd` 标志。

When run with one argument, the argument is treated as a Go-syntax-like representation of the item to be documented. What the argument selects depends on what is installed in GOROOT and GOPATH, as well as the form of the argument, which is schematically one of these:

​	当运行一个参数时，该参数被视为待记录项目的 Go 语法表示形式。参数选择的内容取决于安装在 `GOROOT` 和 `GOPATH` 中的内容，以及参数的形式，大致如下：

```
go doc <pkg>
go doc <sym>[.<methodOrField>]
go doc [<pkg>.]<sym>[.<methodOrField>]
go doc [<pkg>.][<sym>.]<methodOrField>
```

The first item in this list matched by the argument is the one whose documentation is printed. (See the examples below.) However, if the argument starts with a capital letter it is assumed to identify a symbol or method in the current directory.

​	列表中第一个与参数匹配的项目是打印其文档的项目。（参见下面的示例。）然而，如果参数以大写字母开头，则假定它标识当前目录中的符号或方法。

For packages, the order of scanning is determined lexically in breadth-first order. That is, the package presented is the one that matches the search and is nearest the root and lexically first at its level of the hierarchy. The GOROOT tree is always scanned in its entirety before GOPATH.

​	对于包，扫描顺序是按词法顺序广度优先。也就是说，展示的包是与搜索匹配并且最接近根目录且在其层级中词法顺序最靠前的包。在扫描 `GOPATH` 之前，始终会完全扫描 `GOROOT` 树。

If there is no package specified or matched, the package in the current directory is selected, so "go doc Foo" shows the documentation for symbol Foo in the current package.

​	如果没有指定包或没有匹配到包，则选择当前目录中的包，因此 `go doc Foo` 会显示当前包中符号 `Foo` 的文档。

The package path must be either a qualified path or a proper suffix of a path. The go tool's usual package mechanism does not apply: package path elements like . and ... are not implemented by go doc.

​	包路径必须是合格路径或路径的适当后缀。`go` 工具的通常包机制不适用：`go doc` 未实现类似 `.` 和 `...` 这样的包路径元素。

When run with two arguments, the first is a package path (full path or suffix), and the second is a symbol, or symbol with method or struct field:

​	当运行两个参数时，第一个参数是包路径（完整路径或后缀），第二个参数是符号，或者符号及方法或结构字段：

```
go doc <pkg> <sym>[.<methodOrField>]
```

In all forms, when matching symbols, lower-case letters in the argument match either case but upper-case letters match exactly. This means that there may be multiple matches of a lower-case argument in a package if different symbols have different cases. If this occurs, documentation for all matches is printed.

​	在所有形式中，当匹配符号时，参数中的小写字母可以匹配大小写，但大写字母必须完全匹配。这意味着如果包中不同符号具有不同的大小写，可能会有多个匹配项。如果发生这种情况，将打印所有匹配项的文档。

Examples:

```
go doc
	Show documentation for current package.
	显示当前包的文档。
	
go doc Foo
	Show documentation for Foo in the current package.
	(Foo starts with a capital letter so it cannot match
	a package path.)
	显示当前包中 Foo 的文档。
	（Foo 以大写字母开头，因此无法匹配包路径。）
	
go doc encoding/json
	Show documentation for the encoding/json package.
	显示 encoding/json 包的文档。
	
go doc json
	Shorthand for encoding/json.
	encoding/json 的简写形式。
	
go doc json.Number (or go doc json.number)
	Show documentation and method summary for json.Number.
	显示 json.Number 的文档及其方法摘要。
	
go doc json.Number.Int64 (or go doc json.number.int64)
	Show documentation for json.Number's Int64 method.
	显示 json.Number 的 Int64 方法的文档。
	
go doc cmd/doc
	Show package docs for the doc command.
	显示 doc 命令的包文档。
	
go doc -cmd cmd/doc
	Show package docs and exported symbols within the doc command.
	显示 doc 命令的包文档及导出符号。
	
go doc template.new
	Show documentation for html/template's New function.
	(html/template is lexically before text/template)
	显示 html/template 的 New 函数的文档。
	（html/template 在词法上位于 text/template 之前）
	
go doc text/template.new # One argument
	Show documentation for text/template's New function.
	显示 text/template 的 New 函数的文档。
	
go doc text/template new # Two arguments
	Show documentation for text/template's New function.
	显示 text/template 的 New 函数的文档。

At least in the current tree, these invocations all print the
documentation for json.Decoder's Decode method:
至少在当前树中，这些调用都打印 json.Decoder 的 Decode 方法的文档：


go doc json.Decoder.Decode
go doc json.decoder.decode
go doc json.decode
cd go/src/encoding/json; go doc decode
```

Flags:

​	标志：

```
-all
	Show all the documentation for the package.
	显示包的所有文档。
	
-c
	Respect case when matching symbols.
	匹配符号时区分大小写。
	
-cmd
	Treat a command (package main) like a regular package.
	Otherwise package main's exported symbols are hidden
	when showing the package's top-level documentation.
	将命令（`main` 包）视为常规包。
	否则在显示包的顶级文档时，会隐藏 `main` 包的导出符号。
	
-short
	One-line representation for each symbol.
	每个符号的单行表示。
	
-src
	Show the full source code for the symbol. This will
	display the full Go source of its declaration and
	definition, such as a function definition (including
	the body), type declaration or enclosing const
	block. The output may therefore include unexported
	details.
	显示符号的完整源代码。这将显示其声明和定义的完整 Go 源代码，
	例如函数定义（包括函数体）、类型声明或包含的常量块。
	因此，输出可能包含未导出的细节。
	
-u
	Show documentation for unexported as well as exported
	symbols, methods, and fields.
	显示未导出和导出的符号、方法和字段的文档。
```

#### 打印 Go 环境信息 Print Go environment information 

Usage:

```
go env [-json] [-changed] [-u] [-w] [var ...]
```

Env prints Go environment information.

​	`env` 打印 Go 的环境信息。

By default env prints information as a shell script (on Windows, a batch file). If one or more variable names is given as arguments, env prints the value of each named variable on its own line.

​	默认情况下，`env` 会以 shell 脚本的形式输出信息（在 Windows 上为批处理文件）。如果给定一个或多个变量名作为参数，`env` 将逐行打印每个指定变量的值。

The -json flag prints the environment in JSON format instead of as a shell script.

​	`-json` 标志将以 JSON 格式而不是 shell 脚本格式输出环境信息。

The -u flag requires one or more arguments and unsets the default setting for the named environment variables, if one has been set with 'go env -w'.

​	`-u` 标志要求一个或多个参数，并取消使用 `go env -w` 设置的默认环境变量。

The -w flag requires one or more arguments of the form NAME=VALUE and changes the default settings of the named environment variables to the given values.

​	`-w` 标志要求以 `NAME=VALUE` 的形式给出一个或多个参数，并将指定环境变量的默认设置更改为给定值。

The -changed flag prints only those settings whose effective value differs from the default value that would be obtained in an empty environment with no prior uses of the -w flag.

​	`-changed` 标志仅打印与默认值不同的设置，这些设置是在没有使用 `-w` 标志的情况下获得的。

For more about environment variables, see 'go help environment'.

​	有关环境变量的更多信息，请参见 `go help environment`。

#### 使用新 API 更新包 Update packages to use new APIs 

Usage:

```
go fix [-fix list] [packages]
```

Fix runs the Go fix command on the packages named by the import paths.

​	`fix` 对由导入路径命名的包运行 Go 的修复命令。

The -fix flag sets a comma-separated list of fixes to run. The default is all known fixes. (Its value is passed to 'go tool fix -r'.)

​	`-fix` 标志设置一个以逗号分隔的修复列表。默认值为所有已知修复。（它的值会传递给 `go tool fix -r`。）

For more about fix, see 'go doc cmd/fix'. For more about specifying packages, see 'go help packages'.

​	有关修复的更多信息，请参见 `go doc cmd/fix`。有关指定包的更多信息，请参见 `go help packages`。

To run fix with other options, run 'go tool fix'.

​	要使用其他选项运行修复，请运行 `go tool fix`。

See also: go fmt, go vet.

​	另见：`go fmt`，`go vet`。

#### 使用 Gofmt 格式化包源文件 Gofmt (reformat) package sources 

Usage:

```
go fmt [-n] [-x] [packages]
```

Fmt runs the command 'gofmt -l -w' on the packages named by the import paths. It prints the names of the files that are modified.

​	`fmt` 在由导入路径命名的包上运行 `gofmt -l -w` 命令。它会打印被修改的文件的名称。

For more about gofmt, see 'go doc cmd/gofmt'. For more about specifying packages, see 'go help packages'.

​	有关 `gofmt` 的更多信息，请参见 `go doc cmd/gofmt`。有关指定包的更多信息，请参见 `go help packages`。

The -n flag prints commands that would be executed. The -x flag prints commands as they are executed.

​	`-n` 标志打印将要执行的命令。`-x` 标志在执行命令时打印命令。

The -mod flag's value sets which module download mode to use: readonly or vendor. See 'go help modules' for more.

​	`-mod` 标志的值设置使用的模块下载模式：`readonly` 或 `vendor`。有关更多信息，请参见 `go help modules`。

To run gofmt with specific options, run gofmt itself.

​	要使用特定选项运行 `gofmt`，请直接运行 `gofmt`。

See also: go fix, go vet.

​	另见：`go fix`，`go vet`。

#### 通过处理源代码生成 Go 文件 Generate Go files by processing source 

Usage:

```
go generate [-run regexp] [-n] [-v] [-x] [build flags] [file.go... | packages]
```

Generate runs commands described by directives within existing files. Those commands can run any process but the intent is to create or update Go source files.

​	`generate` 运行由现有文件中的指令描述的命令。这些命令可以运行任何进程，但目的是创建或更新 Go 源文件。

Go generate is never run automatically by go build, go test, and so on. It must be run explicitly.

​	`go generate` 不会被 `go build`、`go test` 等命令自动运行。它必须显式运行。

Go generate scans the file for directives, which are lines of the form,

​	`go generate` 会扫描文件中的指令，这些指令的格式为：

```
//go:generate command argument...
```

(note: no leading spaces and no space in "//go") where command is the generator to be run, corresponding to an executable file that can be run locally. It must either be in the shell path (gofmt), a fully qualified path (/usr/you/bin/mytool), or a command alias, described below.

​	（注意：没有前导空格，且 `//go` 中没有空格），其中 `command` 是要运行的生成器，对应于可以在本地运行的可执行文件。它必须位于 shell 路径中（如 `gofmt`），或是一个完整路径（如 `/usr/you/bin/mytool`），或是下面描述的命令别名。

Note that go generate does not parse the file, so lines that look like directives in comments or multiline strings will be treated as directives.

​	请注意，`go generate` 不会解析文件，因此在注释或多行字符串中看似指令的行也会被视为指令。

The arguments to the directive are space-separated tokens or double-quoted strings passed to the generator as individual arguments when it is run.

​	指令的参数是空格分隔的标记或双引号字符串，当生成器运行时，这些参数将作为独立参数传递给生成器。

Quoted strings use Go syntax and are evaluated before execution; a quoted string appears as a single argument to the generator.

​	Quoted strings 使用 Go 语法，在执行前会进行求值；在生成器中，quoted strings 会作为一个单独的参数出现。

To convey to humans and machine tools that code is generated, generated source should have a line that matches the following regular expression (in Go syntax):

​	为了传达给人类和机器工具代码是生成的，生成的源代码应包含一行与以下正则表达式匹配的代码（使用 Go 语法）：

```
^// Code generated .* DO NOT EDIT\.$
```

This line must appear before the first non-comment, non-blank text in the file.

​	该行必须出现在文件中的第一行非注释、非空白文本之前。

Go generate sets several variables when it runs the generator:

​	`go generate` 在运行生成器时会设置几个变量：

```
$GOARCH
	The execution architecture (arm, amd64, etc.)
	执行架构（arm, amd64 等）
	
$GOOS
	The execution operating system (linux, windows, etc.)
	执行操作系统（linux, windows 等）
	
$GOFILE
	The base name of the file.
	文件的基本名称。
	
$GOLINE
	The line number of the directive in the source file.
	源文件中指令的行号。
	
$GOPACKAGE
	The name of the package of the file containing the directive.
	包含指令的文件所属的包名称。
	
$GOROOT
	The GOROOT directory for the 'go' command that invoked the
	generator, containing the Go toolchain and standard library.
	调用生成器的 `go` 命令的 `GOROOT` 目录，包含 Go 工具链和标准库。
	
$DOLLAR
	A dollar sign.
	美元符号。
	
$PATH
	The $PATH of the parent process, with $GOROOT/bin
	placed at the beginning. This causes generators
	that execute 'go' commands to use the same 'go'
	as the parent 'go generate' command.
	父进程的 $PATH，其中将 $GOROOT/bin 放在开头。这将使执行 `go` 命令的生成器使用与父 `go generate` 命令相同的 `go`。
	
```

Other than variable substitution and quoted-string evaluation, no special processing such as "globbing" is performed on the command line.

​	除了变量替换和 quoted-string 求值之外，命令行上没有进行特殊处理（如 "globbing"）。

As a last step before running the command, any invocations of any environment variables with alphanumeric names, such as $GOFILE or $HOME, are expanded throughout the command line. The syntax for variable expansion is $NAME on all operating systems. Due to the order of evaluation, variables are expanded even inside quoted strings. If the variable NAME is not set, $NAME expands to the empty string.

​	在运行命令之前的最后一步，所有带字母数字名称的环境变量的调用，例如 `$GOFILE` 或 `$HOME`，将在整个命令行中展开。变量展开的语法在所有操作系统上均为 `$NAME`。由于求值顺序的原因，变量即使在 quoted strings 中也会展开。如果变量 NAME 未设置，则 `$NAME` 会展开为空字符串。

A directive of the form,

​	形式为：

```
//go:generate -command xxx args...
```

specifies, for the remainder of this source file only, that the string xxx represents the command identified by the arguments. This can be used to create aliases or to handle multiword generators. For example,

的指令会指定，在该源文件的剩余部分中，字符串 `xxx` 代表由参数标识的命令。这可以用于创建别名或处理多字生成器。例如：

```
//go:generate -command foo go tool foo
```

specifies that the command "foo" represents the generator "go tool foo".

指定命令 "foo" 代表生成器 "go tool foo"。

Generate processes packages in the order given on the command line, one at a time. If the command line lists .go files from a single directory, they are treated as a single package. Within a package, generate processes the source files in a package in file name order, one at a time. Within a source file, generate runs generators in the order they appear in the file, one at a time. The go generate tool also sets the build tag "generate" so that files may be examined by go generate but ignored during build.

​	`generate` 按给定命令行中的顺序处理包，一个包接一个包。如果命令行列出单个目录中的 .go 文件，它们会被视为一个包。对于一个包，`generate` 按文件名顺序处理包中的源文件，一个文件接一个文件。在一个源文件中，`generate` 按顺序运行生成器，一个接一个。`go generate` 工具还设置了构建标记 `generate`，以便文件可以被 `go generate` 检查，但在构建期间忽略。

For packages with invalid code, generate processes only source files with a valid package clause.

​	对于包含无效代码的包，`generate` 只处理带有有效包声明的源文件。

If any generator returns an error exit status, "go generate" skips all further processing for that package.

​	如果任何生成器返回错误退出状态，“`go generate`”将跳过该包的所有进一步处理。

The generator is run in the package's source directory.

​	生成器在包的源目录中运行。

Go generate accepts two specific flags:

​	`go generate` 接受两个特定标志：

```
-run=""
	if non-empty, specifies a regular expression to select
	directives whose full original source text (excluding
	any trailing spaces and final newline) matches the
	expression.
	如果非空，指定一个正则表达式以选择其完整的原始源文本
	（不包括任何尾随空格和最终换行符）匹配该表达式的指令。
	
-skip=""
	if non-empty, specifies a regular expression to suppress
	directives whose full original source text (excluding
	any trailing spaces and final newline) matches the
	expression. If a directive matches both the -run and
	the -skip arguments, it is skipped.
	如果非空，指定一个正则表达式以忽略其完整的原始源文本
	（不包括任何尾随空格和最终换行符）匹配该表达式的指令。
	如果某个指令同时匹配 -run 和 -skip 参数，则该指令会被跳过。
```

It also accepts the standard build flags including -v, -n, and -x. The -v flag prints the names of packages and files as they are processed. The -n flag prints commands that would be executed. The -x flag prints commands as they are executed.

​	它还接受标准的构建标志，包括 -v、-n 和 -x。-v 标志打印处理的包和文件的名称。-n 标志打印将要执行的命令。-x 标志打印执行的命令。

For more about build flags, see 'go help build'.

​	有关构建标志的更多信息，请参见 'go help build'。

For more about specifying packages, see 'go help packages'.

​	有关指定包的更多信息，请参见 'go help packages'。

#### 添加依赖项到当前模块并安装它们 Add dependencies to current module and install them 

Usage:

```
go get [-t] [-u] [-v] [build flags] [packages]
```

Get resolves its command-line arguments to packages at specific module versions, updates go.mod to require those versions, and downloads source code into the module cache.

​	Get 将其命令行参数解析为特定模块版本的包，更新 go.mod 以要求这些版本，并将源代码下载到模块缓存中。

To add a dependency for a package or upgrade it to its latest version:

​	要为某个包添加依赖项或将其升级到最新版本：

```
go get example.com/pkg
```

To upgrade or downgrade a package to a specific version:

​	要升级或降级到特定版本的包：

```
go get example.com/pkg@v1.2.3
```

To remove a dependency on a module and downgrade modules that require it:

​	要移除对模块的依赖并降级依赖该模块的模块：

```
go get example.com/mod@none
```

To upgrade the minimum required Go version to the latest released Go version:

​	要将最低要求的 Go 版本升级到最新发布的 Go 版本：

```
go get go@latest
```

To upgrade the Go toolchain to the latest patch release of the current Go toolchain:

​	要将 Go 工具链升级到当前 Go 工具链的最新补丁版本：

```
go get toolchain@patch
```

See https://golang.org/ref/mod#go-get for details.

​	详细信息请参见 https://golang.org/ref/mod#go-get。

In earlier versions of Go, 'go get' was used to build and install packages. Now, 'go get' is dedicated to adjusting dependencies in go.mod. 'go install' may be used to build and install commands instead. When a version is specified, 'go install' runs in module-aware mode and ignores the go.mod file in the current directory. For example:

​	在较早版本的 Go 中，'go get' 用于构建和安装包。现在，'go get' 专用于调整 go.mod 中的依赖项。'go install' 可用于构建和安装命令。当指定了版本时，'go install' 以模块感知模式运行，并忽略当前目录中的 go.mod 文件。例如：

```
go install example.com/pkg@v1.2.3
go install example.com/pkg@latest
```

See 'go help install' or https://golang.org/ref/mod#go-install for details.

​	有关详细信息，请参见 'go help install' 或 https://golang.org/ref/mod#go-install。

'go get' accepts the following flags.

​	'go get' 接受以下标志。

The -t flag instructs get to consider modules needed to build tests of packages specified on the command line.

​	-t 标志指示 get 考虑构建命令行中指定包的测试所需的模块。

The -u flag instructs get to update modules providing dependencies of packages named on the command line to use newer minor or patch releases when available.

​	-u 标志指示 get 更新命令行中指定包的依赖项所提供的模块，以使用可用的较新次要版本或补丁版本。

The -u=patch flag (not -u patch) also instructs get to update dependencies, but changes the default to select patch releases.

​	-u=patch 标志（不是 -u patch）还指示 get 更新依赖项，但默认选择补丁版本。

When the -t and -u flags are used together, get will update test dependencies as well.

​	当 -t 和 -u 标志一起使用时，get 还将更新测试依赖项。

The -x flag prints commands as they are executed. This is useful for debugging version control commands when a module is downloaded directly from a repository.

​	-x 标志打印执行的命令。当直接从存储库下载模块时，这对于调试版本控制命令非常有用。

For more about build flags, see 'go help build'.

​	有关构建标志的更多信息，请参见 'go help build'。

For more about modules, see https://golang.org/ref/mod.

​	有关模块的更多信息，请参见 https://golang.org/ref/mod。

For more about using 'go get' to update the minimum Go version and suggested Go toolchain, see https://go.dev/doc/toolchain.

​	有关使用 'go get' 更新最低 Go 版本和建议的 Go 工具链的更多信息，请参见 https://go.dev/doc/toolchain。

For more about specifying packages, see 'go help packages'.

​	有关指定包的更多信息，请参见 'go help packages'。

This text describes the behavior of get using modules to manage source code and dependencies. If instead the go command is running in GOPATH mode, the details of get's flags and effects change, as does 'go help get'. See 'go help gopath-get'.

​	本文描述了使用模块管理源代码和依赖项时 get 的行为。如果 go 命令是在 GOPATH 模式下运行的，则 get 的标志和效果的详细信息会有所不同，具体请参见 'go help get'。参见 'go help gopath-get'。

See also: go build, go install, go clean, go mod.

​	另见：go build、go install、go clean、go mod。

#### 编译并安装包和依赖项 Compile and install packages and dependencies 

Usage:

```
go install [build flags] [packages]
```

Install compiles and installs the packages named by the import paths.

​	Install 编译并安装由导入路径命名的包。

Executables are installed in the directory named by the GOBIN environment variable, which defaults to $GOPATH/bin or $HOME/go/bin if the GOPATH environment variable is not set. Executables in $GOROOT are installed in $GOROOT/bin or $GOTOOLDIR instead of $GOBIN.

​	可执行文件安装在由 GOBIN 环境变量指定的目录中，如果未设置 GOPATH 环境变量，则默认为 $GOPATH/bin 或 $HOME/go/bin。$GOROOT 中的可执行文件安装在 $GOROOT/bin 或 $GOTOOLDIR，而不是 $GOBIN。

If the arguments have version suffixes (like @latest or @v1.0.0), "go install" builds packages in module-aware mode, ignoring the go.mod file in the current directory or any parent directory, if there is one. This is useful for installing executables without affecting the dependencies of the main module. To eliminate ambiguity about which module versions are used in the build, the arguments must satisfy the following constraints:

​	如果参数带有版本后缀（如 @latest 或 @v1.0.0），“go install”将在模块感知模式下构建包，忽略当前目录或任何父目录中的 go.mod 文件（如果存在）。这对于安装可执行文件而不影响主模块的依赖项非常有用。为消除有关构建中使用的模块版本的歧义，参数必须满足以下约束：

- Arguments must be package paths or package patterns (with "..." wildcards). They must not be standard packages (like fmt), meta-patterns (std, cmd, all), or relative or absolute file paths.
- 参数必须是包路径或包模式（带有 "..." 通配符）。它们不能是标准包（如 fmt）、元模式（std、cmd、all）或相对或绝对文件路径。

- All arguments must have the same version suffix. Different queries are not allowed, even if they refer to the same version.
- 所有参数必须具有相同的版本后缀。即使它们引用相同的版本，也不允许不同的查询。

- All arguments must refer to packages in the same module at the same version.
- 所有参数必须引用同一模块中相同版本的包。

- Package path arguments must refer to main packages. Pattern arguments will only match main packages.
- 包路径参数必须引用 main 包。模式参数将仅匹配 main 包。

- No module is considered the "main" module. If the module containing packages named on the command line has a go.mod file, it must not contain directives (replace and exclude) that would cause it to be interpreted differently than if it were the main module. The module must not require a higher version of itself.
- 没有模块被视为“主”模块。如果包含命令行中命名包的模块有一个 go.mod 文件，则它不得包含会导致其被解释为与主模块不同的指令（replace 和 exclude）。该模块不得要求更高版本的自身。

- Vendor directories are not used in any module. (Vendor directories are not included in the module zip files downloaded by 'go install'.)
- 在任何模块中都不使用 vendor 目录。（vendor 目录不会包含在 'go install' 下载的模块 zip 文件中。）

If the arguments don't have version suffixes, "go install" may run in module-aware mode or GOPATH mode, depending on the GO111MODULE environment variable and the presence of a go.mod file. See 'go help modules' for details. If module-aware mode is enabled, "go install" runs in the context of the main module.

​	如果参数没有版本后缀，“go install”可能会在模块感知模式或 GOPATH 模式下运行，具体取决于 GO111MODULE 环境变量和 go.mod 文件的存在情况。有关详细信息，请参见 'go help modules'。如果启用了模块感知模式，“go install”将在主模块的上下文中运行。

When module-aware mode is disabled, non-main packages are installed in the directory $GOPATH/pkg/$GOOS_$GOARCH. When module-aware mode is enabled, non-main packages are built and cached but not installed.

​	当模块感知模式被禁用时，非主包会安装在 $GOPATH/pkg/$GOOS_$GOARCH 目录中。启用模块感知模式时，非主包会被构建并缓存，但不会安装。

Before Go 1.20, the standard library was installed to `$GOROOT/pkg/$GOOS_$GOARCH`. Starting in Go 1.20, the standard library is built and cached but not installed. Setting `GODEBUG=installgoroot=all` restores the use of `$GOROOT/pkg/$GOOS_$GOARCH`.

在 Go 1.20 之前，标准库会安装到 `$GOROOT/pkg/$GOOS_$GOARCH `目录中。从 Go 1.20 开始，标准库会被构建并缓存，但不会安装。设置 `GODEBUG=installgoroot=all` 可以恢复使用 `$GOROOT/pkg/$GOOS_$GOARCH`。

For more about build flags, see 'go help build'.

​	有关构建标志的更多信息，请参见 'go help build'。

For more about specifying packages, see 'go help packages'.

​	有关指定包的更多信息，请参见 'go help packages'。

See also: go build, go get, go clean.

​	另见：`go build`，`go get`，`go clean`。

#### 列出包或模块 List packages or modules 

Usage:

```
go list [-f format] [-json] [-m] [list flags] [build flags] [packages]
```

List lists the named packages, one per line. The most commonly-used flags are -f and -json, which control the form of the output printed for each package. Other list flags, documented below, control more specific details.

​	`list`命令会列出指定的包，每行一个。最常用的选项是 `-f` 和 `-json`，它们控制每个包的输出形式。其他选项（在下文中有详细说明）则控制更具体的细节。

The default output shows the package import path:

​	默认输出显示包的导入路径：

```
bytes
encoding/json
github.com/gorilla/mux
golang.org/x/net/html
```

The -f flag specifies an alternate format for the list, using the syntax of package template. The default output is equivalent to -f '{{.ImportPath}}'. The struct being passed to the template is:

​	`-f` 选项指定使用包模板语法的替代输出格式。默认输出等同于 `-f '{{.ImportPath}}'`。传递给模板的结构体如下：

```go
type Package struct {
    Dir            string   // 包源文件所在的目录
    ImportPath     string   // 该目录下包的导入路径
    ImportComment  string   // 包声明中的导入注释路径
    Name           string   // 包名
    Doc            string   // 包的文档字符串
    Target         string   // 安装路径
    Shlib          string   // 包含此包的共享库（仅在使用 -linkshared 时设置）
    Goroot         bool     // 该包是否位于 Go root？
    Standard       bool     // 该包是否是 Go 标准库的一部分？
    Stale          bool     // 'go install' 是否对该包有操作？
    StaleReason    string   // Stale == true 的原因
    Root           string   // 包所在的 Go root 或 Go path 目录
    ConflictDir    string   // 此目录覆盖了 $GOPATH 中的 Dir
    BinaryOnly     bool     // 仅二进制包（已不再支持）
    ForTest        string   // 仅用于指定测试的包
    Export         string   // 包含导出数据的文件（使用 -export 时）
    BuildID        string   // 编译包的 Build ID（使用 -export 时）
    Module         *Module  // 包所在模块的信息（可能为 nil）
    Match          []string // 命令行模式匹配此包
    DepOnly        bool     // 包只是依赖项，不是显式列出的
    DefaultGODEBUG string   // 主包的默认 GODEBUG 设置

    // 源文件
    GoFiles           []string   // .go 源文件（不包括 CgoFiles、TestGoFiles、XTestGoFiles）
    CgoFiles          []string   // 导入 "C" 的 .go 源文件
    CompiledGoFiles   []string   // 提供给编译器的 .go 文件（使用 -compiled 时）
    IgnoredGoFiles    []string   // 因构建约束被忽略的 .go 源文件
    IgnoredOtherFiles []string   // 因构建约束被忽略的非 .go 源文件
    CFiles            []string   // .c 源文件
    CXXFiles          []string   // .cc、.cxx 和 .cpp 源文件
    MFiles            []string   // .m 源文件
    HFiles            []string   // .h、.hh、.hpp 和 .hxx 源文件
    FFiles            []string   // .f、.F、.for 和 .f90 Fortran 源文件
    SFiles            []string   // .s 源文件
    SwigFiles         []string   // .swig 文件
    SwigCXXFiles      []string   // .swigcxx 文件
    SysoFiles         []string   // 要添加到存档的 .syso 目标文件
    TestGoFiles       []string   // 包中的 _test.go 文件
    XTestGoFiles      []string   // 包外的 _test.go 文件

    // 嵌入文件
    EmbedPatterns      []string // //go:embed 模式
    EmbedFiles         []string // 与 EmbedPatterns 匹配的文件
    TestEmbedPatterns  []string // TestGoFiles 中的 //go:embed 模式
    TestEmbedFiles     []string // 与 TestEmbedPatterns 匹配的文件
    XTestEmbedPatterns []string // XTestGoFiles 中的 //go:embed 模式
    XTestEmbedFiles    []string // 与 XTestEmbedPatterns 匹配的文件

    // Cgo 指令
    CgoCFLAGS    []string // cgo：C 编译器的标志
    CgoCPPFLAGS  []string // cgo：C 预处理器的标志
    CgoCXXFLAGS  []string // cgo：C++ 编译器的标志
    CgoFFLAGS    []string // cgo：Fortran 编译器的标志
    CgoLDFLAGS   []string // cgo：链接器的标志
    CgoPkgConfig []string // cgo：pkg-config 名称

    // 依赖信息
    Imports      []string          // 该包使用的导入路径
    ImportMap    map[string]string // 源导入到 ImportPath 的映射（省略恒等条目）
    Deps         []string          // 所有（递归）导入的依赖项
    TestImports  []string          // TestGoFiles 中的导入
    XTestImports []string          // XTestGoFiles 中的导入

    // 错误信息
    Incomplete bool            // 此包或其依赖项有错误
    Error      *PackageError   // 加载包时的错误
    DepsErrors []*PackageError // 加载依赖项时的错误
}

```

Packages stored in vendor directories report an ImportPath that includes the path to the vendor directory (for example, "d/vendor/p" instead of "p"), so that the ImportPath uniquely identifies a given copy of a package. The Imports, Deps, TestImports, and XTestImports lists also contain these expanded import paths. See golang.org/s/go15vendor for more about vendoring.

​	存储在 `vendor` 目录中的包的 `ImportPath` 会包含到 `vendor` 目录的路径（例如 `"d/vendor/p"` 而不是 `"p"`），以便 `ImportPath` 唯一标识给定包的副本。`Imports`、`Deps`、`TestImports` 和 `XTestImports` 列表也包含这些扩展的导入路径。有关 `vendor` 的更多信息，请参阅 [golang.org/s/go15vendor](https://golang.org/s/go15vendor)。

The error information, if any, is

​	错误信息（如果有）是：

```go
type PackageError struct {
    ImportStack   []string // 从命令行指定的包到此包的最短路径 shortest path from package named on command line to this one
    Pos           string   // 错误的位置（如果存在，文件:行:列） position of error (if present, file:line:col)
    Err           string   // 错误本身 the error itself
}
```

The module information is a Module struct, defined in the discussion of list -m below.

​	模块信息是一个 `Module` 结构体，定义在下面对 `list -m` 的讨论中。

The template function "join" calls strings.Join.

​	模板函数 `join` 调用 `strings.Join`。

The template function "context" returns the build context, defined as:

​	模板函数 `context` 返回构建上下文，定义如下：

```go
type Context struct {
    GOARCH        string   // 目标架构
    GOOS          string   // 目标操作系统
    GOROOT        string   // Go 根目录
    GOPATH        string   // Go 路径
    CgoEnabled    bool     // 是否可以使用 cgo
    UseAllFiles   bool     // 无论 //go:build 行或文件名如何，都使用文件
    Compiler      string   // 计算目标路径时假定的编译器
    BuildTags     []string // //go:build 行中的构建约束
    ToolTags      []string // 工具链特定的构建约束
    ReleaseTags   []string // 当前版本兼容的发布版本
    InstallSuffix string   // 安装目录名称中的后缀
}
```

For more information about the meaning of these fields see the documentation for the go/build package's Context type.

​	有关这些字段含义的更多信息，请参阅 `go/build` 包的 `Context` 类型文档。

The -json flag causes the package data to be printed in JSON format instead of using the template format. The JSON flag can optionally be provided with a set of comma-separated required field names to be output. If so, those required fields will always appear in JSON output, but others may be omitted to save work in computing the JSON struct.

​	`-json` 选项会将包数据打印为 JSON 格式，而不是使用模板格式。`JSON` 选项可以选择性地提供一组以逗号分隔的必需字段名称作为输出。如果提供了这些必需字段，它们将始终出现在 JSON 输出中，但为了节省计算 JSON 结构的工作，其他字段可能会被省略。

The -compiled flag causes list to set CompiledGoFiles to the Go source files presented to the compiler. Typically this means that it repeats the files listed in GoFiles and then also adds the Go code generated by processing CgoFiles and SwigFiles. The Imports list contains the union of all imports from both GoFiles and CompiledGoFiles.

​	`-compiled` 选项会使 `list` 将 `CompiledGoFiles` 设置为提供给编译器的 Go 源文件。通常，这意味着它会重复列出 `GoFiles`，并添加通过处理 `CgoFiles` 和 `SwigFiles` 生成的 Go 代码。`Imports` 列表包含 `GoFiles` 和 `CompiledGoFiles` 的所有导入的并集。

The -deps flag causes list to iterate over not just the named packages but also all their dependencies. It visits them in a depth-first post-order traversal, so that a package is listed only after all its dependencies. Packages not explicitly listed on the command line will have the DepOnly field set to true.

​	`-deps` 选项会使 `list` 遍历不仅是指定的包，还包括它们的所有依赖项。它会以深度优先后序遍历的方式访问这些包，以便在列出一个包之前，确保其所有依赖项都已列出。没有在命令行上明确列出的包会将 `DepOnly` 字段设置为 `true`。

The -e flag changes the handling of erroneous packages, those that cannot be found or are malformed. By default, the list command prints an error to standard error for each erroneous package and omits the packages from consideration during the usual printing. With the -e flag, the list command never prints errors to standard error and instead processes the erroneous packages with the usual printing. Erroneous packages will have a non-empty ImportPath and a non-nil Error field; other information may or may not be missing (zeroed).

​	`-e` 选项会更改对错误包的处理方式，那些无法找到或格式错误的包。默认情况下，`list` 命令会为每个错误包打印一个错误信息到标准错误，并在正常打印期间忽略该包。带 `-e` 选项时，错误包会像正确的包一样打印。

The -export flag causes list to set the Export field to the name of a file containing up-to-date export information for the given package, and the BuildID field to the build ID of the compiled package.

​	`-export` 标志会使 `list` 将 `Export` 字段设置为包含给定包的最新导出信息的文件名称，并将 `BuildID` 字段设置为已编译包的构建 ID。

The -find flag causes list to identify the named packages but not resolve their dependencies: the Imports and Deps lists will be empty. With the -find flag, the -deps, -test and -export commands cannot be used.

​	`-find` 标志会使 `list` 识别指定的包，但不解析它们的依赖项：`Imports` 和 `Deps` 列表将为空。使用 `-find` 标志时，`-deps`、`-test` 和 `-export` 命令不能使用。

The -test flag causes list to report not only the named packages but also their test binaries (for packages with tests), to convey to source code analysis tools exactly how test binaries are constructed. The reported import path for a test binary is the import path of the package followed by a ".test" suffix, as in "math/rand.test". When building a test, it is sometimes necessary to rebuild certain dependencies specially for that test (most commonly the tested package itself). The reported import path of a package recompiled for a particular test binary is followed by a space and the name of the test binary in brackets, as in "math/rand [math/rand.test](https://pkg.go.dev/math/rand.test)" or "regexp [sort.test]". The ForTest field is also set to the name of the package being tested ("math/rand" or "sort" in the previous examples).

​	`-test` 标志会使 `list` 报告不仅是指定的包，还包括它们的测试二进制文件（对于有测试的包），以便准确传达测试二进制文件是如何构建的。测试二进制文件的导入路径是包的导入路径后加上 ".test" 后缀，例如 "math/rand.test"。构建测试时，有时需要为该测试特别重新编译某些依赖项（最常见的是被测试的包本身）。为特定测试二进制文件重新编译的包的导入路径后会跟随一个空格和括号内的测试二进制文件名称，例如 "math/rand [math/rand.test]" 或 "regexp [sort.test]"。`ForTest` 字段还会设置为正在测试的包的名称（在前面的示例中是 "math/rand" 或 "sort"）。

The Dir, Target, Shlib, Root, ConflictDir, and Export file paths are all absolute paths.

​	`Dir`、`Target`、`Shlib`、`Root`、`ConflictDir` 和 `Export` 文件路径都是绝对路径。

By default, the lists GoFiles, CgoFiles, and so on hold names of files in Dir (that is, paths relative to Dir, not absolute paths). The generated files added when using the -compiled and -test flags are absolute paths referring to cached copies of generated Go source files. Although they are Go source files, the paths may not end in ".go".

​	默认情况下，`GoFiles`、`CgoFiles` 等列表保存 `Dir` 目录中的文件名（即相对于 `Dir` 的路径，而不是绝对路径）。使用 `-compiled` 和 `-test` 标志时添加的生成文件是指向生成的 Go 源文件缓存副本的绝对路径。虽然它们是 Go 源文件，但路径可能不以 ".go" 结尾。

The -m flag causes list to list modules instead of packages.

​	`-m` 标志使 `list` 列出模块而不是包。

When listing modules, the -f flag still specifies a format template applied to a Go struct, but now a Module struct:

​	列出模块时，`-f` 标志仍然指定应用于 Go 结构体的格式模板，但现在是应用于 `Module` 结构体：

```go
type Module struct {
    Path       string        // 模块路径
    Query      string        // 与该版本对应的版本查询
    Version    string        // 模块版本
    Versions   []string      // 可用的模块版本
    Replace    *Module       // 被此模块替代
    Time       *time.Time    // 版本创建的时间
    Update     *Module       // 可用的更新版本（使用 -u）
    Main       bool          // 这是主模块吗？
    Indirect   bool          // 模块仅被主模块间接需要
    Dir        string        // 保存文件本地副本的目录（如果有）
    GoMod      string        // 描述模块的 go.mod 文件路径（如果有）
    GoVersion  string        // 模块中使用的 Go 版本
    Retracted  []string      // 撤回信息（使用 -retracted 或 -u 时）
    Deprecated string        // 弃用消息（如果有，使用 -u）
    Error      *ModuleError  // 加载模块时的错误
    Sum        string        // 路径、版本的校验和（如 go.sum 中）
    GoModSum   string        // go.mod 文件的校验和（如 go.sum 中）
    Origin     any           // 模块的来源
    Reuse      bool          // 旧模块信息的重用是安全的
}

type ModuleError struct {
    Err string // 错误本身
}

```

The file GoMod refers to may be outside the module directory if the module is in the module cache or if the -modfile flag is used.

​	`GoMod` 引用的文件可能位于模块目录之外，如果模块在模块缓存中或使用了 `-modfile` 标志。

The default output is to print the module path and then information about the version and replacement if any. For example, 'go list -m all' might print:

​	默认输出是打印模块路径，然后是版本信息及替换信息（如果有）。例如，`go list -m all` 可能输出：

```
my/main/module
golang.org/x/text v0.3.0 => /tmp/text
rsc.io/pdf v0.1.1
```

The Module struct has a String method that formats this line of output, so that the default format is equivalent to -f '{{.String}}'.

​	`Module` 结构体具有 `String` 方法，该方法会格式化这一行输出，因此默认格式等同于 `-f '{{.String}}'`。

Note that when a module has been replaced, its Replace field describes the replacement module, and its Dir field is set to the replacement's source code, if present. (That is, if Replace is non-nil, then Dir is set to Replace.Dir, with no access to the replaced source code.)

​	注意，当模块被替换时，它的 `Replace` 字段描述了替代模块，并且它的 `Dir` 字段设置为替代模块的源代码目录（如果存在）。(即，如果 `Replace` 非空，则 `Dir` 设置为 `Replace.Dir`，无法访问被替换的源代码。)

The -u flag adds information about available upgrades. When the latest version of a given module is newer than the current one, list -u sets the Module's Update field to information about the newer module. list -u will also set the module's Retracted field if the current version is retracted. The Module's String method indicates an available upgrade by formatting the newer version in brackets after the current version. If a version is retracted, the string "(retracted)" will follow it. For example, 'go list -m -u all' might print:

​	`-u` 标志添加了可用更新的信息。当某个模块的最新版本比当前版本更新时，`list -u` 会将 `Module` 的 `Update` 字段设置为有关该更新模块的信息。如果当前版本已被撤回，`list -u` 还会设置模块的 `Retracted` 字段。`Module` 的 `String` 方法通过在当前版本后面格式化较新的版本来指示可用的升级。如果版本被撤回，则字符串后面会显示 "(retracted)"。例如，`go list -m -u all` 可能输出：

```
my/main/module
golang.org/x/text v0.3.0 [v0.4.0] => /tmp/text
rsc.io/pdf v0.1.1 (retracted) [v0.1.2]
```

(For tools, 'go list -m -u -json all' may be more convenient to parse.)

​	（对于工具来说，`go list -m -u -json all` 可能更方便解析。）

The -versions flag causes list to set the Module's Versions field to a list of all known versions of that module, ordered according to semantic versioning, earliest to latest. The flag also changes the default output format to display the module path followed by the space-separated version list.

​	`-versions` 标志使 `list` 将模块的 `Versions` 字段设置为该模块所有已知版本的列表，按照语义版本顺序，从早到晚。该标志还会更改默认输出格式，显示模块路径，后跟以空格分隔的版本列表。

The -retracted flag causes list to report information about retracted module versions. When -retracted is used with -f or -json, the Retracted field will be set to a string explaining why the version was retracted. The string is taken from comments on the retract directive in the module's go.mod file. When -retracted is used with -versions, retracted versions are listed together with unretracted versions. The -retracted flag may be used with or without -m.

​	`-retracted` 标志使 `list` 报告已撤回的模块版本信息。当 `-retracted` 与 `-f` 或 `-json` 一起使用时，`Retracted` 字段将被设置为解释版本为何被撤回的字符串。该字符串取自模块 `go.mod` 文件中 `retract` 指令的注释。当 `-retracted` 与 `-versions` 一起使用时，已撤回的版本与未撤回的版本一起列出。`-retracted` 标志可以与 `-m` 一起或单独使用。

The arguments to list -m are interpreted as a list of modules, not packages. The main module is the module containing the current directory. The active modules are the main module and its dependencies. With no arguments, list -m shows the main module. With arguments, list -m shows the modules specified by the arguments. Any of the active modules can be specified by its module path. The special pattern "all" specifies all the active modules, first the main module and then dependencies sorted by module path. A pattern containing "..." specifies the active modules whose module paths match the pattern. A query of the form path@version specifies the result of that query, which is not limited to active modules. See 'go help modules' for more about module queries.

​	`list -m` 的参数被解释为模块列表，而不是包。主模块是包含当前目录的模块。活动模块是主模块及其依赖项。没有参数时，`list -m` 显示主模块。带参数时，`list -m` 显示由参数指定的模块。活动模块中的任何模块都可以通过其模块路径指定。特殊模式 "all" 指定所有活动模块，首先是主模块，然后是按模块路径排序的依赖项。包含 "..." 的模式指定模块路径与该模式匹配的活动模块。`path@version` 形式的查询指定该查询的结果，这不局限于活动模块。有关模块查询的更多信息，请参见 `go help modules`。

The template function "module" takes a single string argument that must be a module path or query and returns the specified module as a Module struct. If an error occurs, the result will be a Module struct with a non-nil Error field.

​	模板函数 `module` 接受一个字符串参数，该参数必须是模块路径或查询，并返回指定的模块作为 `Module` 结构体。如果发生错误，结果将是 `Error` 字段非空的 `Module` 结构体。

When using -m, the -reuse=old.json flag accepts the name of file containing the JSON output of a previous 'go list -m -json' invocation with the same set of modifier flags (such as -u, -retracted, and -versions). The go command may use this file to determine that a module is unchanged since the previous invocation and avoid redownloading information about it. Modules that are not redownloaded will be marked in the new output by setting the Reuse field to true. Normally the module cache provides this kind of reuse automatically; the -reuse flag can be useful on systems that do not preserve the module cache.

​	使用 `-m` 时，`-reuse=old.json` 标志接受一个文件名，该文件包含先前通过相同修改标志集（如 `-u`、`-retracted` 和 `-versions`）调用 `go list -m -json` 的输出。`go` 命令可能使用此文件来确定自上次调用以来模块是否未更改，并避免重新下载相关信息。未重新下载的模块将在新输出中标记为 `Reuse` 字段设置为 `true`。通常，模块缓存会自动提供这种重用；`-reuse` 标志在不保留模块缓存的系统上可能有用。

For more about build flags, see 'go help build'.

​	有关构建标志的更多信息，请参见 `go help build`。

For more about specifying packages, see 'go help packages'.

​	有关指定包的更多信息，请参见 `go help packages`。

For more about modules, see https://golang.org/ref/mod.

​	有关模块的更多信息，请访问 https://golang.org/ref/mod。

#### 模块维护 Module maintenance 

Go mod provides access to operations on modules.

​	`go mod` 提供对模块操作的访问。

Note that support for modules is built into all the go commands, not just 'go mod'. For example, day-to-day adding, removing, upgrading, and downgrading of dependencies should be done using 'go get'. See 'go help modules' for an overview of module functionality.

​	请注意，对模块的支持已内置于所有 `go` 命令中，而不仅仅是 `go mod`。例如，日常添加、移除、升级和降级依赖项应该使用 `go get`。有关模块功能概述，请参见 `go help modules`。

Usage:

```
go mod <command> [arguments]
```

The commands are:

​	命令包括：

```
download    下载模块到本地缓存 download modules to local cache
edit        从工具或脚本编辑 go.mod edit go.mod from tools or scripts
graph       打印模块依赖关系图 print module requirement graph
init        在当前目录初始化新模块 initialize new module in current directory
tidy        添加缺失的模块并删除未使用的模块 add missing and remove unused modules
vendor      创建依赖项的 vendor 副本 make vendored copy of dependencies
verify      验证依赖项内容是否符合预期 verify dependencies have expected content
why         解释为什么需要包或模块 explain why packages or modules are needed
```

Use "go help mod <command>" for more information about a command.

​	使用 `go help mod <command>` 获取有关某个命令的更多信息。

#### 下载模块到本地缓存 Download modules to local cache 

Usage:

```
go mod download [-x] [-json] [-reuse=old.json] [modules]
```

Download downloads the named modules, which can be module patterns selecting dependencies of the main module or module queries of the form path@version.

​	`download` 命令下载指定的模块，模块可以是选择主模块依赖的模块模式，或是类似 `path@version` 形式的模块查询。

With no arguments, download applies to the modules needed to build and test the packages in the main module: the modules explicitly required by the main module if it is at 'go 1.17' or higher, or all transitively-required modules if at 'go 1.16' or lower.

​	不带参数时，`download` 应用于构建和测试主模块中的包所需的模块：如果 Go 版本为 1.17 或更高，则只下载主模块显式要求的模块；如果 Go 版本为 1.16 或更低，则下载所有传递依赖的模块。

The go command will automatically download modules as needed during ordinary execution. The "go mod download" command is useful mainly for pre-filling the local cache or to compute the answers for a Go module proxy.

​	在普通执行过程中，Go 命令会自动下载所需模块。`go mod download` 命令主要用于预填充本地缓存，或为 Go 模块代理计算答案。

By default, download writes nothing to standard output. It may print progress messages and errors to standard error.

​	默认情况下，`download` 不会向标准输出写入任何内容。它可能会向标准错误输出进度消息和错误信息。

The -json flag causes download to print a sequence of JSON objects to standard output, describing each downloaded module (or failure), corresponding to this Go struct:

​	`-json` 标志使 `download` 打印一系列 JSON 对象到标准输出，每个对象描述一个下载的模块（或失败），对应以下 Go 结构体：

```go
type Module struct {
    Path     string // 模块路径
    Query    string // 版本查询，对应此版本
    Version  string // 模块版本
    Error    string // 加载模块时发生的错误
    Info     string // 缓存的 .info 文件的绝对路径
    GoMod    string // 缓存的 .mod 文件的绝对路径
    Zip      string // 缓存的 .zip 文件的绝对路径
    Dir      string // 缓存的源码根目录的绝对路径
    Sum      string // 路径和版本的校验和（如 go.sum 中）
    GoModSum string // go.mod 文件的校验和（如 go.sum 中）
    Origin   any    // 模块的来源
    Reuse    bool   // 旧模块信息的重用是安全的
}

```

The -reuse flag accepts the name of file containing the JSON output of a previous 'go mod download -json' invocation. The go command may use this file to determine that a module is unchanged since the previous invocation and avoid redownloading it. Modules that are not redownloaded will be marked in the new output by setting the Reuse field to true. Normally the module cache provides this kind of reuse automatically; the -reuse flag can be useful on systems that do not preserve the module cache.

​	`-reuse` 标志接受一个文件名，该文件包含上一次执行 `go mod download -json` 命令的 JSON 输出。Go 命令可能会使用此文件来判断某个模块自上次调用以来是否未发生变化，从而避免重新下载它。未重新下载的模块将在新的输出中通过设置 `Reuse` 字段为 `true` 来标记。通常，模块缓存会自动提供这种重用功能；`-reuse` 标志在不保留模块缓存的系统上可能有用。

The -x flag causes download to print the commands download executes.

​	`-x` 标志使 `download` 打印它执行的命令。

See https://golang.org/ref/mod#go-mod-download for more about 'go mod download'.

​	有关 `go mod download` 的更多信息，请参阅 https://golang.org/ref/mod#go-mod-download。

See https://golang.org/ref/mod#version-queries for more about version queries.

​	有关版本查询的更多信息，请参阅 https://golang.org/ref/mod#version-queries。

#### 从工具或脚本编辑 go.mod 文件 Edit go.mod from tools or scripts 

Usage:

```
go mod edit [editing flags] [-fmt|-print|-json] [go.mod]
```

Edit provides a command-line interface for editing go.mod, for use primarily by tools or scripts. It reads only go.mod; it does not look up information about the modules involved. By default, edit reads and writes the go.mod file of the main module, but a different target file can be specified after the editing flags.

​	`edit` 提供了一个用于编辑 `go.mod` 的命令行接口，主要供工具或脚本使用。它仅读取 `go.mod` 文件；不会查找涉及模块的其他信息。默认情况下，`edit` 读取并写入主模块的 `go.mod` 文件，但可以在编辑标志后指定其他目标文件。

The editing flags specify a sequence of editing operations.

​	编辑标志指定了一系列编辑操作。

The -fmt flag reformats the go.mod file without making other changes. This reformatting is also implied by any other modifications that use or rewrite the go.mod file. The only time this flag is needed is if no other flags are specified, as in 'go mod edit -fmt'.

​	`-fmt` 标志重新格式化 `go.mod` 文件，而不进行其他更改。任何使用或重写 `go.mod` 文件的修改都会隐含此格式化操作。只有在未指定其他标志时，才需要此标志，如 `go mod edit -fmt`。

The -module flag changes the module's path (the go.mod file's module line).

​	`-module` 标志更改模块路径（即 `go.mod` 文件中的模块行）。

The -godebug=key=value flag adds a godebug key=value line, replacing any existing godebug lines with the given key.

​	`-godebug=key=value` 标志添加一行 `godebug key=value`，并替换掉具有相同 `key` 的任何现有 `godebug` 行。

The -dropgodebug=key flag drops any existing godebug lines with the given key.

​	`-dropgodebug=key` 标志删除任何具有给定 `key` 的现有 `godebug` 行。

The -require=path@version and -droprequire=path flags add and drop a requirement on the given module path and version. Note that -require overrides any existing requirements on path. These flags are mainly for tools that understand the module graph. Users should prefer 'go get path@version' or 'go get path@none', which make other go.mod adjustments as needed to satisfy constraints imposed by other modules.

​	`-require=path@version` 和 `-droprequire=path` 标志添加和删除对给定模块路径和版本的要求。请注意，`-require` 会覆盖对 `path` 的任何现有要求。这些标志主要供理解模块图的工具使用。用户应该优先使用 `go get path@version` 或 `go get path@none`，它们会根据其他模块施加的约束做出必要的 `go.mod` 调整。

The -go=version flag sets the expected Go language version. This flag is mainly for tools that understand Go version dependencies. Users should prefer 'go get go@version'.

​	`-go=version` 标志设置预期的 Go 语言版本。该标志主要供理解 Go 版本依赖关系的工具使用。用户应该优先使用 `go get go@version`。

The -toolchain=version flag sets the Go toolchain to use. This flag is mainly for tools that understand Go version dependencies. Users should prefer 'go get toolchain@version'.

​	`-toolchain=version` 标志设置要使用的 Go 工具链版本。该标志主要供理解 Go 版本依赖关系的工具使用。用户应该优先使用 `go get toolchain@version`。

The -exclude=path@version and -dropexclude=path@version flags add and drop an exclusion for the given module path and version. Note that -exclude=path@version is a no-op if that exclusion already exists.

​	`-exclude=path@version` 和 `-dropexclude=path@version` 标志添加和删除对给定模块路径和版本的排除。请注意，如果排除已经存在，`-exclude=path@version` 是一个无操作命令。

The -replace=old[@v]=new[@v] flag adds a replacement of the given module path and version pair. If the @v in old@v is omitted, a replacement without a version on the left side is added, which applies to all versions of the old module path. If the @v in new@v is omitted, the new path should be a local module root directory, not a module path. Note that -replace overrides any redundant replacements for old[@v], so omitting @v will drop existing replacements for specific versions.

​	`-replace=old[@v]=new[@v]` 标志添加对给定模块路径和版本对的替换。如果 `old@v` 中的 `@v` 省略，则会添加没有版本的替换，这将适用于 `old` 模块路径的所有版本。如果 `new@v` 中的 `@v` 省略，则新路径应为本地模块根目录，而不是模块路径。请注意，`-replace` 会覆盖对 `old[@v]` 的任何冗余替换，因此省略 `@v` 将删除现有的特定版本替换。

The -dropreplace=old[@v] flag drops a replacement of the given module path and version pair. If the @v is omitted, a replacement without a version on the left side is dropped.

​	`-dropreplace=old[@v]` 标志删除对给定模块路径和版本对的替换。如果省略 `@v`，则会删除没有版本的替换。

The -retract=version and -dropretract=version flags add and drop a retraction on the given version. The version may be a single version like "v1.2.3" or a closed interval like "[v1.1.0,v1.1.9]". Note that -retract=version is a no-op if that retraction already exists.

​	`-retract=version` 和 `-dropretract=version` 标志添加和删除对给定版本的撤回。版本可以是类似 "v1.2.3" 的单个版本，也可以是类似 "[v1.1.0,v1.1.9]" 的闭合区间。请注意，如果撤回已存在，则 `-retract=version` 是一个无操作命令。

The -godebug, -dropgodebug, -require, -droprequire, -exclude, -dropexclude, -replace, -dropreplace, -retract, and -dropretract editing flags may be repeated, and the changes are applied in the order given.

​	`-godebug`、`-dropgodebug`、`-require`、`-droprequire`、`-exclude`、`-dropexclude`、`-replace`、`-dropreplace`、`-retract` 和 `-dropretract` 编辑标志可以重复使用，并按给定顺序应用更改。

The -print flag prints the final go.mod in its text format instead of writing it back to go.mod.

​	`-print` 标志以文本格式打印最终的 `go.mod` 文件，而不是将其写回 `go.mod`。

The -json flag prints the final go.mod file in JSON format instead of writing it back to go.mod. The JSON output corresponds to these Go types:

​	`-json` 标志以 JSON 格式打印最终的 `go.mod` 文件，而不是将其写回 `go.mod`。JSON 输出对应以下 Go 类型：

```go
type Module struct {
	Path    string
	Version string
}

type GoMod struct {
	Module    ModPath
	Go        string
	Toolchain string
	Godebug   []Godebug
	Require   []Require
	Exclude   []Module
	Replace   []Replace
	Retract   []Retract
}

type ModPath struct {
	Path       string
	Deprecated string
}

type Godebug struct {
	Key   string
	Value string
}

type Require struct {
	Path     string
	Version  string
	Indirect bool
}

type Replace struct {
	Old Module
	New Module
}

type Retract struct {
	Low       string
	High      string
	Rationale string
}
```

Retract entries representing a single version (not an interval) will have the "Low" and "High" fields set to the same value.

​	代表单个版本（非区间）的 `Retract` 条目将使 `Low` 和 `High` 字段设置为相同的值。

Note that this only describes the go.mod file itself, not other modules referred to indirectly. For the full set of modules available to a build, use 'go list -m -json all'.

​	请注意，这只描述了 `go.mod` 文件本身，而不是其他间接引用的模块。要查看构建可用的完整模块集，请使用 `go list -m -json all`。

Edit also provides the -C, -n, and -x build flags.

​	`edit` 还提供了 `-C`、`-n` 和 `-x` 构建标志。

See https://golang.org/ref/mod#go-mod-edit for more about 'go mod edit'.

​	有关 `go mod edit` 的更多信息，请参阅 https://golang.org/ref/mod#go-mod-edit。

#### 打印模块依赖关系图 Print module requirement graph 

Usage:

```
go mod graph [-go=version] [-x]
```

Graph prints the module requirement graph (with replacements applied) in text form. Each line in the output has two space-separated fields: a module and one of its requirements. Each module is identified as a string of the form path@version, except for the main module, which has no @version suffix.

​	`graph` 以文本形式打印模块依赖关系图（应用替换后）。输出中的每一行包含两个用空格分隔的字段：一个模块及其依赖项。每个模块都以 `path@version` 形式标识，除了主模块，它没有 `@version` 后缀。

The -go flag causes graph to report the module graph as loaded by the given Go version, instead of the version indicated by the 'go' directive in the go.mod file.

​	`-go` 标志让 `graph` 报告由指定 Go 版本加载的模块图，而不是由 go.mod 文件中的 `go` 指令指定的版本。

The -x flag causes graph to print the commands graph executes.

​	`-x` 标志让 `graph` 打印其执行的命令。

See https://golang.org/ref/mod#go-mod-graph for more about 'go mod graph'.

​	更多关于 `go mod graph` 的信息，请参见 [go mod graph](https://golang.org/ref/mod#go-mod-graph)。

#### 在当前目录下初始化新模块 Initialize new module in current directory 

Usage:

```
go mod init [module-path]
```

Init initializes and writes a new go.mod file in the current directory, in effect creating a new module rooted at the current directory. The go.mod file must not already exist.

​	`init` 会在当前目录下初始化并写入一个新的 go.mod 文件，从而在当前目录下创建一个新的模块。当前目录中不应已经存在 go.mod 文件。

Init accepts one optional argument, the module path for the new module. If the module path argument is omitted, init will attempt to infer the module path using import comments in .go files, vendoring tool configuration files (like Gopkg.lock), and the current directory (if in GOPATH).

​	`init` 接受一个可选参数，即新模块的模块路径。如果未提供模块路径参数，`init` 将尝试使用 .go 文件中的导入注释、供应商工具配置文件（如 Gopkg.lock）和当前目录（如果位于 GOPATH 中）来推断模块路径。

See https://golang.org/ref/mod#go-mod-init for more about 'go mod init'.

​	更多关于 `go mod init` 的信息，请参见 [go mod init](https://golang.org/ref/mod#go-mod-init)。

#### 添加缺失模块并移除未使用模块 Add missing and remove unused modules 

Usage:

```
go mod tidy [-e] [-v] [-x] [-diff] [-go=version] [-compat=version]
```

Tidy makes sure go.mod matches the source code in the module. It adds any missing modules necessary to build the current module's packages and dependencies, and it removes unused modules that don't provide any relevant packages. It also adds any missing entries to go.sum and removes any unnecessary ones.

​	`tidy` 确保 go.mod 与模块中的源代码匹配。它会添加构建当前模块的包和依赖所需的任何缺失模块，并移除不提供任何相关包的未使用模块。同时，它还会向 go.sum 添加任何缺失的条目并移除任何不必要的条目。

The -v flag causes tidy to print information about removed modules to standard error.

​	`-v` 标志让 `tidy` 打印有关移除模块的信息到标准错误输出。

The -e flag causes tidy to attempt to proceed despite errors encountered while loading packages.

​	`-e` 标志让 `tidy` 尽管在加载包时遇到错误也尝试继续。

The -diff flag causes tidy not to modify go.mod or go.sum but instead print the necessary changes as a unified diff. It exits with a non-zero code if the diff is not empty.

​	`-diff` 标志让 `tidy` 不修改 go.mod 或 go.sum，而是以统一 diff 格式打印所需的更改。如果 diff 结果不为空，则以非零代码退出。

The -go flag causes tidy to update the 'go' directive in the go.mod file to the given version, which may change which module dependencies are retained as explicit requirements in the go.mod file. (Go versions 1.17 and higher retain more requirements in order to support lazy module loading.)

​	`-go` 标志让 `tidy` 更新 go.mod 文件中的 `go` 指令为指定版本，这可能会改变保留在 go.mod 文件中的模块依赖项（Go 1.17 及更高版本保留更多的依赖以支持懒加载模块）。

The -compat flag preserves any additional checksums needed for the 'go' command from the indicated major Go release to successfully load the module graph, and causes tidy to error out if that version of the 'go' command would load any imported package from a different module version. By default, tidy acts as if the -compat flag were set to the version prior to the one indicated by the 'go' directive in the go.mod file.

​	`-compat` 标志保留 `go` 命令从指定 Go 主版本加载模块图所需的额外校验和，如果该版本的 `go` 命令从不同模块版本加载任何导入包，`tidy` 将报错。默认情况下，`tidy` 的行为类似于将 `-compat` 标志设置为 go.mod 文件中 `go` 指令指定版本的前一个版本。

The -x flag causes tidy to print the commands download executes.

​	`-x` 标志让 `tidy` 打印下载执行的命令。

See https://golang.org/ref/mod#go-mod-tidy for more about 'go mod tidy'.

​	更多关于 `go mod tidy` 的信息，请参见 [go mod tidy](https://golang.org/ref/mod#go-mod-tidy)。

#### 创建依赖项的vendor副本 Make vendored copy of dependencies 

Usage:

```
go mod vendor [-e] [-v] [-o outdir]
```

Vendor resets the main module's vendor directory to include all packages needed to build and test all the main module's packages. It does not include test code for vendored packages.

​	`vendor` 重置主模块的 `vendor` 目录，以包含构建和测试主模块包所需的所有包。它不会包含被供应商化包的测试代码。

The -v flag causes vendor to print the names of vendored modules and packages to standard error.

​	`-v` 标志让 `vendor` 打印供应商化模块和包的名称到标准错误输出。

The -e flag causes vendor to attempt to proceed despite errors encountered while loading packages.

​	`-e` 标志让 `vendor` 尽管在加载包时遇到错误也尝试继续。

The -o flag causes vendor to create the vendor directory at the given path instead of "vendor". The go command can only use a vendor directory named "vendor" within the module root directory, so this flag is primarily useful for other tools.

​	`-o` 标志让 `vendor` 在指定路径下创建 `vendor` 目录，而不是在 "vendor" 目录。`go` 命令只能使用模块根目录中的 "vendor" 目录，因此此标志主要适用于其他工具。

See https://golang.org/ref/mod#go-mod-vendor for more about 'go mod vendor'.

​	更多关于 `go mod vendor` 的信息，请参见 [go mod vendor](https://golang.org/ref/mod#go-mod-vendor)。

#### 验证依赖项内容是否符合预期 Verify dependencies have expected content 

Usage:

```
go mod verify
```

Verify checks that the dependencies of the current module, which are stored in a local downloaded source cache, have not been modified since being downloaded. If all the modules are unmodified, verify prints "all modules verified." Otherwise it reports which modules have been changed and causes 'go mod' to exit with a non-zero status.

​	`verify` 检查当前模块的依赖项是否在本地下载的源缓存中未被修改。如果所有模块均未被修改，`verify` 会打印 "all modules verified"。否则，它会报告哪些模块发生了更改，并导致 `go mod` 以非零状态退出。

See https://golang.org/ref/mod#go-mod-verify for more about 'go mod verify'.

​	更多关于 `go mod verify` 的信息，请参见 [go mod verify](https://golang.org/ref/mod#go-mod-verify)。

#### 解释为什么需要某些包或模块 Explain why packages or modules are needed 

Usage:

```
go mod why [-m] [-vendor] packages...
```

Why shows a shortest path in the import graph from the main module to each of the listed packages. If the -m flag is given, why treats the arguments as a list of modules and finds a path to any package in each of the modules.

​	`why` 显示从主模块到列出的包的导入图中的最短路径。如果使用 `-m` 标志，`why` 将把参数视为模块列表，并找到通向每个模块中任意包的路径。

By default, why queries the graph of packages matched by "go list all", which includes tests for reachable packages. The -vendor flag causes why to exclude tests of dependencies.

​	默认情况下，`why` 查询的是通过 `go list all` 匹配的包的图，其中包括可达包的测试。`-vendor` 标志让 `why` 排除依赖项的测试。

The output is a sequence of stanzas, one for each package or module name on the command line, separated by blank lines. Each stanza begins with a comment line "# package" or "# module" giving the target package or module. Subsequent lines give a path through the import graph, one package per line. If the package or module is not referenced from the main module, the stanza will display a single parenthesized note indicating that fact.

​	输出是一个序列，每个命令行上的包或模块名都有一段内容，段与段之间用空行分隔。每段内容以 `# package` 或 `# module` 注释行开头，标识目标包或模块。后续行显示导入图中的路径，每行一个包。如果包或模块未被主模块引用，该段将显示一个括号内的说明来指示这一点。

For example:

​	例如：

```
$ go mod why golang.org/x/text/language golang.org/x/text/encoding
# golang.org/x/text/language
rsc.io/quote
rsc.io/sampler
golang.org/x/text/language

# golang.org/x/text/encoding
(main module does not need package golang.org/x/text/encoding)
$
```

See https://golang.org/ref/mod#go-mod-why for more about 'go mod why'.

​	更多关于 `go mod why` 的信息，请参见 [go mod why](https://golang.org/ref/mod#go-mod-why)。

#### 工作区维护 Workspace maintenance 

Work provides access to operations on workspaces.

​	`work` 提供对工作区的操作访问。

Note that support for workspaces is built into many other commands, not just 'go work'.

​	请注意，许多其他命令内置了对工作区的支持，而不仅仅是 `go work`。

See 'go help modules' for information about Go's module system of which workspaces are a part.

​	关于 Go 模块系统及其工作区部分的信息，请参见 `go help modules`。

See https://go.dev/ref/mod#workspaces for an in-depth reference on workspaces.

​	有关工作区的详细参考，请参见 [workspaces](https://go.dev/ref/mod#workspaces)。

See https://go.dev/doc/tutorial/workspaces for an introductory tutorial on workspaces.

​	有关工作区的入门教程，请参见 [tutorial/workspaces](https://go.dev/doc/tutorial/workspaces)。

A workspace is specified by a go.work file that specifies a set of module directories with the "use" directive. These modules are used as root modules by the go command for builds and related operations. A workspace that does not specify modules to be used cannot be used to do builds from local modules.

​	工作区由 `go.work` 文件指定，其中指定了一组包含 `use` 指令的模块目录。这些模块被 `go` 命令用作构建和相关操作的根模块。不指定使用模块的工作区不能用于从本地模块进行构建。

go.work files are line-oriented. Each line holds a single directive, made up of a keyword followed by arguments. For example:

​	`go.work` 文件是行导向的。每一行包含一个指令，由一个关键字后跟参数组成。例如：

```
go 1.18

use ../foo/bar
use ./baz

replace example.com/foo v1.2.3 => example.com/bar v1.4.5
```

The leading keyword can be factored out of adjacent lines to create a block, like in Go imports.

​	前导关键字可以从相邻行中提取出来以创建一个块，如同 Go 导入一样。

```
use (
  ../foo/bar
  ./baz
)
```

The use directive specifies a module to be included in the workspace's set of main modules. The argument to the use directive is the directory containing the module's go.mod file.

​	`use` 指令指定要包含在工作区主模块集中的模块。`use` 指令的参数是包含模块的 `go.mod` 文件的目录。

The go directive specifies the version of Go the file was written at. It is possible there may be future changes in the semantics of workspaces that could be controlled by this version, but for now the version specified has no effect.

​	`go` 指令指定编写该文件时的 Go 版本。未来可能会有工作区语义的更改，这些更改可能由该版本控制，但目前指定的版本没有影响。

The replace directive has the same syntax as the replace directive in a go.mod file and takes precedence over replaces in go.mod files. It is primarily intended to override conflicting replaces in different workspace modules.

​	`replace` 指令的语法与 go.mod 文件中的 `replace` 指令相同，并且优先于 go.mod 文件中的 `replace` 指令。它主要用于覆盖不同工作区模块中的冲突替换。

To determine whether the go command is operating in workspace mode, use the "go env GOWORK" command. This will specify the workspace file being used.

​	要确定 `go` 命令是否在工作区模式下运行，请使用 `go env GOWORK` 命令。该命令将指定正在使用的工作区文件。

Usage:

```
go work <command> [arguments]
```

The commands are:

​	命令包括：

```
edit        编辑 go.work 文件，供工具或脚本使用 edit go.work from tools or scripts
init        初始化工作区文件 initialize workspace file
sync        将工作区构建列表与模块同步 sync workspace build list to modules
use         将模块添加到工作区文件 add modules to workspace file
vendor      创建依赖项的供应商副本 make vendored copy of dependencies
```

Use "go help work <command>" for more information about a command.

​	使用 `go help work <command>` 获取有关命令的更多信息。

#### 编辑 go.work 文件（用于工具或脚本） Edit go.work from tools or scripts 

Usage:

```
go work edit [editing flags] [go.work]
```

Edit provides a command-line interface for editing go.work, for use primarily by tools or scripts. It only reads go.work; it does not look up information about the modules involved. If no file is specified, Edit looks for a go.work file in the current directory and its parent directories

​	`edit` 提供了一个命令行界面，用于编辑 `go.work` 文件，主要供工具或脚本使用。它只会读取 `go.work` 文件，不会查找相关模块的信息。如果未指定文件，`edit` 将在当前目录及其父目录中查找 `go.work` 文件。

The editing flags specify a sequence of editing operations.

​	编辑标志指定了一系列编辑操作。

The -fmt flag reformats the go.work file without making other changes. This reformatting is also implied by any other modifications that use or rewrite the go.mod file. The only time this flag is needed is if no other flags are specified, as in 'go work edit -fmt'.

​	`-fmt` 标志重新格式化 `go.work` 文件而不做其他更改。任何使用或重写 `go.mod` 文件的修改也会隐含此格式化操作。只有当未指定其他标志时，才需要使用此标志，例如在 `go work edit -fmt` 中。

The -godebug=key=value flag adds a godebug key=value line, replacing any existing godebug lines with the given key.

​	`-godebug=key=value` 标志添加 `godebug` 键值行，替换任何具有相同键的现有 `godebug` 行。

The -dropgodebug=key flag drops any existing godebug lines with the given key.

​	`-dropgodebug=key` 标志删除具有指定键的现有 `godebug` 行。

The -use=path and -dropuse=path flags add and drop a use directive from the go.work file's set of module directories.

​	`-use=path` 和 `-dropuse=path` 标志分别向 `go.work` 文件中的模块目录集添加和删除 `use` 指令。

The -replace=old[@v]=new[@v] flag adds a replacement of the given module path and version pair. If the @v in old@v is omitted, a replacement without a version on the left side is added, which applies to all versions of the old module path. If the @v in new@v is omitted, the new path should be a local module root directory, not a module path. Note that -replace overrides any redundant replacements for old[@v], so omitting @v will drop existing replacements for specific versions.

​	`-replace=old[@v]=new[@v]` 标志为指定的模块路径和版本对添加替换。如果省略了 `old@v` 中的 `@v`，则会添加一个没有左侧版本的替换，它适用于所有版本的旧模块路径。如果省略了 `new@v` 中的 `@v`，则新路径应该是本地模块根目录，而不是模块路径。注意，`-replace` 会覆盖 `old[@v]` 的任何冗余替换，因此省略 `@v` 将删除针对特定版本的现有替换。

The -dropreplace=old[@v] flag drops a replacement of the given module path and version pair. If the @v is omitted, a replacement without a version on the left side is dropped.

​	`-dropreplace=old[@v]` 标志删除指定模块路径和版本对的替换。如果省略了 `@v`，则删除没有左侧版本的替换。

The -use, -dropuse, -replace, and -dropreplace, editing flags may be repeated, and the changes are applied in the order given.

​	`-use`、`-dropuse`、`-replace` 和 `-dropreplace` 编辑标志可以重复使用，并按照指定的顺序应用更改。

The -go=version flag sets the expected Go language version.

​	`-go=version` 标志设置预期的 Go 语言版本。

The -toolchain=name flag sets the Go toolchain to use.

​	`-toolchain=name` 标志设置要使用的 Go 工具链。

The -print flag prints the final go.work in its text format instead of writing it back to go.mod.

​	`-print` 标志以文本格式打印最终的 `go.work` 文件，而不是将其写回 `go.mod`。

The -json flag prints the final go.work file in JSON format instead of writing it back to go.mod. The JSON output corresponds to these Go types:

​	`-json` 标志以 JSON 格式打印最终的 `go.work` 文件，而不是将其写回 `go.mod`。JSON 输出对应于以下 Go 类型：

```
type GoWork struct {
	Go        string
	Toolchain string
	Godebug   []Godebug
	Use       []Use
	Replace   []Replace
}

type Godebug struct {
	Key   string
	Value string
}

type Use struct {
	DiskPath   string
	ModulePath string
}

type Replace struct {
	Old Module
	New Module
}

type Module struct {
	Path    string
	Version string
}
```

See the workspaces reference at https://go.dev/ref/mod#workspaces for more information.

​	更多信息请参见 [工作区参考文档](https://go.dev/ref/mod#workspaces)。

#### 初始化工作区文件 Initialize workspace file 

Usage:

```
go work init [moddirs]
```

Init initializes and writes a new go.work file in the current directory, in effect creating a new workspace at the current directory.

​	`init` 在当前目录下初始化并写入一个新的 `go.work` 文件，实际上是在当前目录下创建一个新的工作区。

go work init optionally accepts paths to the workspace modules as arguments. If the argument is omitted, an empty workspace with no modules will be created.

​	`go work init` 可以选择性地接受工作区模块的路径作为参数。如果省略参数，则会创建一个没有模块的空工作区。

Each argument path is added to a use directive in the go.work file. The current go version will also be listed in the go.work file.

​	每个参数路径都会被添加到 `go.work` 文件中的 `use` 指令中。当前的 Go 版本也将被列入 `go.work` 文件中。

See the workspaces reference at https://go.dev/ref/mod#workspaces for more information.

​	更多信息请参见 [工作区参考文档](https://go.dev/ref/mod#workspaces)。

#### 将工作区构建列表同步到模块 Sync workspace build list to modules 

Usage:

```
go work sync
```

Sync syncs the workspace's build list back to the workspace's modules

​	`sync` 将工作区的构建列表同步回工作区的模块。

The workspace's build list is the set of versions of all the (transitive) dependency modules used to do builds in the workspace. go work sync generates that build list using the Minimal Version Selection algorithm, and then syncs those versions back to each of modules specified in the workspace (with use directives).

​	工作区的构建列表是用于在工作区中进行构建的所有（传递）依赖模块的版本集合。`go work sync` 使用最小版本选择算法生成该构建列表，然后将这些版本同步回工作区中指定的每个模块（使用 `use` 指令）。

The syncing is done by sequentially upgrading each of the dependency modules specified in a workspace module to the version in the build list if the dependency module's version is not already the same as the build list's version. Note that Minimal Version Selection guarantees that the build list's version of each module is always the same or higher than that in each workspace module.

​	同步通过按顺序升级工作区模块中指定的每个依赖模块到构建列表中的版本来完成，如果依赖模块的版本已经与构建列表中的版本相同，则不会升级。请注意，最小版本选择算法保证构建列表中每个模块的版本始终与每个工作区模块中的版本相同或更高。

See the workspaces reference at https://go.dev/ref/mod#workspaces for more information.

​	更多信息请参见 [工作区参考文档](https://go.dev/ref/mod#workspaces)。

#### 向工作区文件添加模块 Add modules to workspace file 

Usage:

```
go work use [-r] [moddirs]
```

Use provides a command-line interface for adding directories, optionally recursively, to a go.work file.

​	`use` 提供了一个命令行界面，用于向 `go.work` 文件中添加目录（可以选择递归添加）。

A use directive will be added to the go.work file for each argument directory listed on the command line go.work file, if it exists, or removed from the go.work file if it does not exist. Use fails if any remaining use directives refer to modules that do not exist.

​	如果命令行列出的参数目录存在，`use` 指令将被添加到 `go.work` 文件中；如果目录不存在，`use` 指令将从 `go.work` 文件中删除。如果剩余的 `use` 指令中引用的模块不存在，`use` 将失败。

Use updates the go line in go.work to specify a version at least as new as all the go lines in the used modules, both preexisting ones and newly added ones. With no arguments, this update is the only thing that go work use does.

​	`use` 更新 `go.work` 文件中的 `go` 行，以指定至少与所使用的模块（包括现有模块和新添加模块）的所有 `go` 行一样新的版本。如果没有参数，则这是 `go work use` 所做的唯一操作。

The -r flag searches recursively for modules in the argument directories, and the use command operates as if each of the directories were specified as arguments.

​	`-r` 标志递归搜索参数目录中的模块，`use` 命令将像指定参数目录一样操作。

See the workspaces reference at https://go.dev/ref/mod#workspaces for more information.

​	更多信息请参见 [工作区参考文档](https://go.dev/ref/mod#workspaces)。

#### 创建依赖项的供应商副本 Make vendored copy of dependencies 

Usage:

```
go work vendor [-e] [-v] [-o outdir]
```

Vendor resets the workspace's vendor directory to include all packages needed to build and test all the workspace's packages. It does not include test code for vendored packages.

​	`vendor` 重置工作区的 `vendor` 目录，以包含构建和测试工作区中的所有包所需的包。它不包含被供应商化包的测试代码。

The -v flag causes vendor to print the names of vendored modules and packages to standard error.

​	`-v` 标志使 `vendor` 将供应商化模块和包的名称打印到标准错误输出。

The -e flag causes vendor to attempt to proceed despite errors encountered while loading packages.

​	`-e` 标志使 `vendor` 尽管在加载包时遇到错误也尝试继续。

The -o flag causes vendor to create the vendor directory at the given path instead of "vendor". The go command can only use a vendor directory named "vendor" within the module root directory, so this flag is primarily useful for other tools.

​	`-o` 标志使 `vendor` 在给定路径下创建 `vendor` 目录，而不是在默认的 `vendor` 目录中。`go` 命令只能使用模块根目录中的 `vendor` 目录，因此此标志主要用于其他工具。

#### 编译并运行 Go 程序 Compile and run Go program 

Usage:

```
go run [build flags] [-exec xprog] package [arguments...]
```

Run compiles and runs the named main Go package. Typically the package is specified as a list of .go source files from a single directory, but it may also be an import path, file system path, or pattern matching a single known package, as in 'go run .' or 'go run my/cmd'.

​	`run` 编译并运行指定的主 Go 包。通常，该包由单个目录中的 `.go` 源文件列表指定，但它也可以是导入路径、文件系统路径或匹配已知单个包的模式，例如 `go run .` 或 `go run my/cmd`。

If the package argument has a version suffix (like @latest or @v1.0.0), "go run" builds the program in module-aware mode, ignoring the go.mod file in the current directory or any parent directory, if there is one. This is useful for running programs without affecting the dependencies of the main module.

​	如果包参数有版本后缀（如 `@latest` 或 `@v1.0.0`），`go run` 将在模块感知模式下构建程序，忽略当前目录或任何父目录中的 `go.mod` 文件（如果存在）。这对于运行程序而不影响主模块的依赖项非常有用。

If the package argument doesn't have a version suffix, "go run" may run in module-aware mode or GOPATH mode, depending on the GO111MODULE environment variable and the presence of a go.mod file. See 'go help modules' for details. If module-aware mode is enabled, "go run" runs in the context of the main module.

​	如果包参数没有版本后缀，`go run` 可能会在模块感知模式或 GOPATH 模式下运行，这取决于 `GO111MODULE` 环境变量的值以及 `go.mod` 文件的存在情况。有关详细信息，请参见 `go help modules`。如果启用了模块感知模式，`go run` 会在主模块的上下文中运行。

By default, 'go run' runs the compiled binary directly: 'a.out arguments...'. If the -exec flag is given, 'go run' invokes the binary using xprog:

​	默认情况下，`go run` 直接运行编译后的二进制文件：`a.out arguments...`。如果给出了 `-exec` 标志，`go run` 将使用 `xprog` 调用二进制文件：

```
'xprog a.out arguments...'.
```

If the -exec flag is not given, GOOS or GOARCH is different from the system default, and a program named go_$GOOS_$GOARCH_exec can be found on the current search path, 'go run' invokes the binary using that program, for example 'go_js_wasm_exec a.out arguments...'. This allows execution of cross-compiled programs when a simulator or other execution method is available.

​	如果未给出 `-exec` 标志，`GOOS` 或 `GOARCH` 与系统默认值不同，并且在当前搜索路径中可以找到名为 `go_$GOOS_$GOARCH_exec` 的程序，则 `go run` 将使用该程序调用二进制文件，例如 `go_js_wasm_exec a.out arguments...`。这允许在模拟器或其他执行方法可用时执行交叉编译的程序。

By default, 'go run' compiles the binary without generating the information used by debuggers, to reduce build time. To include debugger information in the binary, use 'go build'.

​	默认情况下，`go run` 编译二进制文件时不会生成调试器使用的信息，以减少构建时间。要在二进制文件中包含调试器信息，请使用 `go build`。

The exit status of Run is not the exit status of the compiled binary.

​	`Run` 的退出状态不是编译二进制文件的退出状态。

For more about build flags, see 'go help build'. For more about specifying packages, see 'go help packages'.

​	有关构建标志的更多信息，请参见 `go help build`。有关指定包的更多信息，请参见 `go help packages`。

See also: go build.

​	另请参见：`go build`。

#### 管理遥测数据和设置 Manage telemetry data and settings 

Usage:

```
go telemetry [off|local|on]
```

Telemetry is used to manage Go telemetry data and settings.

​	遥测用于管理 Go 的遥测数据和设置。

Telemetry can be in one of three modes: off, local, or on.

​	遥测可以处于三种模式之一：关闭、本地或开启。

When telemetry is in local mode, counter data is written to the local file system, but will not be uploaded to remote servers.

​	当遥测处于本地模式时，计数器数据将写入本地文件系统，但不会上传到远程服务器。

When telemetry is off, local counter data is neither collected nor uploaded.

​	当遥测关闭时，本地计数器数据既不会被收集也不会被上传。

When telemetry is on, telemetry data is written to the local file system and periodically sent to https://telemetry.go.dev/. Uploaded data is used to help improve the Go toolchain and related tools, and it will be published as part of a public dataset.

​	当遥测开启时，遥测数据会写入本地文件系统，并定期发送到 https://telemetry.go.dev/。上传的数据用于帮助改进 Go 工具链及相关工具，并将作为公共数据集的一部分发布。

For more details, see https://telemetry.go.dev/privacy. This data is collected in accordance with the Google Privacy Policy (https://policies.google.com/privacy).

​	有关详细信息，请参见 https://telemetry.go.dev/privacy。这些数据的收集符合 Google 隐私政策（https://policies.google.com/privacy）。

To view the current telemetry mode, run "go telemetry". To disable telemetry uploading, but keep local data collection, run "go telemetry local". To enable both collection and uploading, run “go telemetry on”. To disable both collection and uploading, run "go telemetry off".

​	要查看当前的遥测模式，请运行 `go telemetry`。要禁用遥测上传，但保留本地数据收集，请运行 `go telemetry local`。要启用数据收集和上传，请运行 `go telemetry on`。要禁用数据收集和上传，请运行 `go telemetry off`。

See https://go.dev/doc/telemetry for more information on telemetry.

​	有关遥测的更多信息，请参见 https://go.dev/doc/telemetry。

#### 测试包 Test packages 

Usage:

```
go test [build/test flags] [packages] [build/test flags & test binary flags]
```

'Go test' automates testing the packages named by the import paths. It prints a summary of the test results in the format:

​	`go test` 自动测试由导入路径指定的包。它以如下格式打印测试结果摘要：

```
ok   archive/tar   0.011s
FAIL archive/zip   0.022s
ok   compress/gzip 0.033s
...
```

followed by detailed output for each failed package.

​	随后是每个失败包的详细输出。

'Go test' recompiles each package along with any files with names matching the file pattern `"*_test.go"`. These additional files can contain test functions, benchmark functions, fuzz tests and example functions. See 'go help testfunc' for more. Each listed package causes the execution of a separate test binary. Files whose names begin with "`_`" (including `"_test.go"`) or "." are ignored.

​	`go test` 重新编译每个包以及名称匹配 `*_test.go` 文件的任何文件。这些附加文件可以包含测试函数、基准测试函数、模糊测试和示例函数。有关更多信息，请参见 `go help testfunc`。每个列出的包都会导致执行单独的测试二进制文件。名称以 "`_`"（包括 `"_test.go"`）或 "." 开头的文件将被忽略。

Test files that declare a package with the suffix "_test" will be compiled as a separate package, and then linked and run with the main test binary.

​	声明包后缀为 `_test` 的测试文件将被编译为一个单独的包，然后与主测试二进制文件链接并运行。

The go tool will ignore a directory named "testdata", making it available to hold ancillary data needed by the tests.

​	Go 工具将忽略名为 "testdata" 的目录，使其可用于保存测试所需的辅助数据。

As part of building a test binary, go test runs go vet on the package and its test source files to identify significant problems. If go vet finds any problems, go test reports those and does not run the test binary. Only a high-confidence subset of the default go vet checks are used. That subset is: atomic, bool, buildtags, directive, errorsas, ifaceassert, nilfunc, printf, and stringintconv. You can see the documentation for these and other vet tests via "go doc cmd/vet". To disable the running of go vet, use the -vet=off flag. To run all checks, use the -vet=all flag.

​	作为构建测试二进制文件的一部分，`go test` 在包及其测试源文件上运行 `go vet`，以识别重大问题。如果 `go vet` 发现任何问题，`go test` 会报告这些问题，并且不会运行测试二进制文件。只会使用默认 `go vet` 检查的高置信度子集。该子集包括：`atomic`、`bool`、`buildtags`、`directive`、`errorsas`、`ifaceassert`、`nilfunc`、`printf` 和 `stringintconv`。您可以通过 `go doc cmd/vet` 查看这些和其他 vet 检查的文档。要禁用 `go vet` 的运行，请使用 `-vet=off` 标志。要运行所有检查，请使用 `-vet=all` 标志。

All test output and summary lines are printed to the go command's standard output, even if the test printed them to its own standard error. (The go command's standard error is reserved for printing errors building the tests.)

​	所有测试输出和摘要行都打印到 `go` 命令的标准输出，即使测试将其打印到自己的标准错误。（`go` 命令的标准错误保留用于打印构建测试时的错误。）

The go command places `$GOROOT/bin` at the beginning of $PATH in the test's environment, so that tests that execute 'go' commands use the same 'go' as the parent 'go test' command.

​	`go` 命令将 `$GOROOT/bin` 放在测试环境的 `$PATH` 开头，以便执行 `go` 命令的测试使用与父 `go test` 命令相同的 `go`。

Go test runs in two different modes:

​	`go test` 以两种不同的模式运行：

The first, called local directory mode, occurs when go test is invoked with no package arguments (for example, 'go test' or 'go test -v'). In this mode, go test compiles the package sources and tests found in the current directory and then runs the resulting test binary. In this mode, caching (discussed below) is disabled. After the package test finishes, go test prints a summary line showing the test status ('ok' or 'FAIL'), package name, and elapsed time.

​	第一种称为本地目录模式，当 `go test` 在没有包参数的情况下调用时（例如，`go test` 或 `go test -v`）。在这种模式下，`go test` 编译当前目录中找到的包源代码和测试，然后运行生成的测试二进制文件。在这种模式下，缓存（下文讨论）被禁用。包测试完成后，`go test` 会打印一行摘要，显示测试状态（`ok` 或 `FAIL`）、包名称和经过时间。

The second, called package list mode, occurs when go test is invoked with explicit package arguments (for example 'go test math', 'go test ./...', and even 'go test .'). In this mode, go test compiles and tests each of the packages listed on the command line. If a package test passes, go test prints only the final 'ok' summary line. If a package test fails, go test prints the full test output. If invoked with the -bench or -v flag, go test prints the full output even for passing package tests, in order to display the requested benchmark results or verbose logging. After the package tests for all of the listed packages finish, and their output is printed, go test prints a final 'FAIL' status if any package test has failed.

​	第二种称为包列表模式，当 `go test` 被显式包参数调用时（例如，`go test math`、`go test ./...` 甚至 `go test .`）。在这种模式下，`go test` 编译并测试命令行中列出的每个包。如果包测试通过，`go test` 仅打印最终的 `ok` 摘要行。如果包测试失败，`go test` 会打印完整的测试输出。如果使用 `-bench` 或 `-v` 标志调用，`go test` 将打印完整的输出，即使是通过的包测试，以显示请求的基准测试结果或详细日志记录。所有列出包的包测试完成并打印其输出后，如果任何包测试失败，`go test` 会打印最终的 `FAIL` 状态。

In package list mode only, go test caches successful package test results to avoid unnecessary repeated running of tests. When the result of a test can be recovered from the cache, go test will redisplay the previous output instead of running the test binary again. When this happens, go test prints '(cached)' in place of the elapsed time in the summary line.

​	仅在包列表模式下，`go test` 会缓存成功的包测试结果，以避免不必要的重复运行测试。当测试结果可以从缓存中恢复时，`go test` 将重新显示以前的输出，而不是再次运行测试二进制文件。当发生这种情况时，`go test` 会在摘要行中以 `(cached)` 替代经过时间。

The rule for a match in the cache is that the run involves the same test binary and the flags on the command line come entirely from a restricted set of 'cacheable' test flags, defined as -benchtime, -cpu, -list, -parallel, -run, -short, -timeout, -failfast, -fullpath and -v. If a run of go test has any test or non-test flags outside this set, the result is not cached. To disable test caching, use any test flag or argument other than the cacheable flags. The idiomatic way to disable test caching explicitly is to use -count=1. Tests that open files within the package's source root (usually $GOPATH) or that consult environment variables only match future runs in which the files and environment variables are unchanged. A cached test result is treated as executing in no time at all, so a successful package test result will be cached and reused regardless of -timeout setting.

​	缓存匹配的规则是运行涉及相同的测试二进制文件，并且命令行上的标志完全来自一组受限的“可缓存”测试标志，定义为 `-benchtime`、`-cpu`、`-list`、`-parallel`、`-run`、`-short`、`-timeout`、`-failfast`、`-fullpath` 和 `-v`。如果 `go test` 的运行具有任何超出此集合的测试或非测试标志，则结果不会被缓存。要禁用测试缓存，请使用任何测试标志或缓存以外的参数。显式禁用测试缓存的惯用方法是使用 `-count=1`。在包的源根目录（通常是 `$GOPATH`）中打开文件的测试或仅在文件和环境变量不变的情况下与未来的运行匹配。缓存的测试结果被视为在零时间内执行，因此成功的包测试结果将被缓存并重新使用，而不管 `-timeout` 设置如何。

In addition to the build flags, the flags handled by 'go test' itself are:

​	除了构建标志外，`go test` 自身处理的标志包括：

```
-args
    Pass the remainder of the command line (everything after -args)
    to the test binary, uninterpreted and unchanged.
    Because this flag consumes the remainder of the command line,
    the package list (if present) must appear before this flag.
    将命令行的剩余部分（-args 之后的所有内容）
    传递给测试二进制文件，不进行解释和更改。
    由于此标志消耗命令行的剩余部分，
    包列表（如果存在）必须出现在此标志之前。

-c
    Compile the test binary to pkg.test in the current directory but do not run it
    (where pkg is the last element of the package's import path).
    The file name or target directory can be changed with the -o flag.
    将测试二进制文件编译为当前目录中的 `pkg.test`，
    但不运行它（其中 `pkg` 是包导入路径的最后一部分）。
    可以使用 `-o` 标志更改文件名或目标目录。

-exec xprog
    Run the test binary using xprog. The behavior is the same as
    in 'go run'. See 'go help run' for details.
    使用 `xprog` 运行测试二进制文件。行为与
    `go run` 中的行为相同。有关详细信息，请参见 `go help run`。

-json
    Convert test output to JSON suitable for automated processing.
    See 'go doc test2json' for the encoding details.
    将测试输出转换为适合自动处理的 JSON 格式。
    有关编码的详细信息，请参见 `go doc test2json`。

-o file
    Compile the test binary to the named file.
    The test still runs (unless -c or -i is specified).
    If file ends in a slash or names an existing directory,
    the test is written to pkg.test in that directory.
    将测试二进制文件编译为指定文件。
    测试仍然运行（除非指定了 `-c` 或 `-i`）。
    如果 `file` 以斜杠结尾或指定现有目录的名称，
    测试将写入该目录中的 `pkg.test`。
```

The test binary also accepts flags that control execution of the test; these flags are also accessible by 'go test'. See 'go help testflag' for details.

​	测试二进制文件还接受控制测试执行的标志；这些标志也可以通过 `go test` 访问。有关详细信息，请参见 `go help testflag`。

For more about build flags, see 'go help build'. For more about specifying packages, see 'go help packages'.

​	有关构建标志的更多信息，请参见 `go help build`。有关指定包的更多信息，请参见 `go help packages`。

See also: go build, go vet.

​	另请参见：`go build`，`go vet`。

#### Run specified go tool 

Usage:

```
go tool [-n] command [args...]
```

Tool runs the go tool command identified by the arguments. With no arguments it prints the list of known tools.

The -n flag causes tool to print the command that would be executed but not execute it.

For more about each tool command, see 'go doc cmd/<command>'.

#### Print Go version 

Usage:

```
go version [-m] [-v] [file ...]
```

Version prints the build information for Go binary files.

Go version reports the Go version used to build each of the named files.

If no files are named on the command line, go version prints its own version information.

If a directory is named, go version walks that directory, recursively, looking for recognized Go binaries and reporting their versions. By default, go version does not report unrecognized files found during a directory scan. The -v flag causes it to report unrecognized files.

The -m flag causes go version to print each file's embedded module version information, when available. In the output, the module information consists of multiple lines following the version line, each indented by a leading tab character.

See also: go doc runtime/debug.BuildInfo.

#### Report likely mistakes in packages 

Usage:

```
go vet [build flags] [-vettool prog] [vet flags] [packages]
```

Vet runs the Go vet command on the packages named by the import paths.

For more about vet and its flags, see 'go doc cmd/vet'. For more about specifying packages, see 'go help packages'. For a list of checkers and their flags, see 'go tool vet help'. For details of a specific checker such as 'printf', see 'go tool vet help printf'.

The -vettool=prog flag selects a different analysis tool with alternative or additional checks. For example, the 'shadow' analyzer can be built and run using these commands:

```
go install golang.org/x/tools/go/analysis/passes/shadow/cmd/shadow@latest
go vet -vettool=$(which shadow)
```

The build flags supported by go vet are those that control package resolution and execution, such as -C, -n, -x, -v, -tags, and -toolexec. For more about these flags, see 'go help build'.

See also: go fmt, go fix.

#### Build constraints 

A build constraint, also known as a build tag, is a condition under which a file should be included in the package. Build constraints are given by a line comment that begins

```
//go:build
```

Build constraints can also be used to downgrade the language version used to compile a file.

Constraints may appear in any kind of source file (not just Go), but they must appear near the top of the file, preceded only by blank lines and other comments. These rules mean that in Go files a build constraint must appear before the package clause.

To distinguish build constraints from package documentation, a build constraint should be followed by a blank line.

A build constraint comment is evaluated as an expression containing build tags combined by ||, &&, and ! operators and parentheses. Operators have the same meaning as in Go.

For example, the following build constraint constrains a file to build when the "linux" and "386" constraints are satisfied, or when "darwin" is satisfied and "cgo" is not:

```
//go:build (linux && 386) || (darwin && !cgo)
```

It is an error for a file to have more than one //go:build line.

During a particular build, the following build tags are satisfied:

- the target operating system, as spelled by runtime.GOOS, set with the GOOS environment variable.
- the target architecture, as spelled by runtime.GOARCH, set with the GOARCH environment variable.
- any architecture features, in the form GOARCH.feature (for example, "amd64.v2"), as detailed below.
- "unix", if GOOS is a Unix or Unix-like system.
- the compiler being used, either "gc" or "gccgo"
- "cgo", if the cgo command is supported (see CGO_ENABLED in 'go help environment').
- a term for each Go major release, through the current version: "go1.1" from Go version 1.1 onward, "go1.12" from Go 1.12, and so on.
- any additional tags given by the -tags flag (see 'go help build').

There are no separate build tags for beta or minor releases.

If a file's name, after stripping the extension and a possible _test suffix, matches any of the following patterns:

```
*_GOOS
*_GOARCH
*_GOOS_GOARCH
```

(example: source_windows_amd64.go) where GOOS and GOARCH represent any known operating system and architecture values respectively, then the file is considered to have an implicit build constraint requiring those terms (in addition to any explicit constraints in the file).

Using GOOS=android matches build tags and files as for GOOS=linux in addition to android tags and files.

Using GOOS=illumos matches build tags and files as for GOOS=solaris in addition to illumos tags and files.

Using GOOS=ios matches build tags and files as for GOOS=darwin in addition to ios tags and files.

The defined architecture feature build tags are:

- For GOARCH=386, GO386=387 and GO386=sse2 set the 386.387 and 386.sse2 build tags, respectively.
- For GOARCH=amd64, GOAMD64=v1, v2, and v3 correspond to the amd64.v1, amd64.v2, and amd64.v3 feature build tags.
- For GOARCH=arm, GOARM=5, 6, and 7 correspond to the arm.5, arm.6, and arm.7 feature build tags.
- For GOARCH=arm64, GOARM64=v8.{0-9} and v9.{0-5} correspond to the arm64.v8.{0-9} and arm64.v9.{0-5} feature build tags.
- For GOARCH=mips or mipsle, GOMIPS=hardfloat and softfloat correspond to the mips.hardfloat and mips.softfloat (or mipsle.hardfloat and mipsle.softfloat) feature build tags.
- For GOARCH=mips64 or mips64le, GOMIPS64=hardfloat and softfloat correspond to the mips64.hardfloat and mips64.softfloat (or mips64le.hardfloat and mips64le.softfloat) feature build tags.
- For GOARCH=ppc64 or ppc64le, GOPPC64=power8, power9, and power10 correspond to the ppc64.power8, ppc64.power9, and ppc64.power10 (or ppc64le.power8, ppc64le.power9, and ppc64le.power10) feature build tags.
- For GOARCH=riscv64, GORISCV64=rva20u64 and rva22u64 correspond to the riscv64.rva20u64 and riscv64.rva22u64 build tags.
- For GOARCH=wasm, GOWASM=satconv and signext correspond to the wasm.satconv and wasm.signext feature build tags.

For GOARCH=amd64, arm, ppc64, ppc64le, and riscv64, a particular feature level sets the feature build tags for all previous levels as well. For example, GOAMD64=v2 sets the amd64.v1 and amd64.v2 feature flags. This ensures that code making use of v2 features continues to compile when, say, GOAMD64=v4 is introduced. Code handling the absence of a particular feature level should use a negation:

```
//go:build !amd64.v2
```

To keep a file from being considered for any build:

```
//go:build ignore
```

(Any other unsatisfied word will work as well, but "ignore" is conventional.)

To build a file only when using cgo, and only on Linux and OS X:

```
//go:build cgo && (linux || darwin)
```

Such a file is usually paired with another file implementing the default functionality for other systems, which in this case would carry the constraint:

```
//go:build !(cgo && (linux || darwin))
```

Naming a file dns_windows.go will cause it to be included only when building the package for Windows; similarly, math_386.s will be included only when building the package for 32-bit x86.

Go versions 1.16 and earlier used a different syntax for build constraints, with a "// +build" prefix. The gofmt command will add an equivalent //go:build constraint when encountering the older syntax.

In modules with a Go version of 1.21 or later, if a file's build constraint has a term for a Go major release, the language version used when compiling the file will be the minimum version implied by the build constraint.

#### Build modes 

The 'go build' and 'go install' commands take a -buildmode argument which indicates which kind of object file is to be built. Currently supported values are:

```
-buildmode=archive
	Build the listed non-main packages into .a files. Packages named
	main are ignored.

-buildmode=c-archive
	Build the listed main package, plus all packages it imports,
	into a C archive file. The only callable symbols will be those
	functions exported using a cgo //export comment. Requires
	exactly one main package to be listed.

-buildmode=c-shared
	Build the listed main package, plus all packages it imports,
	into a C shared library. The only callable symbols will
	be those functions exported using a cgo //export comment.
	Requires exactly one main package to be listed.

-buildmode=default
	Listed main packages are built into executables and listed
	non-main packages are built into .a files (the default
	behavior).

-buildmode=shared
	Combine all the listed non-main packages into a single shared
	library that will be used when building with the -linkshared
	option. Packages named main are ignored.

-buildmode=exe
	Build the listed main packages and everything they import into
	executables. Packages not named main are ignored.

-buildmode=pie
	Build the listed main packages and everything they import into
	position independent executables (PIE). Packages not named
	main are ignored.

-buildmode=plugin
	Build the listed main packages, plus all packages that they
	import, into a Go plugin. Packages not named main are ignored.
```

On AIX, when linking a C program that uses a Go archive built with -buildmode=c-archive, you must pass -Wl,-bnoobjreorder to the C compiler.

#### Calling between Go and C 

There are two different ways to call between Go and C/C++ code.

The first is the cgo tool, which is part of the Go distribution. For information on how to use it see the cgo documentation (go doc cmd/cgo).

The second is the SWIG program, which is a general tool for interfacing between languages. For information on SWIG see http://swig.org/. When running go build, any file with a .swig extension will be passed to SWIG. Any file with a .swigcxx extension will be passed to SWIG with the -c++ option.

When either cgo or SWIG is used, go build will pass any .c, .m, .s, .S or .sx files to the C compiler, and any .cc, .cpp, .cxx files to the C++ compiler. The CC or CXX environment variables may be set to determine the C or C++ compiler, respectively, to use.

#### Build and test caching 

The go command caches build outputs for reuse in future builds. The default location for cache data is a subdirectory named go-build in the standard user cache directory for the current operating system. Setting the GOCACHE environment variable overrides this default, and running 'go env GOCACHE' prints the current cache directory.

The go command periodically deletes cached data that has not been used recently. Running 'go clean -cache' deletes all cached data.

The build cache correctly accounts for changes to Go source files, compilers, compiler options, and so on: cleaning the cache explicitly should not be necessary in typical use. However, the build cache does not detect changes to C libraries imported with cgo. If you have made changes to the C libraries on your system, you will need to clean the cache explicitly or else use the -a build flag (see 'go help build') to force rebuilding of packages that depend on the updated C libraries.

The go command also caches successful package test results. See 'go help test' for details. Running 'go clean -testcache' removes all cached test results (but not cached build results).

The go command also caches values used in fuzzing with 'go test -fuzz', specifically, values that expanded code coverage when passed to a fuzz function. These values are not used for regular building and testing, but they're stored in a subdirectory of the build cache. Running 'go clean -fuzzcache' removes all cached fuzzing values. This may make fuzzing less effective, temporarily.

The GODEBUG environment variable can enable printing of debugging information about the state of the cache:

GODEBUG=gocacheverify=1 causes the go command to bypass the use of any cache entries and instead rebuild everything and check that the results match existing cache entries.

GODEBUG=gocachehash=1 causes the go command to print the inputs for all of the content hashes it uses to construct cache lookup keys. The output is voluminous but can be useful for debugging the cache.

GODEBUG=gocachetest=1 causes the go command to print details of its decisions about whether to reuse a cached test result.

#### Environment variables 

The go command and the tools it invokes consult environment variables for configuration. If an environment variable is unset or empty, the go command uses a sensible default setting. To see the effective setting of the variable <NAME>, run 'go env <NAME>'. To change the default setting, run 'go env -w <NAME>=<VALUE>'. Defaults changed using 'go env -w' are recorded in a Go environment configuration file stored in the per-user configuration directory, as reported by os.UserConfigDir. The location of the configuration file can be changed by setting the environment variable GOENV, and 'go env GOENV' prints the effective location, but 'go env -w' cannot change the default location. See 'go help env' for details.

General-purpose environment variables:

```
GO111MODULE
	Controls whether the go command runs in module-aware mode or GOPATH mode.
	May be "off", "on", or "auto".
	See https://golang.org/ref/mod#mod-commands.
GCCGO
	The gccgo command to run for 'go build -compiler=gccgo'.
GOARCH
	The architecture, or processor, for which to compile code.
	Examples are amd64, 386, arm, ppc64.
GOBIN
	The directory where 'go install' will install a command.
GOCACHE
	The directory where the go command will store cached
	information for reuse in future builds.
GOMODCACHE
	The directory where the go command will store downloaded modules.
GODEBUG
	Enable various debugging facilities. See https://go.dev/doc/godebug
	for details.
GOENV
	The location of the Go environment configuration file.
	Cannot be set using 'go env -w'.
	Setting GOENV=off in the environment disables the use of the
	default configuration file.
GOFLAGS
	A space-separated list of -flag=value settings to apply
	to go commands by default, when the given flag is known by
	the current command. Each entry must be a standalone flag.
	Because the entries are space-separated, flag values must
	not contain spaces. Flags listed on the command line
	are applied after this list and therefore override it.
GOINSECURE
	Comma-separated list of glob patterns (in the syntax of Go's path.Match)
	of module path prefixes that should always be fetched in an insecure
	manner. Only applies to dependencies that are being fetched directly.
	GOINSECURE does not disable checksum database validation. GOPRIVATE or
	GONOSUMDB may be used to achieve that.
GOOS
	The operating system for which to compile code.
	Examples are linux, darwin, windows, netbsd.
GOPATH
	Controls where various files are stored. See: 'go help gopath'.
GOPROXY
	URL of Go module proxy. See https://golang.org/ref/mod#environment-variables
	and https://golang.org/ref/mod#module-proxy for details.
GOPRIVATE, GONOPROXY, GONOSUMDB
	Comma-separated list of glob patterns (in the syntax of Go's path.Match)
	of module path prefixes that should always be fetched directly
	or that should not be compared against the checksum database.
	See https://golang.org/ref/mod#private-modules.
GOROOT
	The root of the go tree.
GOSUMDB
	The name of checksum database to use and optionally its public key and
	URL. See https://golang.org/ref/mod#authenticating.
GOTOOLCHAIN
	Controls which Go toolchain is used. See https://go.dev/doc/toolchain.
GOTMPDIR
	The directory where the go command will write
	temporary source files, packages, and binaries.
GOVCS
	Lists version control commands that may be used with matching servers.
	See 'go help vcs'.
GOWORK
	In module aware mode, use the given go.work file as a workspace file.
	By default or when GOWORK is "auto", the go command searches for a
	file named go.work in the current directory and then containing directories
	until one is found. If a valid go.work file is found, the modules
	specified will collectively be used as the main modules. If GOWORK
	is "off", or a go.work file is not found in "auto" mode, workspace
	mode is disabled.
```

Environment variables for use with cgo:

```
AR
	The command to use to manipulate library archives when
	building with the gccgo compiler.
	The default is 'ar'.
CC
	The command to use to compile C code.
CGO_ENABLED
	Whether the cgo command is supported. Either 0 or 1.
CGO_CFLAGS
	Flags that cgo will pass to the compiler when compiling
	C code.
CGO_CFLAGS_ALLOW
	A regular expression specifying additional flags to allow
	to appear in #cgo CFLAGS source code directives.
	Does not apply to the CGO_CFLAGS environment variable.
CGO_CFLAGS_DISALLOW
	A regular expression specifying flags that must be disallowed
	from appearing in #cgo CFLAGS source code directives.
	Does not apply to the CGO_CFLAGS environment variable.
CGO_CPPFLAGS, CGO_CPPFLAGS_ALLOW, CGO_CPPFLAGS_DISALLOW
	Like CGO_CFLAGS, CGO_CFLAGS_ALLOW, and CGO_CFLAGS_DISALLOW,
	but for the C preprocessor.
CGO_CXXFLAGS, CGO_CXXFLAGS_ALLOW, CGO_CXXFLAGS_DISALLOW
	Like CGO_CFLAGS, CGO_CFLAGS_ALLOW, and CGO_CFLAGS_DISALLOW,
	but for the C++ compiler.
CGO_FFLAGS, CGO_FFLAGS_ALLOW, CGO_FFLAGS_DISALLOW
	Like CGO_CFLAGS, CGO_CFLAGS_ALLOW, and CGO_CFLAGS_DISALLOW,
	but for the Fortran compiler.
CGO_LDFLAGS, CGO_LDFLAGS_ALLOW, CGO_LDFLAGS_DISALLOW
	Like CGO_CFLAGS, CGO_CFLAGS_ALLOW, and CGO_CFLAGS_DISALLOW,
	but for the linker.
CXX
	The command to use to compile C++ code.
FC
	The command to use to compile Fortran code.
PKG_CONFIG
	Path to pkg-config tool.
```

Architecture-specific environment variables:

```
GOARM
	For GOARCH=arm, the ARM architecture for which to compile.
	Valid values are 5, 6, 7.
	The value can be followed by an option specifying how to implement floating point instructions.
	Valid options are ,softfloat (default for 5) and ,hardfloat (default for 6 and 7).
GOARM64
	For GOARCH=arm64, the ARM64 architecture for which to compile.
	Valid values are v8.0 (default), v8.{1-9}, v9.{0-5}.
	The value can be followed by an option specifying extensions implemented by target hardware.
	Valid options are ,lse and ,crypto.
	Note that some extensions are enabled by default starting from a certain GOARM64 version;
	for example, lse is enabled by default starting from v8.1.
GO386
	For GOARCH=386, how to implement floating point instructions.
	Valid values are sse2 (default), softfloat.
GOAMD64
	For GOARCH=amd64, the microarchitecture level for which to compile.
	Valid values are v1 (default), v2, v3, v4.
	See https://golang.org/wiki/MinimumRequirements#amd64
GOMIPS
	For GOARCH=mips{,le}, whether to use floating point instructions.
	Valid values are hardfloat (default), softfloat.
GOMIPS64
	For GOARCH=mips64{,le}, whether to use floating point instructions.
	Valid values are hardfloat (default), softfloat.
GOPPC64
	For GOARCH=ppc64{,le}, the target ISA (Instruction Set Architecture).
	Valid values are power8 (default), power9, power10.
GORISCV64
	For GOARCH=riscv64, the RISC-V user-mode application profile for which
	to compile. Valid values are rva20u64 (default), rva22u64.
	See https://github.com/riscv/riscv-profiles/blob/main/src/profiles.adoc
GOWASM
	For GOARCH=wasm, comma-separated list of experimental WebAssembly features to use.
	Valid values are satconv, signext.
```

Environment variables for use with code coverage:

```
GOCOVERDIR
	Directory into which to write code coverage data files
	generated by running a "go build -cover" binary.
	Requires that GOEXPERIMENT=coverageredesign is enabled.
```

Special-purpose environment variables:

```
GCCGOTOOLDIR
	If set, where to find gccgo tools, such as cgo.
	The default is based on how gccgo was configured.
GOEXPERIMENT
	Comma-separated list of toolchain experiments to enable or disable.
	The list of available experiments may change arbitrarily over time.
	See src/internal/goexperiment/flags.go for currently valid values.
	Warning: This variable is provided for the development and testing
	of the Go toolchain itself. Use beyond that purpose is unsupported.
GO_EXTLINK_ENABLED
	Whether the linker should use external linking mode
	when using -linkmode=auto with code that uses cgo.
	Set to 0 to disable external linking mode, 1 to enable it.
GIT_ALLOW_PROTOCOL
	Defined by Git. A colon-separated list of schemes that are allowed
	to be used with git fetch/clone. If set, any scheme not explicitly
	mentioned will be considered insecure by 'go get'.
	Because the variable is defined by Git, the default value cannot
	be set using 'go env -w'.
```

Additional information available from 'go env' but not read from the environment:

```
GOEXE
	The executable file name suffix (".exe" on Windows, "" on other systems).
GOGCCFLAGS
	A space-separated list of arguments supplied to the CC command.
GOHOSTARCH
	The architecture (GOARCH) of the Go toolchain binaries.
GOHOSTOS
	The operating system (GOOS) of the Go toolchain binaries.
GOMOD
	The absolute path to the go.mod of the main module.
	If module-aware mode is enabled, but there is no go.mod, GOMOD will be
	os.DevNull ("/dev/null" on Unix-like systems, "NUL" on Windows).
	If module-aware mode is disabled, GOMOD will be the empty string.
GOTOOLDIR
	The directory where the go tools (compile, cover, doc, etc...) are installed.
GOVERSION
	The version of the installed Go tree, as reported by runtime.Version.
```

#### File types 

The go command examines the contents of a restricted set of files in each directory. It identifies which files to examine based on the extension of the file name. These extensions are:

```
.go
	Go source files.
.c, .h
	C source files.
	If the package uses cgo or SWIG, these will be compiled with the
	OS-native compiler (typically gcc); otherwise they will
	trigger an error.
.cc, .cpp, .cxx, .hh, .hpp, .hxx
	C++ source files. Only useful with cgo or SWIG, and always
	compiled with the OS-native compiler.
.m
	Objective-C source files. Only useful with cgo, and always
	compiled with the OS-native compiler.
.s, .S, .sx
	Assembler source files.
	If the package uses cgo or SWIG, these will be assembled with the
	OS-native assembler (typically gcc (sic)); otherwise they
	will be assembled with the Go assembler.
.swig, .swigcxx
	SWIG definition files.
.syso
	System object files.
```

Files of each of these types except .syso may contain build constraints, but the go command stops scanning for build constraints at the first item in the file that is not a blank line or //-style line comment. See the go/build package documentation for more details.

#### The go.mod file 

A module version is defined by a tree of source files, with a go.mod file in its root. When the go command is run, it looks in the current directory and then successive parent directories to find the go.mod marking the root of the main (current) module.

The go.mod file format is described in detail at https://golang.org/ref/mod#go-mod-file.

To create a new go.mod file, use 'go mod init'. For details see 'go help mod init' or https://golang.org/ref/mod#go-mod-init.

To add missing module requirements or remove unneeded requirements, use 'go mod tidy'. For details, see 'go help mod tidy' or https://golang.org/ref/mod#go-mod-tidy.

To add, upgrade, downgrade, or remove a specific module requirement, use 'go get'. For details, see 'go help module-get' or https://golang.org/ref/mod#go-get.

To make other changes or to parse go.mod as JSON for use by other tools, use 'go mod edit'. See 'go help mod edit' or https://golang.org/ref/mod#go-mod-edit.

#### GOPATH environment variable 

The Go path is used to resolve import statements. It is implemented by and documented in the go/build package.

The GOPATH environment variable lists places to look for Go code. On Unix, the value is a colon-separated string. On Windows, the value is a semicolon-separated string. On Plan 9, the value is a list.

If the environment variable is unset, GOPATH defaults to a subdirectory named "go" in the user's home directory ($HOME/go on Unix, %USERPROFILE%\go on Windows), unless that directory holds a Go distribution. Run "go env GOPATH" to see the current GOPATH.

See https://golang.org/wiki/SettingGOPATH to set a custom GOPATH.

Each directory listed in GOPATH must have a prescribed structure:

The src directory holds source code. The path below src determines the import path or executable name.

The pkg directory holds installed package objects. As in the Go tree, each target operating system and architecture pair has its own subdirectory of pkg (pkg/GOOS_GOARCH).

If DIR is a directory listed in the GOPATH, a package with source in DIR/src/foo/bar can be imported as "foo/bar" and has its compiled form installed to "DIR/pkg/GOOS_GOARCH/foo/bar.a".

The bin directory holds compiled commands. Each command is named for its source directory, but only the final element, not the entire path. That is, the command with source in DIR/src/foo/quux is installed into DIR/bin/quux, not DIR/bin/foo/quux. The "foo/" prefix is stripped so that you can add DIR/bin to your PATH to get at the installed commands. If the GOBIN environment variable is set, commands are installed to the directory it names instead of DIR/bin. GOBIN must be an absolute path.

Here's an example directory layout:

```
GOPATH=/home/user/go

/home/user/go/
    src/
        foo/
            bar/               (go code in package bar)
                x.go
            quux/              (go code in package main)
                y.go
    bin/
        quux                   (installed command)
    pkg/
        linux_amd64/
            foo/
                bar.a          (installed package object)
```

Go searches each directory listed in GOPATH to find source code, but new packages are always downloaded into the first directory in the list.

See https://golang.org/doc/code.html for an example.

#### GOPATH and Modules 

When using modules, GOPATH is no longer used for resolving imports. However, it is still used to store downloaded source code (in GOPATH/pkg/mod) and compiled commands (in GOPATH/bin).

#### Internal Directories 

Code in or below a directory named "internal" is importable only by code in the directory tree rooted at the parent of "internal". Here's an extended version of the directory layout above:

```
/home/user/go/
    src/
        crash/
            bang/              (go code in package bang)
                b.go
        foo/                   (go code in package foo)
            f.go
            bar/               (go code in package bar)
                x.go
            internal/
                baz/           (go code in package baz)
                    z.go
            quux/              (go code in package main)
                y.go
```

The code in z.go is imported as "foo/internal/baz", but that import statement can only appear in source files in the subtree rooted at foo. The source files foo/f.go, foo/bar/x.go, and foo/quux/y.go can all import "foo/internal/baz", but the source file crash/bang/b.go cannot.

See https://golang.org/s/go14internal for details.

#### Vendor Directories 

Go 1.6 includes support for using local copies of external dependencies to satisfy imports of those dependencies, often referred to as vendoring.

Code below a directory named "vendor" is importable only by code in the directory tree rooted at the parent of "vendor", and only using an import path that omits the prefix up to and including the vendor element.

Here's the example from the previous section, but with the "internal" directory renamed to "vendor" and a new foo/vendor/crash/bang directory added:

```
/home/user/go/
    src/
        crash/
            bang/              (go code in package bang)
                b.go
        foo/                   (go code in package foo)
            f.go
            bar/               (go code in package bar)
                x.go
            vendor/
                crash/
                    bang/      (go code in package bang)
                        b.go
                baz/           (go code in package baz)
                    z.go
            quux/              (go code in package main)
                y.go
```

The same visibility rules apply as for internal, but the code in z.go is imported as "baz", not as "foo/vendor/baz".

Code in vendor directories deeper in the source tree shadows code in higher directories. Within the subtree rooted at foo, an import of "crash/bang" resolves to "foo/vendor/crash/bang", not the top-level "crash/bang".

Code in vendor directories is not subject to import path checking (see 'go help importpath').

When 'go get' checks out or updates a git repository, it now also updates submodules.

Vendor directories do not affect the placement of new repositories being checked out for the first time by 'go get': those are always placed in the main GOPATH, never in a vendor subtree.

See https://golang.org/s/go15vendor for details.

#### Module proxy protocol 

A Go module proxy is any web server that can respond to GET requests for URLs of a specified form. The requests have no query parameters, so even a site serving from a fixed file system (including a file:/// URL) can be a module proxy.

For details on the GOPROXY protocol, see https://golang.org/ref/mod#goproxy-protocol.

#### Import path syntax 

An import path (see 'go help packages') denotes a package stored in the local file system. In general, an import path denotes either a standard package (such as "unicode/utf8") or a package found in one of the work spaces (For more details see: 'go help gopath').

#### Relative import paths 

An import path beginning with ./ or ../ is called a relative path. The toolchain supports relative import paths as a shortcut in two ways.

First, a relative path can be used as a shorthand on the command line. If you are working in the directory containing the code imported as "unicode" and want to run the tests for "unicode/utf8", you can type "go test ./utf8" instead of needing to specify the full path. Similarly, in the reverse situation, "go test .." will test "unicode" from the "unicode/utf8" directory. Relative patterns are also allowed, like "go test ./..." to test all subdirectories. See 'go help packages' for details on the pattern syntax.

Second, if you are compiling a Go program not in a work space, you can use a relative path in an import statement in that program to refer to nearby code also not in a work space. This makes it easy to experiment with small multipackage programs outside of the usual work spaces, but such programs cannot be installed with "go install" (there is no work space in which to install them), so they are rebuilt from scratch each time they are built. To avoid ambiguity, Go programs cannot use relative import paths within a work space.

#### Remote import paths 

Certain import paths also describe how to obtain the source code for the package using a revision control system.

A few common code hosting sites have special syntax:

```
Bitbucket (Git, Mercurial)

	import "bitbucket.org/user/project"
	import "bitbucket.org/user/project/sub/directory"

GitHub (Git)

	import "github.com/user/project"
	import "github.com/user/project/sub/directory"

Launchpad (Bazaar)

	import "launchpad.net/project"
	import "launchpad.net/project/series"
	import "launchpad.net/project/series/sub/directory"

	import "launchpad.net/~user/project/branch"
	import "launchpad.net/~user/project/branch/sub/directory"

IBM DevOps Services (Git)

	import "hub.jazz.net/git/user/project"
	import "hub.jazz.net/git/user/project/sub/directory"
```

For code hosted on other servers, import paths may either be qualified with the version control type, or the go tool can dynamically fetch the import path over https/http and discover where the code resides from a <meta> tag in the HTML.

To declare the code location, an import path of the form

```
repository.vcs/path
```

specifies the given repository, with or without the .vcs suffix, using the named version control system, and then the path inside that repository. The supported version control systems are:

```
Bazaar      .bzr
Fossil      .fossil
Git         .git
Mercurial   .hg
Subversion  .svn
```

For example,

```
import "example.org/user/foo.hg"
```

denotes the root directory of the Mercurial repository at example.org/user/foo or foo.hg, and

```
import "example.org/repo.git/foo/bar"
```

denotes the foo/bar directory of the Git repository at example.org/repo or repo.git.

When a version control system supports multiple protocols, each is tried in turn when downloading. For example, a Git download tries https://, then git+ssh://.

By default, downloads are restricted to known secure protocols (e.g. https, ssh). To override this setting for Git downloads, the GIT_ALLOW_PROTOCOL environment variable can be set (For more details see: 'go help environment').

If the import path is not a known code hosting site and also lacks a version control qualifier, the go tool attempts to fetch the import over https/http and looks for a <meta> tag in the document's HTML <head>.

The meta tag has the form:

```
<meta name="go-import" content="import-prefix vcs repo-root">
```

The import-prefix is the import path corresponding to the repository root. It must be a prefix or an exact match of the package being fetched with "go get". If it's not an exact match, another http request is made at the prefix to verify the <meta> tags match.

The meta tag should appear as early in the file as possible. In particular, it should appear before any raw JavaScript or CSS, to avoid confusing the go command's restricted parser.

The vcs is one of "bzr", "fossil", "git", "hg", "svn".

The repo-root is the root of the version control system containing a scheme and not containing a .vcs qualifier.

For example,

```
import "example.org/pkg/foo"
```

will result in the following requests:

```
https://example.org/pkg/foo?go-get=1 (preferred)
http://example.org/pkg/foo?go-get=1  (fallback, only with use of correctly set GOINSECURE)
```

If that page contains the meta tag

```
<meta name="go-import" content="example.org git https://code.org/r/p/exproj">
```

the go tool will verify that https://example.org/?go-get=1 contains the same meta tag and then git clone https://code.org/r/p/exproj into GOPATH/src/example.org.

When using GOPATH, downloaded packages are written to the first directory listed in the GOPATH environment variable. (See 'go help gopath-get' and 'go help gopath'.)

When using modules, downloaded packages are stored in the module cache. See https://golang.org/ref/mod#module-cache.

When using modules, an additional variant of the go-import meta tag is recognized and is preferred over those listing version control systems. That variant uses "mod" as the vcs in the content value, as in:

```
<meta name="go-import" content="example.org mod https://code.org/moduleproxy">
```

This tag means to fetch modules with paths beginning with example.org from the module proxy available at the URL https://code.org/moduleproxy. See https://golang.org/ref/mod#goproxy-protocol for details about the proxy protocol.

#### Import path checking 

When the custom import path feature described above redirects to a known code hosting site, each of the resulting packages has two possible import paths, using the custom domain or the known hosting site.

A package statement is said to have an "import comment" if it is immediately followed (before the next newline) by a comment of one of these two forms:

```
package math // import "path"
package math /* import "path" */
```

The go command will refuse to install a package with an import comment unless it is being referred to by that import path. In this way, import comments let package authors make sure the custom import path is used and not a direct path to the underlying code hosting site.

Import path checking is disabled for code found within vendor trees. This makes it possible to copy code into alternate locations in vendor trees without needing to update import comments.

Import path checking is also disabled when using modules. Import path comments are obsoleted by the go.mod file's module statement.

See https://golang.org/s/go14customimport for details.

#### Modules, module versions, and more 

Modules are how Go manages dependencies.

A module is a collection of packages that are released, versioned, and distributed together. Modules may be downloaded directly from version control repositories or from module proxy servers.

For a series of tutorials on modules, see https://golang.org/doc/tutorial/create-module.

For a detailed reference on modules, see https://golang.org/ref/mod.

By default, the go command may download modules from [https://proxy.golang.org](https://proxy.golang.org/). It may authenticate modules using the checksum database at [https://sum.golang.org](https://sum.golang.org/). Both services are operated by the Go team at Google. The privacy policies for these services are available at https://proxy.golang.org/privacy and https://sum.golang.org/privacy, respectively.

The go command's download behavior may be configured using GOPROXY, GOSUMDB, GOPRIVATE, and other environment variables. See 'go help environment' and https://golang.org/ref/mod#private-module-privacy for more information.

#### Module authentication using go.sum 

When the go command downloads a module zip file or go.mod file into the module cache, it computes a cryptographic hash and compares it with a known value to verify the file hasn't changed since it was first downloaded. Known hashes are stored in a file in the module root directory named go.sum. Hashes may also be downloaded from the checksum database depending on the values of GOSUMDB, GOPRIVATE, and GONOSUMDB.

For details, see https://golang.org/ref/mod#authenticating.

#### Package lists and patterns 

Many commands apply to a set of packages:

```
go <action> [packages]
```

Usually, [packages] is a list of import paths.

An import path that is a rooted path or that begins with a . or .. element is interpreted as a file system path and denotes the package in that directory.

Otherwise, the import path P denotes the package found in the directory DIR/src/P for some DIR listed in the GOPATH environment variable (For more details see: 'go help gopath').

If no import paths are given, the action applies to the package in the current directory.

There are four reserved names for paths that should not be used for packages to be built with the go tool:

\- "main" denotes the top-level package in a stand-alone executable.

\- "all" expands to all packages found in all the GOPATH trees. For example, 'go list all' lists all the packages on the local system. When using modules, "all" expands to all packages in the main module and their dependencies, including dependencies needed by tests of any of those.

\- "std" is like all but expands to just the packages in the standard Go library.

\- "cmd" expands to the Go repository's commands and their internal libraries.

Import paths beginning with "cmd/" only match source code in the Go repository.

An import path is a pattern if it includes one or more "..." wildcards, each of which can match any string, including the empty string and strings containing slashes. Such a pattern expands to all package directories found in the GOPATH trees with names matching the patterns.

To make common patterns more convenient, there are two special cases. First, /... at the end of the pattern can match an empty string, so that net/... matches both net and packages in its subdirectories, like net/http. Second, any slash-separated pattern element containing a wildcard never participates in a match of the "vendor" element in the path of a vendored package, so that ./... does not match packages in subdirectories of ./vendor or ./mycode/vendor, but ./vendor/... and ./mycode/vendor/... do. Note, however, that a directory named vendor that itself contains code is not a vendored package: cmd/vendor would be a command named vendor, and the pattern cmd/... matches it. See golang.org/s/go15vendor for more about vendoring.

An import path can also name a package to be downloaded from a remote repository. Run 'go help importpath' for details.

Every package in a program must have a unique import path. By convention, this is arranged by starting each path with a unique prefix that belongs to you. For example, paths used internally at Google all begin with 'google', and paths denoting remote repositories begin with the path to the code, such as 'github.com/user/repo'.

Packages in a program need not have unique package names, but there are two reserved package names with special meaning. The name main indicates a command, not a library. Commands are built into binaries and cannot be imported. The name documentation indicates documentation for a non-Go program in the directory. Files in package documentation are ignored by the go command.

As a special case, if the package list is a list of .go files from a single directory, the command is applied to a single synthesized package made up of exactly those files, ignoring any build constraints in those files and ignoring any other files in the directory.

Directory and file names that begin with "." or "_" are ignored by the go tool, as are directories named "testdata".

#### Configuration for downloading non-public code 

The go command defaults to downloading modules from the public Go module mirror at proxy.golang.org. It also defaults to validating downloaded modules, regardless of source, against the public Go checksum database at sum.golang.org. These defaults work well for publicly available source code.

The GOPRIVATE environment variable controls which modules the go command considers to be private (not available publicly) and should therefore not use the proxy or checksum database. The variable is a comma-separated list of glob patterns (in the syntax of Go's path.Match) of module path prefixes. For example,

```
GOPRIVATE=*.corp.example.com,rsc.io/private
```

causes the go command to treat as private any module with a path prefix matching either pattern, including git.corp.example.com/xyzzy, rsc.io/private, and rsc.io/private/quux.

For fine-grained control over module download and validation, the GONOPROXY and GONOSUMDB environment variables accept the same kind of glob list and override GOPRIVATE for the specific decision of whether to use the proxy and checksum database, respectively.

For example, if a company ran a module proxy serving private modules, users would configure go using:

```
GOPRIVATE=*.corp.example.com
GOPROXY=proxy.example.com
GONOPROXY=none
```

The GOPRIVATE variable is also used to define the "public" and "private" patterns for the GOVCS variable; see 'go help vcs'. For that usage, GOPRIVATE applies even in GOPATH mode. In that case, it matches import paths instead of module paths.

The 'go env -w' command (see 'go help env') can be used to set these variables for future go command invocations.

For more details, see https://golang.org/ref/mod#private-modules.

#### Testing flags 

The 'go test' command takes both flags that apply to 'go test' itself and flags that apply to the resulting test binary.

Several of the flags control profiling and write an execution profile suitable for "go tool pprof"; run "go tool pprof -h" for more information. The --alloc_space, --alloc_objects, and --show_bytes options of pprof control how the information is presented.

The following flags are recognized by the 'go test' command and control the execution of any test:

```
-bench regexp
    Run only those benchmarks matching a regular expression.
    By default, no benchmarks are run.
    To run all benchmarks, use '-bench .' or '-bench=.'.
    The regular expression is split by unbracketed slash (/)
    characters into a sequence of regular expressions, and each
    part of a benchmark's identifier must match the corresponding
    element in the sequence, if any. Possible parents of matches
    are run with b.N=1 to identify sub-benchmarks. For example,
    given -bench=X/Y, top-level benchmarks matching X are run
    with b.N=1 to find any sub-benchmarks matching Y, which are
    then run in full.

-benchtime t
    Run enough iterations of each benchmark to take t, specified
    as a time.Duration (for example, -benchtime 1h30s).
    The default is 1 second (1s).
    The special syntax Nx means to run the benchmark N times
    (for example, -benchtime 100x).

-count n
    Run each test, benchmark, and fuzz seed n times (default 1).
    If -cpu is set, run n times for each GOMAXPROCS value.
    Examples are always run once. -count does not apply to
    fuzz tests matched by -fuzz.

-cover
    Enable coverage analysis.
    Note that because coverage works by annotating the source
    code before compilation, compilation and test failures with
    coverage enabled may report line numbers that don't correspond
    to the original sources.

-covermode set,count,atomic
    Set the mode for coverage analysis for the package[s]
    being tested. The default is "set" unless -race is enabled,
    in which case it is "atomic".
    The values:
	set: bool: does this statement run?
	count: int: how many times does this statement run?
	atomic: int: count, but correct in multithreaded tests;
		significantly more expensive.
    Sets -cover.

-coverpkg pattern1,pattern2,pattern3
    Apply coverage analysis in each test to packages matching the patterns.
    The default is for each test to analyze only the package being tested.
    See 'go help packages' for a description of package patterns.
    Sets -cover.

-cpu 1,2,4
    Specify a list of GOMAXPROCS values for which the tests, benchmarks or
    fuzz tests should be executed. The default is the current value
    of GOMAXPROCS. -cpu does not apply to fuzz tests matched by -fuzz.

-failfast
    Do not start new tests after the first test failure.

-fullpath
    Show full file names in the error messages.

-fuzz regexp
    Run the fuzz test matching the regular expression. When specified,
    the command line argument must match exactly one package within the
    main module, and regexp must match exactly one fuzz test within
    that package. Fuzzing will occur after tests, benchmarks, seed corpora
    of other fuzz tests, and examples have completed. See the Fuzzing
    section of the testing package documentation for details.

-fuzztime t
    Run enough iterations of the fuzz target during fuzzing to take t,
    specified as a time.Duration (for example, -fuzztime 1h30s).
	The default is to run forever.
    The special syntax Nx means to run the fuzz target N times
    (for example, -fuzztime 1000x).

-fuzzminimizetime t
    Run enough iterations of the fuzz target during each minimization
    attempt to take t, as specified as a time.Duration (for example,
    -fuzzminimizetime 30s).
	The default is 60s.
    The special syntax Nx means to run the fuzz target N times
    (for example, -fuzzminimizetime 100x).

-json
    Log verbose output and test results in JSON. This presents the
    same information as the -v flag in a machine-readable format.

-list regexp
    List tests, benchmarks, fuzz tests, or examples matching the regular
    expression. No tests, benchmarks, fuzz tests, or examples will be run.
    This will only list top-level tests. No subtest or subbenchmarks will be
    shown.

-parallel n
    Allow parallel execution of test functions that call t.Parallel, and
    fuzz targets that call t.Parallel when running the seed corpus.
    The value of this flag is the maximum number of tests to run
    simultaneously.
    While fuzzing, the value of this flag is the maximum number of
    subprocesses that may call the fuzz function simultaneously, regardless of
    whether T.Parallel is called.
    By default, -parallel is set to the value of GOMAXPROCS.
    Setting -parallel to values higher than GOMAXPROCS may cause degraded
    performance due to CPU contention, especially when fuzzing.
    Note that -parallel only applies within a single test binary.
    The 'go test' command may run tests for different packages
    in parallel as well, according to the setting of the -p flag
    (see 'go help build').

-run regexp
    Run only those tests, examples, and fuzz tests matching the regular
    expression. For tests, the regular expression is split by unbracketed
    slash (/) characters into a sequence of regular expressions, and each
    part of a test's identifier must match the corresponding element in
    the sequence, if any. Note that possible parents of matches are
    run too, so that -run=X/Y matches and runs and reports the result
    of all tests matching X, even those without sub-tests matching Y,
    because it must run them to look for those sub-tests.
    See also -skip.

-short
    Tell long-running tests to shorten their run time.
    It is off by default but set during all.bash so that installing
    the Go tree can run a sanity check but not spend time running
    exhaustive tests.

-shuffle off,on,N
    Randomize the execution order of tests and benchmarks.
    It is off by default. If -shuffle is set to on, then it will seed
    the randomizer using the system clock. If -shuffle is set to an
    integer N, then N will be used as the seed value. In both cases,
    the seed will be reported for reproducibility.

-skip regexp
    Run only those tests, examples, fuzz tests, and benchmarks that
    do not match the regular expression. Like for -run and -bench,
    for tests and benchmarks, the regular expression is split by unbracketed
    slash (/) characters into a sequence of regular expressions, and each
    part of a test's identifier must match the corresponding element in
    the sequence, if any.

-timeout d
    If a test binary runs longer than duration d, panic.
    If d is 0, the timeout is disabled.
    The default is 10 minutes (10m).

-v
    Verbose output: log all tests as they are run. Also print all
    text from Log and Logf calls even if the test succeeds.

-vet list
    Configure the invocation of "go vet" during "go test"
    to use the comma-separated list of vet checks.
    If list is empty, "go test" runs "go vet" with a curated list of
    checks believed to be always worth addressing.
    If list is "off", "go test" does not run "go vet" at all.
```

The following flags are also recognized by 'go test' and can be used to profile the tests during execution:

```
-benchmem
    Print memory allocation statistics for benchmarks.
    Allocations made in C or using C.malloc are not counted.

-blockprofile block.out
    Write a goroutine blocking profile to the specified file
    when all tests are complete.
    Writes test binary as -c would.

-blockprofilerate n
    Control the detail provided in goroutine blocking profiles by
    calling runtime.SetBlockProfileRate with n.
    See 'go doc runtime.SetBlockProfileRate'.
    The profiler aims to sample, on average, one blocking event every
    n nanoseconds the program spends blocked. By default,
    if -test.blockprofile is set without this flag, all blocking events
    are recorded, equivalent to -test.blockprofilerate=1.

-coverprofile cover.out
    Write a coverage profile to the file after all tests have passed.
    Sets -cover.

-cpuprofile cpu.out
    Write a CPU profile to the specified file before exiting.
    Writes test binary as -c would.

-memprofile mem.out
    Write an allocation profile to the file after all tests have passed.
    Writes test binary as -c would.

-memprofilerate n
    Enable more precise (and expensive) memory allocation profiles by
    setting runtime.MemProfileRate. See 'go doc runtime.MemProfileRate'.
    To profile all memory allocations, use -test.memprofilerate=1.

-mutexprofile mutex.out
    Write a mutex contention profile to the specified file
    when all tests are complete.
    Writes test binary as -c would.

-mutexprofilefraction n
    Sample 1 in n stack traces of goroutines holding a
    contended mutex.

-outputdir directory
    Place output files from profiling in the specified directory,
    by default the directory in which "go test" is running.

-trace trace.out
    Write an execution trace to the specified file before exiting.
```

Each of these flags is also recognized with an optional 'test.' prefix, as in -test.v. When invoking the generated test binary (the result of 'go test -c') directly, however, the prefix is mandatory.

The 'go test' command rewrites or removes recognized flags, as appropriate, both before and after the optional package list, before invoking the test binary.

For instance, the command

```
go test -v -myflag testdata -cpuprofile=prof.out -x
```

will compile the test binary and then run it as

```
pkg.test -test.v -myflag testdata -test.cpuprofile=prof.out
```

(The -x flag is removed because it applies only to the go command's execution, not to the test itself.)

The test flags that generate profiles (other than for coverage) also leave the test binary in pkg.test for use when analyzing the profiles.

When 'go test' runs a test binary, it does so from within the corresponding package's source code directory. Depending on the test, it may be necessary to do the same when invoking a generated test binary directly. Because that directory may be located within the module cache, which may be read-only and is verified by checksums, the test must not write to it or any other directory within the module unless explicitly requested by the user (such as with the -fuzz flag, which writes failures to testdata/fuzz).

The command-line package list, if present, must appear before any flag not known to the go test command. Continuing the example above, the package list would have to appear before -myflag, but could appear on either side of -v.

When 'go test' runs in package list mode, 'go test' caches successful package test results to avoid unnecessary repeated running of tests. To disable test caching, use any test flag or argument other than the cacheable flags. The idiomatic way to disable test caching explicitly is to use -count=1.

To keep an argument for a test binary from being interpreted as a known flag or a package name, use -args (see 'go help test') which passes the remainder of the command line through to the test binary uninterpreted and unaltered.

For instance, the command

```
go test -v -args -x -v
```

will compile the test binary and then run it as

```
pkg.test -test.v -x -v
```

Similarly,

```
go test -args math
```

will compile the test binary and then run it as

```
pkg.test math
```

In the first example, the -x and the second -v are passed through to the test binary unchanged and with no effect on the go command itself. In the second example, the argument math is passed through to the test binary, instead of being interpreted as the package list.

#### Testing functions 

The 'go test' command expects to find test, benchmark, and example functions in the "*_test.go" files corresponding to the package under test.

A test function is one named TestXxx (where Xxx does not start with a lower case letter) and should have the signature,

```
func TestXxx(t *testing.T) { ... }
```

A benchmark function is one named BenchmarkXxx and should have the signature,

```
func BenchmarkXxx(b *testing.B) { ... }
```

A fuzz test is one named FuzzXxx and should have the signature,

```
func FuzzXxx(f *testing.F) { ... }
```

An example function is similar to a test function but, instead of using *testing.T to report success or failure, prints output to os.Stdout. If the last comment in the function starts with "Output:" then the output is compared exactly against the comment (see examples below). If the last comment begins with "Unordered output:" then the output is compared to the comment, however the order of the lines is ignored. An example with no such comment is compiled but not executed. An example with no text after "Output:" is compiled, executed, and expected to produce no output.

Godoc displays the body of ExampleXxx to demonstrate the use of the function, constant, or variable Xxx. An example of a method M with receiver type T or *T is named ExampleT_M. There may be multiple examples for a given function, constant, or variable, distinguished by a trailing _xxx, where xxx is a suffix not beginning with an upper case letter.

Here is an example of an example:

```
func ExamplePrintln() {
	Println("The output of\nthis example.")
	// Output: The output of
	// this example.
}
```

Here is another example where the ordering of the output is ignored:

```
func ExamplePerm() {
	for _, value := range Perm(4) {
		fmt.Println(value)
	}

	// Unordered output: 4
	// 2
	// 1
	// 3
	// 0
}
```

The entire test file is presented as the example when it contains a single example function, at least one other function, type, variable, or constant declaration, and no tests, benchmarks, or fuzz tests.

See the documentation of the testing package for more information.

#### Controlling version control with GOVCS 

The 'go get' command can run version control commands like git to download imported code. This functionality is critical to the decentralized Go package ecosystem, in which code can be imported from any server, but it is also a potential security problem, if a malicious server finds a way to cause the invoked version control command to run unintended code.

To balance the functionality and security concerns, the 'go get' command by default will only use git and hg to download code from public servers. But it will use any known version control system (bzr, fossil, git, hg, svn) to download code from private servers, defined as those hosting packages matching the GOPRIVATE variable (see 'go help private'). The rationale behind allowing only Git and Mercurial is that these two systems have had the most attention to issues of being run as clients of untrusted servers. In contrast, Bazaar, Fossil, and Subversion have primarily been used in trusted, authenticated environments and are not as well scrutinized as attack surfaces.

The version control command restrictions only apply when using direct version control access to download code. When downloading modules from a proxy, 'go get' uses the proxy protocol instead, which is always permitted. By default, the 'go get' command uses the Go module mirror (proxy.golang.org) for public packages and only falls back to version control for private packages or when the mirror refuses to serve a public package (typically for legal reasons). Therefore, clients can still access public code served from Bazaar, Fossil, or Subversion repositories by default, because those downloads use the Go module mirror, which takes on the security risk of running the version control commands using a custom sandbox.

The GOVCS variable can be used to change the allowed version control systems for specific packages (identified by a module or import path). The GOVCS variable applies when building package in both module-aware mode and GOPATH mode. When using modules, the patterns match against the module path. When using GOPATH, the patterns match against the import path corresponding to the root of the version control repository.

The general form of the GOVCS setting is a comma-separated list of pattern:vcslist rules. The pattern is a glob pattern that must match one or more leading elements of the module or import path. The vcslist is a pipe-separated list of allowed version control commands, or "all" to allow use of any known command, or "off" to disallow all commands. Note that if a module matches a pattern with vcslist "off", it may still be downloaded if the origin server uses the "mod" scheme, which instructs the go command to download the module using the GOPROXY protocol. The earliest matching pattern in the list applies, even if later patterns might also match.

For example, consider:

```
GOVCS=github.com:git,evil.com:off,*:git|hg
```

With this setting, code with a module or import path beginning with github.com/ can only use git; paths on evil.com cannot use any version control command, and all other paths (* matches everything) can use only git or hg.

The special patterns "public" and "private" match public and private module or import paths. A path is private if it matches the GOPRIVATE variable; otherwise it is public.

If no rules in the GOVCS variable match a particular module or import path, the 'go get' command applies its default rule, which can now be summarized in GOVCS notation as 'public:git|hg,private:all'.

To allow unfettered use of any version control system for any package, use:

```
GOVCS=*:all
```

To disable all use of version control, use:

```
GOVCS=*:off
```

The 'go env -w' command (see 'go help env') can be used to set the GOVCS variable for future go command invocations.
