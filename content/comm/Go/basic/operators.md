+++
title = "操作符和标点符号"
date = 2024-08-19T09:31:38+08:00
weight = 30
type = "docs"
description = ""
isCJKLanguage = true
draft = false

+++

## 操作符和标点符号（48个）

```go
+    &     +=    &=     &&    ==    !=    (    )
-    |     -=    |=     ||    <     <=    [    ]
*    ^     *=    ^=     <-    >     >=    {    }
/    <<    /=    <<=    ++    =     :=    ,    ;
%    >>    %=    >>=    --    !     ...   .    :
     &^          &^=          ~
```

## 算术操作符（7个）

### `+`



### `-`

### `*`

### `/` 

除法，若两个操作数都是整数，结果是整数（向0取整）；
若两个操作数都是浮点数，则结果是浮点数；
若一整数一浮点数，则编译报错：invalid operation: 变量1 / 变量2 (mismatched types int and float64)

### `%` 

取余

### `++` 

​	Go语言中`++`是一个语句，且只有后置`++`，而没有前置`++`

### `--`

 	Go语言中`——`是一个语句，且只有后置`——`，而没有前置`——`



## 赋值操作符（11个）

### `+=`

### `-=`

### `*=`

### `/=`

### `%=`

### `&=`

### `|=`

### `^=`

### `<<=`

### `>>=`



## 逻辑操作符（3个）

### `&&` 

​	逻辑与

### `||` 

​	逻辑或

### `!`  

​	逻辑非



## 比较操作符（6个）

### `==`

### `!=`

### `<`

### `>`

### `<=`

### `>=`



## 位操作符（6个）

### `&`  

​	按位与。



> 只能用于相同的整数类型，即操作符两边的数据类型必须是相同的整数类型。

​	具体来说，`a & b` 的运算规则是：

- 如果 `a` 和 `b` 中某一位都为 `1`，则结果的对应位为 `1`。
- 如果 `a` 和 `b` 中某一位有一个为 `0`，则结果的对应位为 `0`。
- 不能忽略符号位，即符号位也参与运算。
- 负数是用其补码形式进行运算（提示：负数在内存中的表示形式其实就是以补码的形式，故进行`&`操作时不用手动转换成补码的形式，以下示例中的补码，只是为了方便理解）。

```go
package main

import "fmt"

func main() {
	a := int8(8)
	b := int8(11)
	c := int8(-8)
	d := int8(-11)
	fmt.Printf("a&b\na=%08b a补=%08b\nb=%08b b补=%08b\nr=%08b r补=%08b\n----\n", a, uint8(a), b, uint8(b), a&b, uint8(a&b))
	fmt.Printf("c&d\nc=%08b c补=%08b\nd=%08b d补=%08b\nr=%08b r补=%08b\n----\n", c, uint8(c), d, uint8(d), c&d, uint8(c&d))
	fmt.Printf("a&d\na=%08b a补=%08b\nd=%08b c补=%08b\nr=%08b r补=%08b\n----\n", a, uint8(a), d, uint8(d), a&d, uint8(a&d))
	fmt.Printf("d&a\nd=%08b d补=%08b\na=%08b a补=%08b\nr=%08b r补=%08b\n----\n", d, uint8(d), a, uint8(a), d&a, uint8(d&a))
	fmt.Printf("b&c\nb=%08b b补=%08b\nc=%08b c补=%08b\nr=%08b r补=%08b\n----\n", b, uint8(b), c, uint8(c), b&c, uint8(b&c))
	fmt.Printf("c&b\nc=%08b c补=%08b\nb=%08b b补=%08b\nr=%08b r补=%08b\n----\n", c, uint8(c), b, uint8(b), c&b, uint8(c&b))

}

```

```
a&b
a=00001000 a补=00001000
b=00001011 b补=00001011
r=00001000 r补=00001000
----
c&d
c=-0001000 c补=11111000
d=-0001011 d补=11110101
r=-0010000 r补=11110000
----
a&d
a=00001000 a补=00001000
d=-0001011 c补=11110101
r=00000000 r补=00000000
----
d&a
d=-0001011 d补=11110101
a=00001000 a补=00001000
r=00000000 r补=00000000
----
b&c
b=00001011 b补=00001011
c=-0001000 c补=11111000
r=00001000 r补=00001000
----
c&b
c=-0001000 c补=11111000
b=00001011 b补=00001011
r=00001000 r补=00001000
----
```





### `| ` 

​	按位或。

> 只能用于相同的整数类型，即操作符两边的数据类型必须是相同的整数类型。

​	具体来说，`a | b` 的运算规则是：

- 如果 `a` 和 `b` 中某一位有一个为 `1`，则结果的对应位为 `1`。
- 如果 `a` 和 `b` 中某一位都为 `0`，则结果的对应位为 `0`。
- 不能忽略符号位，即符号位也参与运算。
- 负数是用其补码形式进行运算（提示：负数在内存中的表示形式其实就是以补码的形式，故进行`|`操作时不用手动转换成补码的形式，以下示例中的补码，只是为了方便理解）。

```go
package main

import "fmt"

func main() {
	a := int8(8)
	b := int8(11)
	c := int8(-8)
	d := int8(-11)
	fmt.Printf("a|b\na=%08b a补=%08b\nb=%08b b补=%08b\nr=%08b r补=%08b\n----\n", a, uint8(a), b, uint8(b), a|b, uint8(a|b))
	fmt.Printf("c|d\nc=%08b c补=%08b\nd=%08b d补=%08b\nr=%08b r补=%08b\n----\n", c, uint8(c), d, uint8(d), c|d, uint8(c|d))
	fmt.Printf("a|d\na=%08b a补=%08b\nd=%08b c补=%08b\nr=%08b r补=%08b\n----\n", a, uint8(a), d, uint8(d), a|d, uint8(a|d))
	fmt.Printf("d|a\nd=%08b d补=%08b\na=%08b a补=%08b\nr=%08b r补=%08b\n----\n", d, uint8(d), a, uint8(a), d|a, uint8(d|a))
	fmt.Printf("b|c\nb=%08b b补=%08b\nc=%08b c补=%08b\nr=%08b r补=%08b\n----\n", b, uint8(b), c, uint8(c), b|c, uint8(b|c))
	fmt.Printf("c|b\nc=%08b c补=%08b\nb=%08b b补=%08b\nr=%08b r补=%08b\n----\n", c, uint8(c), b, uint8(b), c|b, uint8(c|b))

}

```

```
a|b
a=00001000 a补=00001000
b=00001011 b补=00001011
r=00001011 r补=00001011
----
c|d
c=-0001000 c补=11111000
d=-0001011 d补=11110101
r=-0000011 r补=11111101
----
a|d
a=00001000 a补=00001000
d=-0001011 c补=11110101
r=-0000011 r补=11111101
----
d|a
d=-0001011 d补=11110101
a=00001000 a补=00001000
r=-0000011 r补=11111101
----
b|c
b=00001011 b补=00001011
c=-0001000 c补=11111000
r=-0000101 r补=11111011
----
c|b
c=-0001000 c补=11111000
b=00001011 b补=00001011
r=-0000101 r补=11111011
----
```



### `^ ` 

​	`按位异或`。或者，也可以表示`按位取反`。

#### 按位异或

> 只能用于相同的整数类型，即操作符两边的数据类型必须是相同的整数类型。

​	

​	具体来说，`a ^ b` 的运算规则是：

- 如果 `a` 和 `b` 中某一位不同，则结果的对应位为 `1`。
- 如果 `a` 和 `b` 中某一位相同，则结果的对应位为 `0`。
- 不能忽略符号位，即符号位也参与运算。
- 遇到负数则将其表示成补码后，再进行运算（负数在内存中的表示形式其实就是以补码的形式，故进行`^`操作时不用手动转换成补码的形式）。

```go
package main

import "fmt"

func main() {
	a := int8(8)
	b := int8(11)
	c := int8(-8)
	d := int8(-11)
	fmt.Printf("a^b\na=%08b a补=%08b\nb=%08b b补=%08b\nr=%08b r补=%08b\n----\n", a, uint8(a), b, uint8(b), a^b, uint8(a^b))
	fmt.Printf("c^d\nc=%08b c补=%08b\nd=%08b d补=%08b\nr=%08b r补=%08b\n----\n", c, uint8(c), d, uint8(d), c^d, uint8(c^d))
	fmt.Printf("a^d\na=%08b a补=%08b\nd=%08b c补=%08b\nr=%08b r补=%08b\n----\n", a, uint8(a), d, uint8(d), a^d, uint8(a^d))
	fmt.Printf("d^a\nd=%08b d补=%08b\na=%08b a补=%08b\nr=%08b r补=%08b\n----\n", d, uint8(d), a, uint8(a), d^a, uint8(d^a))
	fmt.Printf("b^c\nb=%08b b补=%08b\nc=%08b c补=%08b\nr=%08b r补=%08b\n----\n", b, uint8(b), c, uint8(c), b^c, uint8(b^c))
	fmt.Printf("c^b\nc=%08b c补=%08b\nb=%08b b补=%08b\nr=%08b r补=%08b\n----\n", c, uint8(c), b, uint8(b), c^b, uint8(c^b))

}

```

```
a^b
a=00001000 a补=00001000
b=00001011 b补=00001011
r=00000011 r补=00000011
----
c^d
c=-0001000 c补=11111000
d=-0001011 d补=11110101
r=00001101 r补=00001101
----
a^d
a=00001000 a补=00001000
d=-0001011 c补=11110101
r=-0000011 r补=11111101
----
d^a
d=-0001011 d补=11110101
a=00001000 a补=00001000
r=-0000011 r补=11111101
----
b^c
b=00001011 b补=00001011
c=-0001000 c补=11111000
r=-0001101 r补=11110011
----
c^b
c=-0001000 c补=11111000
b=00001011 b补=00001011
r=-0001101 r补=11110011
----
```

#### 按位取反

> 只能用于相同的整数类型。

```go
package main

import "fmt"

func main() {
	a := int8(8)
	c := int8(-8)
	fmt.Printf("^a\na=%08b a补=%08b <- %d\nr=%08b r补=%08b <- %d\n----\n", a, uint8(a), a, ^a, uint8(^a), ^a)
	fmt.Printf("^c\na=%08b c补=%08b <- %d\nr=%08b r补=%08b <- %d\n----\n", c, uint8(c), c, ^c, uint8(^c), ^c)

}

```

```
^a
a=00001000 a补=00001000 <- 8
r=-0001001 r补=11110111 <- -9
----
^c
a=-0001000 c补=11111000 <- -8
r=00000111 r补=00000111 <- 7
----
```



### `&^`

​	 按位清除。

> 只能用于相同的整数类型，即操作符两边的数据类型必须是相同的整数类型。

​	具体来说，`a &^ b` 的运算规则是：

- 如果 `b` 中某一位是 `1`，则 `a` 对应的那一位会被清零（即变成 `0`）。
- 如果 `b` 中某一位是 `0`，则 `a` 对应的那一位保持不变。
- 不能忽略符号位，即符号位也参与运算。
- 遇到负数则将其表示成补码后，再进行运算（负数在内存中的表示形式其实就是以补码的形式，故进行`&^`操作时不用手动转换成补码的形式）。

```go
package main

import "fmt"

func main() {
	a := int8(8)
	b := int8(11)
	c := int8(-8)
	d := int8(-11)
	fmt.Printf("a&^b\na=%08b a补=%08b\nb=%08b b补=%08b\nr=%08b r补=%08b\n----\n", a, uint8(a), b, uint8(b), a&^b, uint8(a&^b))
	fmt.Printf("c&^d\nc=%08b c补=%08b\nd=%08b d补=%08b\nr=%08b r补=%08b\n----\n", c, uint8(c), d, uint8(d), c&^d, uint8(c&^d))
	fmt.Printf("a&^d\na=%08b a补=%08b\nd=%08b c补=%08b\nr=%08b r补=%08b\n----\n", a, uint8(a), d, uint8(d), a&^d, uint8(a&^d))
	fmt.Printf("d&^a\nd=%08b d补=%08b\na=%08b a补=%08b\nr=%08b r补=%08b\n----\n", d, uint8(d), a, uint8(a), d&^a, uint8(d&^a))
	fmt.Printf("b&^c\nb=%08b b补=%08b\nc=%08b c补=%08b\nr=%08b r补=%08b\n----\n", b, uint8(b), c, uint8(c), b&^c, uint8(b&^c))
	fmt.Printf("c&^b\nc=%08b c补=%08b\nb=%08b b补=%08b\nr=%08b r补=%08b\n----\n", c, uint8(c), b, uint8(b), c&^b, uint8(c&^b))


	// e := uint(256255)
	// fmt.Printf("a&^e\na=%08b\ne=%08b\nr=%08b\n----\n", a, e, a&^e) //invalid operation: a &^ e (mismatched types int8 and uint)
	// f := int16(11)
	// fmt.Printf("a&^f\na=%08b\nf=%08b\nr=%08b\n----\n", a, f, a&^f) //invalid operation: a &^ f (mismatched types int8 and int16)
}

```

```go
a&^b
a=00001000 a补=00001000
b=00001011 b补=00001011
r=00000000 r补=00000000
----
c&^d
c=-0001000 c补=11111000
d=-0001011 d补=11110101
r=00001000 r补=00001000
----
a&^d
a=00001000 a补=00001000
d=-0001011 c补=11110101
r=00001000 r补=00001000
----
d&^a
d=-0001011 d补=11110101
a=00001000 a补=00001000
r=-0001011 r补=11110101
----
b&^c
b=00001011 b补=00001011
c=-0001000 c补=11111000
r=00000011 r补=00000011
----
c&^b
c=-0001000 c补=11111000
b=00001011 b补=00001011
r=-0010000 r补=11110000
----
```

`>>` 

​	二进制左移位

```go
package main

import "fmt"

func main() {
	a := int8(8)
	b := uint8(8)
	c := int8(-8)
	fmt.Printf("a=%08b\n", a)

	fmt.Printf("a << 1 = %08b -> %d\n", a<<1, a<<1)
	fmt.Printf("a << 2 = %08b -> %d\n", a<<2, a<<2)
	fmt.Printf("a << 4 = %08b -> %d\n", a<<4, a<<3)
	fmt.Printf("a << 5 = %08b -> %d\n", a<<5, a<<4)
	fmt.Printf("a << 6 = %08b -> %d\n", a<<6, a<<6)
	fmt.Printf("b=%08b\n", b)
	fmt.Printf("b << 1 = %08b -> %d\n", b<<1, b<<1)
	fmt.Printf("b << 2 = %08b -> %d\n", b<<2, b<<2)
	fmt.Printf("b << 4 = %08b -> %d\n", b<<4, b<<4)
	fmt.Printf("b << 5 = %08b -> %d\n", b<<5, b<<5)
	fmt.Printf("b << 6 = %08b -> %d\n", b<<6, b<<6)
	fmt.Printf("c=%09b\n", c)
	fmt.Printf("c << 1 = %08b -> %d\n", c<<1, c<<1)
	fmt.Printf("c << 2 = %08b -> %d\n", c<<2, c<<2)
	fmt.Printf("c << 4 = %08b -> %d\n", c<<4, c<<4)
	fmt.Printf("c << 5 = %08b -> %d\n", c<<5, c<<5)
	fmt.Printf("c << 6 = %08b -> %d\n", c<<6, c<<6)

}

```

```
a=00001000
a << 1 = 00010000 -> 16
a << 2 = 00100000 -> 32
a << 4 = -10000000 -> 64
a << 5 = 00000000 -> -128
a << 6 = 00000000 -> 0
b=00001000
b << 1 = 00010000 -> 16
b << 2 = 00100000 -> 32
b << 4 = 10000000 -> 128
b << 5 = 00000000 -> 0
b << 6 = 00000000 -> 0
c=-00001000
c << 1 = -0010000 -> -16
c << 2 = -0100000 -> -32
c << 4 = -10000000 -> -128
c << 5 = 00000000 -> 0
c << 6 = 00000000 -> 0
```

​	可以看出，对于有符号的整数，移位时，最高位若是1，则当成负数。

`>>` 

二进制右移位

## 指针操作符（2个）

### `*` 

​	声明指针变量、解引用指针。

### `&`

​	获取变量的地址。

## 其他操作符和标点符号（12个）

### `( `

​	左括号，用于运算时分组、import分组、函数或方法的定义以及调用，以及变量定义、常量定义、类型定义时共用var、const、type关键字

### `) `

​	右括号，用于运算时分组、import分组、函数或方法的定义以及调用，以及变量定义、常量定义、类型定义时共用var、const、type关键字

### `[ `

​	左方括号，用于切片、数组的定义，以及切片、数组获取指定索引的值、map获取指定键的值时使用。

### `] `

​	右方括号，用于切片、数组的定义，以及切片、数组获取指定索引的值、map获取指定键的值时使用。

### `{` 

​	用于切片、数组、map等字面值，以及函数、方法、接口、结构体的定义

### `} `

​	用于切片、数组、map等字面值，以及函数、方法、接口、结构体的定义

### `:=` 

​	用于短变量声明

### `. `

​	调用实例的方法、指定包中的函数或方法

### `,` 

​	逗号分隔符

### `; `

​	分号，位于语句末尾，则分号可省略，若一行中有多个语句，则中间语句后面的分号不可省略

### `... `

​	1.放在函数或方法的形参列表的最后一项前，表示该函数或方法接收任意多个实参；
​	2.放在append内置函数的形参列表的最后一项后（最后一项必须是字符串类型、切片类型，
​	对于切片，则其元素的类型必须与append函数的第一个实参的元素类型一致，
​	对于字符串类型，则append函数的第一个实参的元素类型必须是byte类型）

### `: `

1.定义标签后跟的一个冒号（goto语句跳转指定的标签、break指定的标签等）；
2.case、default语句后跟的一个冒号；
3.结构体字段标签中的一个冒号；
4.切片表达式中的一个冒号；

### `~` 

​	指定基础类型

### `->` 

​	channel操作

### `|`

​	 用于类型联合

### 操作符优先级

```go
优先级从高到低排列：
（1）一元操作符（右结合性）
+（正号）
-（负号）
!（逻辑非）
^（按位取反）
*（指针解引用）
&（取地址）
<-（接收运算符，用于从通道中接收数据）

（2）乘法、除法和取余（左结合性）
*（乘法）
/（除法）
%（取余）
<<（左移）
>>（右移）
&（按位与）
&^（按位清除）

（3）加法和减法（左结合性）
+（加法）
-（减法）
|（按位或）
^（按位异或）

（4）关系操作符
==（等于）
!=（不等于）
<（小于）
<=（小于等于）
>（大于）
>=（大于等于）

（5）逻辑运算符
&&（逻辑与）
||（逻辑或）


（6）赋值运算符（右结合性）
=（赋值）
+=（加后赋值）
-=（减后赋值）
*=（乘后赋值）
/=（除后赋值）
%=（取余后赋值）
<<=（左移后赋值）
>>=（右移后赋值）
&=（按位与后赋值）
&^=（按位清除后赋值）
|=（按位或后赋值）
^=（按位异或后赋值）

（7）其他运算符（左结合性）
,（逗号，用于多变量声明和函数参数列表）
```

### 操作符的结合性

​	参见以上优先级部分。
