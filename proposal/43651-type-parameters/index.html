<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-cn class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><link rel="shortcut icon" href=/go_docs/favicons/favicon.ico><link rel=apple-touch-icon href=/go_docs/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/go_docs/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/go_docs/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/go_docs/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/go_docs/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/go_docs/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/go_docs/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/go_docs/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/go_docs/favicons/android-192x192.png sizes=192x192><title>Type Parameters Proposal | Go 中文档集</title><meta name=description content="Type Parameters Proposal 原文：https://go.googlesource.com/proposal/+/HEAD/design/43651-type-pa"><meta property="og:title" content="Type Parameters Proposal"><meta property="og:description" content="Type Parameters Proposal 原文：https://go.googlesource.com/proposal/+/HEAD/design/43651-type-pa"><meta property="og:type" content="article"><meta property="og:url" content="https://before80.github.io/go_docs/proposal/43651-type-parameters/"><meta property="article:section" content="proposal"><meta property="article:published_time" content="2023-06-18T15:53:12+08:00"><meta property="article:modified_time" content="2024-10-10T15:07:50+08:00"><meta itemprop=name content="Type Parameters Proposal"><meta itemprop=description content="Type Parameters Proposal 原文：https://go.googlesource.com/proposal/+/HEAD/design/43651-type-pa"><meta itemprop=datePublished content="2023-06-18T15:53:12+08:00"><meta itemprop=dateModified content="2024-10-10T15:07:50+08:00"><meta itemprop=wordCount content="24166"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Type Parameters Proposal"><meta name=twitter:description content="Type Parameters Proposal 原文：https://go.googlesource.com/proposal/+/HEAD/design/43651-type-pa"><link rel=preload href=/go_docs/scss/main.min.2412d9ce8d59c0bc460230f66fb6de2f724f349b5e83810ed8155cc1ecc54c1e.css as=style><link href=/go_docs/scss/main.min.2412d9ce8d59c0bc460230f66fb6de2f724f349b5e83810ed8155cc1ecc54c1e.css rel=stylesheet integrity><link href=/go_docs/css/extra.css rel=stylesheet><link href=/go_docs/css/tocbot.css rel=stylesheet><script src=https://code.jquery.com/jquery-3.7.1.min.js integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin=anonymous></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@docsearch/css@3.6.0 integrity="sha512-AyDFDkYyALC5qoao077IqAOV7UC4oKCBTp+mJfjIt306AIRoBxoEZYDo0kAx/R7RbT+3EYEky1po/F1w1eQt7g==" crossorigin=anonymous></head><body class=td-page><header><nav class="td-navbar navbar-dark js-navbar-scroll" data-bs-theme=dark><div class="container-fluid flex-column flex-md-row"><a class=navbar-brand href=/go_docs/><span class="navbar-brand__logo navbar-logo"><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 500 500" style="enable-background:new 0 0 500 500"><g><path style="fill:#fff" d="M116.8525 421.9722c-5.7041.0-10.3442-4.3127-10.3442-9.6129V88.183c0-5.3002 4.6401-9.6117 10.3442-9.6117H320.858c3.0347.0 9.3959.5498 11.7506 2.6302l.3545.3442 58.905 63.2912c2.3101 2.491 2.9202 8.4928 2.9202 11.3184v256.2039c0 5.3002-4.6407 9.6129-10.3436 9.6129H116.8525z"/><g><g><g><path style="fill:#767676" d="M384.4445 423.2066H116.852c-6.3839.0-11.5786-4.8658-11.5786-10.8474V88.1831c0-5.9804 5.1947-10.8461 11.5786-10.8461h204.0062c.377.0 9.2786.0329 12.568 2.9389l.3947.3833 58.9508 63.337c3.2135 3.4652 3.2514 11.7924 3.2514 12.1593v256.2036C396.0231 418.3408 390.8284 423.2066 384.4445 423.2066zM116.5079 411.9189c.0848.0278.1999.0531.3441.0531h267.5925c.1442.0.2581-.0253.3441-.0531V156.1556c-.0076-.9033-.3593-3.7347-.7034-5.0037l-57.6527-61.9416c-1.4651-.3176-4.4533-.6389-5.5742-.6389H116.852c-.143.0-.2594.024-.3441.0531V411.9189zm267.4533-261.149zM327.0321 89.371v.0013V89.371z"/></g></g></g><g><g><path style="fill:#5b7fc0" d="M189.0874 210.1754l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.025 2.454-11.4897 6.4116-15.4473C177.5953 212.627 183.0601 210.1742 189.0874 210.1754zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403S197.0816 234.1722 197.0804 232.033z"/><path style="opacity:.3;fill:#fff" d="M189.0898 210.176c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 212.6276 183.0612 210.176 189.0898 210.176zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 236.239 197.0839 234.2399 197.0839 232.0372z"/><g><defs><path id="SVGID_1_" d="M194.7376 237.6875c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.999 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 234.2399 196.1861 236.239 194.7376 237.6875z"/></defs><clipPath id="SVGID_2_"><use xlink:href="#SVGID_1_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_2_);fill:#fff" d="M190.0704 225.0237c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 225.7247 191.9774 225.0237 190.0704 225.0237z"/><path style="opacity:.13;clip-path:url(#SVGID_2_);fill:#020202" d="M190.0704 225.0237c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 225.7247 191.9774 225.0237 190.0704 225.0237z"/></g><g><defs><path id="SVGID_3_" d="M189.0898 210.176c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 212.6276 183.0612 210.176 189.0898 210.176zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 236.239 197.0839 234.2399 197.0839 232.0372z"/></defs><clipPath id="SVGID_4_"><use xlink:href="#SVGID_3_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_4_);fill:#5b7fc0" d="M172.6595 215.6045c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8612 12.0547.0024 21.8636-9.797 21.8613-21.8612.0024-3.8475-1.0151-7.6326-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 209.1953 176.6171 211.647 172.6595 215.6045z"/></g></g><rect x="198.8952" y="225.1043" style="fill:#5b7fc0" width="122.6266" height="13.8671"/></g><g><path style="fill:#d95140" d="M189.0874 155.7611l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.0249 2.454-11.4897 6.4116-15.4473C177.5953 158.2128 183.0601 155.7599 189.0874 155.7611zm7.993 21.8577c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403C196.2508 181.7667 197.0816 179.758 197.0804 177.6188z"/><path style="opacity:.3;fill:#fff" d="M189.0898 155.7617c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 158.2134 183.0612 155.7617 189.0898 155.7617zm7.9941 21.8613c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 181.8248 197.0839 179.8256 197.0839 177.623z"/><g><defs><path id="SVGID_5_" d="M194.7376 183.2733c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.9989 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 179.8256 196.1861 181.8248 194.7376 183.2733z"/></defs><clipPath id="SVGID_6_"><use xlink:href="#SVGID_5_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_6_);fill:#fff" d="M190.0704 170.6095c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 171.3104 191.9774 170.6095 190.0704 170.6095z"/><path style="opacity:.13;clip-path:url(#SVGID_6_);fill:#020202" d="M190.0704 170.6095c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 171.3104 191.9774 170.6095 190.0704 170.6095z"/></g><g><defs><path id="SVGID_7_" d="M189.0898 155.7617c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 158.2134 183.0612 155.7617 189.0898 155.7617zm7.9941 21.8613c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 181.8248 197.0839 179.8256 197.0839 177.623z"/></defs><clipPath id="SVGID_8_"><use xlink:href="#SVGID_7_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_8_);fill:#d95140" d="M172.6595 161.1903c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8613 12.0547.0024 21.8636-9.797 21.8613-21.8613.0024-3.8474-1.0151-7.6326-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 154.7811 176.6171 157.2327 172.6595 161.1903z"/></g><rect x="198.8952" y="170.69" style="fill:#d95140" width="122.6266" height="13.8671"/></g><g><g><path style="fill:#56a55c" d="M189.5379 264.6147l.0012-.0012c7.7751.0012 15.0294 4.1862 18.932 10.9235 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032-5.8394.0-11.3281-2.2733-15.458-6.4032-4.13-4.13-6.4032-9.6186-6.4056-15.4628.0012-6.0249 2.454-11.4897 6.4116-15.4472C178.0458 267.0663 183.5105 264.6135 189.5379 264.6147zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6538 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403C196.7013 290.6202 197.5321 288.6115 197.5309 286.4723z"/><path style="opacity:.3;fill:#fff" d="M189.5403 264.6153c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8065-21.8612-21.8613.0-6.0285 2.4516-11.492 6.4116-15.452C178.0482 267.0669 183.5117 264.6153 189.5403 264.6153zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.6366 290.6783 197.5344 288.6792 197.5344 286.4765z"/><g><defs><path id="SVGID_9_" d="M195.1881 292.1268c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.9989 7.9942-7.9941 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.5344 288.6792 196.6366 290.6783 195.1881 292.1268z"/></defs><clipPath id="SVGID_10_"><use xlink:href="#SVGID_9_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_10_);fill:#fff" d="M190.5209 279.463c-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7446-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9941 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C194.239 280.164 192.4279 279.463 190.5209 279.463z"/><path style="opacity:.13;clip-path:url(#SVGID_10_);fill:#020202" d="M190.5209 279.463c-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7446-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9941 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C194.239 280.164 192.4279 279.463 190.5209 279.463z"/></g><g><defs><path id="SVGID_11_" d="M189.5403 264.6153c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8065-21.8612-21.8613.0-6.0285 2.4516-11.492 6.4116-15.452C178.0482 267.0669 183.5117 264.6153 189.5403 264.6153zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.6366 290.6783 197.5344 288.6792 197.5344 286.4765z"/></defs><clipPath id="SVGID_12_"><use xlink:href="#SVGID_11_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_12_);fill:#56a55c" d="M173.11 270.0439c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8613 12.0547.0024 21.8636-9.797 21.8613-21.8613.0024-3.8474-1.0151-7.6326-2.9353-10.9462-3.8977-6.7325-11.1497-10.9151-18.926-10.9151C182.5311 263.6346 177.0676 266.0863 173.11 270.0439z"/></g></g><rect x="199.3456" y="279.5436" style="fill:#56a55c" width="122.6266" height="13.8671"/></g><g><g><path style="fill:#f1bc42" d="M189.0874 318.7208l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3305-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.025 2.454-11.4897 6.4116-15.4472C177.5953 321.1724 183.0601 318.7196 189.0874 318.7208zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403S197.0816 342.7176 197.0804 340.5784z"/><path style="opacity:.3;fill:#fff" d="M189.0898 318.7214c7.7763.0 15.0283 4.1826 18.926 10.915 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8612-12.0547.0024-21.8636-9.8065-21.8612-21.8612.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 321.173 183.0612 318.7214 189.0898 318.7214zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 344.7844 197.0839 342.7853 197.0839 340.5826z"/><g><defs><path id="SVGID_13_" d="M194.7376 346.2329c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.999 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 342.7853 196.1861 344.7844 194.7376 346.2329z"/></defs><clipPath id="SVGID_14_"><use xlink:href="#SVGID_13_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_14_);fill:#fff" d="M190.0704 333.5691c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0834 6.1218 2.8788C193.7885 334.2701 191.9774 333.5691 190.0704 333.5691z"/><path style="opacity:.13;clip-path:url(#SVGID_14_);fill:#020202" d="M190.0704 333.5691c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0834 6.1218 2.8788C193.7885 334.2701 191.9774 333.5691 190.0704 333.5691z"/></g><g><defs><path id="SVGID_15_" d="M189.0898 318.7214c7.7763.0 15.0283 4.1826 18.926 10.915 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8612-12.0547.0024-21.8636-9.8065-21.8612-21.8612.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 321.173 183.0612 318.7214 189.0898 318.7214zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 344.7844 197.0839 342.7853 197.0839 340.5826z"/></defs><clipPath id="SVGID_16_"><use xlink:href="#SVGID_15_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_16_);fill:#f1bc42" d="M172.6595 324.15c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8612 12.0547.0024 21.8636-9.797 21.8613-21.8612.0024-3.8474-1.0151-7.6327-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 317.7407 176.6171 320.1924 172.6595 324.15z"/></g></g><rect x="198.8952" y="333.6497" style="fill:#f1bc42" width="122.6266" height="13.8671"/></g></g></svg></span><span class=navbar-brand__name>Go 中文档集</span></a><div class="td-navbar-nav-scroll ms-md-auto" id=main_navbar><ul class=navbar-nav><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=javascript:; id=show-timer style=color:#fe4512f5!important></a></li><li class=nav-item><a class=nav-link href=/go_docs/refs/><span>参考</span></a></li><li class=nav-item><a class=nav-link href=/go_docs/comm/><span>对比</span></a></li><li class=nav-item><a class=nav-link href=/go_docs/tools/><span>工具</span></a></li><li class=nav-item><a class=nav-link href=/go_docs/langSpec/><span>语规</span></a></li><li class=nav-item><a class=nav-link href=/go_docs/styleGuide/><span>编规</span></a></li><li class=nav-item><a class=nav-link href=/go_docs/example/><span>示例</span></a></li><li class=nav-item><a class=nav-link href=/go_docs/asu/><span>汇总</span></a></li><li class=nav-item><a class=nav-link href=/go_docs/fx/><span>分析</span></a></li><li class=nav-item><a class=nav-link href=/go_docs/docs/><span>文档</span></a></li><li class=nav-item><a class=nav-link href=/go_docs/cmd/><span>go命令</span></a></li><li class=nav-item><a class=nav-link href=/go_docs/stdLib/><span>标准库</span></a></li><li class=nav-item><a class=nav-link href=/go_docs/thirdPkg/><span>第三方包</span></a></li><li class=nav-item><a class=nav-link href=/go_docs/delve/><span>delve</span></a></li><li class=nav-item><a class=nav-link href=/go_docs/rod/><span>rod</span></a></li><li class=nav-item><a class=nav-link href=/go_docs/goframe/><span>goframe</span></a></li><li class=nav-item><a class=nav-link href=/go_docs/gorm/><span>gorm</span></a></li><li class=nav-item><a class=nav-link href=/go_docs/echo/><span>echo</span></a></li><li class=nav-item><a class=nav-link href=/go_docs/fiber/><span>fiber</span></a></li><li class=nav-item><a class=nav-link href=/go_docs/buffalo/><span>buffalo</span></a></li><li class=nav-item><a class=nav-link href=/go_docs/beego/><span>beego</span></a></li><li class=nav-item><a class=nav-link href=/go_docs/goBlog/><span>官博</span></a></li><li class=nav-item><a class="nav-link active" href=/go_docs/proposal/><span>提案</span></a></li><li class="td-light-dark-menu nav-item dropdown"><svg xmlns="http://www.w3.org/2000/svg" class="d-none"><symbol id="check2" viewBox="0 0 16 16"><path d="M13.854 3.646a.5.5.0 010 .708l-7 7a.5.5.0 01-.708.0l-3.5-3.5a.5.5.0 11.708-.708L6.5 10.293l6.646-6.647a.5.5.0 01.708.0z"/></symbol><symbol id="circle-half" viewBox="0 0 16 16"><path d="M8 15A7 7 0 108 1v14zm0 1A8 8 0 118 0a8 8 0 010 16z"/></symbol><symbol id="moon-stars-fill" viewBox="0 0 16 16"><path d="M6 .278a.768.768.0 01.08.858 7.208 7.208.0 00-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527.0 1.04-.055 1.533-.16a.787.787.0 01.81.316.733.733.0 01-.031.893A8.349 8.349.0 018.344 16C3.734 16 0 12.286.0 7.71.0 4.266 2.114 1.312 5.124.06A.752.752.0 016 .278z"/><path d="M10.794 3.148a.217.217.0 01.412.0l.387 1.162c.173.518.579.924 1.097 1.097l1.162.387a.217.217.0 010 .412l-1.162.387A1.734 1.734.0 0011.593 7.69l-.387 1.162a.217.217.0 01-.412.0l-.387-1.162A1.734 1.734.0 009.31 6.593l-1.162-.387a.217.217.0 010-.412l1.162-.387a1.734 1.734.0 001.097-1.097l.387-1.162zM13.863.099a.145.145.0 01.274.0l.258.774c.115.346.386.617.732.732l.774.258a.145.145.0 010 .274l-.774.258a1.156 1.156.0 00-.732.732l-.258.774a.145.145.0 01-.274.0l-.258-.774a1.156 1.156.0 00-.732-.732l-.774-.258a.145.145.0 010-.274l.774-.258c.346-.115.617-.386.732-.732L13.863.1z"/></symbol><symbol id="sun-fill" viewBox="0 0 16 16"><path d="M8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 0zm0 13a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 13zm8-5a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2a.5.5.0 01.5.5zM3 8a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2A.5.5.0 013 8zm10.657-5.657a.5.5.0 010 .707l-1.414 1.415a.5.5.0 11-.707-.708l1.414-1.414a.5.5.0 01.707.0zm-9.193 9.193a.5.5.0 010 .707L3.05 13.657a.5.5.0 01-.707-.707l1.414-1.414a.5.5.0 01.707.0zm9.193 2.121a.5.5.0 01-.707.0l-1.414-1.414a.5.5.0 01.707-.707l1.414 1.414a.5.5.0 010 .707zM4.464 4.465a.5.5.0 01-.707.0L2.343 3.05a.5.5.0 11.707-.707l1.414 1.414a.5.5.0 010 .708z"/></symbol></svg><button class="btn btn-link nav-link dropdown-toggle d-flex align-items-center" id=bd-theme type=button aria-expanded=false data-bs-toggle=dropdown data-bs-display=static aria-label="Toggle theme (auto)"><svg class="bi my-1 theme-icon-active"><use href="#circle-half"/></svg></button><ul class="dropdown-menu dropdown-menu-end" aria-labelledby=bd-theme-text><li><button type=button class="dropdown-item d-flex align-items-center" data-bs-theme-value=light aria-pressed=false><svg class="bi me-2 opacity-50"><use href="#sun-fill"/></svg>
Light<svg class="bi ms-auto d-none"><use href="#check2"/></svg></button></li><li><button type=button class="dropdown-item d-flex align-items-center" data-bs-theme-value=dark aria-pressed=false><svg class="bi me-2 opacity-50"><use href="#moon-stars-fill"/></svg>
Dark<svg class="bi ms-auto d-none"><use href="#check2"/></svg></button></li><li><button type=button class="dropdown-item d-flex align-items-center active" data-bs-theme-value=auto aria-pressed=true><svg class="bi me-2 opacity-50"><use href="#circle-half"/></svg>
Auto<svg class="bi ms-auto d-none"><use href="#check2"/></svg></button></li></ul></li></ul></div><div class="d-none d-lg-block"><div class=td-search><div class=td-search--algolia id=docsearch-1></div></div></div></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><aside class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none"><div id=td-sidebar-menu class=td-sidebar__inner><form class="td-sidebar__search d-flex align-items-center"><div class=td-search><div class=td-search--algolia id=docsearch-0></div></div><button class="btn btn-link td-sidebar__toggle d-md-none p-0 ms-3 fas fa-bars" type=button data-bs-toggle=collapse data-bs-target=#td-section-nav aria-controls=td-section-nav aria-expanded=false aria-label="Toggle section navigation"></button></form><nav class="td-sidebar-nav collapse foldable-nav" id=td-section-nav><ul class="td-sidebar-nav__section pe-md-3 ul-0"><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child active-path" id=m-go_docsproposal-li><a href=/go_docs/proposal/ class="align-left ps-0 td-sidebar-link td-sidebar-link__section tree-root" id=m-go_docsproposal><span>提案</span></a><ul class=ul-1><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child active-path" id=m-go_docsproposal43651-type-parameters-li><input type=checkbox id=m-go_docsproposal43651-type-parameters-check checked>
<label for=m-go_docsproposal43651-type-parameters-check><a href=/go_docs/proposal/43651-type-parameters/ class="align-left ps-0 active td-sidebar-link td-sidebar-link__page" id=m-go_docsproposal43651-type-parameters><span class=td-sidebar-nav-active-item>Type Parameters Proposal</span></a></label></li></ul></li></ul></nav></div></aside><aside class="d-none d-xl-block col-xl-2 td-sidebar-toc d-print-none"><div class="td-page-meta ms-2 pb-1 pt-2 mb-0"><a href=https://before80.github.io/go_docs/comm/coffee class="td-page-meta--view td-page-meta__view" style=color:#2bf518!important target=_blank rel=noopener><i class="fa-solid fa-mug-hot fa-fw"></i> 请作者喝杯咖啡吧</a>
<a href=https://github.com/before80/go_docs/tree/main/content/proposal/43651-type-parameters.md class="td-page-meta--view td-page-meta__view" target=_blank rel=noopener><i class="fa-solid fa-file-lines fa-fw"></i> 查看页面源码</a>
<a href=https://github.com/before80/go_docs/edit/main/content/proposal/43651-type-parameters.md class="td-page-meta--edit td-page-meta__edit" target=_blank rel=noopener><i class="fa-solid fa-pen-to-square fa-fw"></i> 编辑此页</a>
<a href="https://github.com/before80/go_docs/new/main/content/proposal?filename=change-me.md&amp;value=---%0Atitle%3A+%22Long+Page+Title%22%0AlinkTitle%3A+%22Short+Nav+Title%22%0Aweight%3A+100%0Adescription%3A+%3E-%0A+++++Page+description+for+heading+and+indexes.%0A---%0A%0A%23%23+Heading%0A%0AEdit+this+template+to+create+your+new+page.%0A%0A%2A+Give+it+a+good+name%2C+ending+in+%60.md%60+-+e.g.+%60getting-started.md%60%0A%2A+Edit+the+%22front+matter%22+section+at+the+top+of+the+page+%28weight+controls+how+its+ordered+amongst+other+pages+in+the+same+directory%3B+lowest+number+first%29.%0A%2A+Add+a+good+commit+message+at+the+bottom+of+the+page+%28%3C80+characters%3B+use+the+extended+description+field+for+more+detail%29.%0A%2A+Create+a+new+branch+so+you+can+preview+your+new+file+and+request+a+review+via+Pull+Request.%0A" class="td-page-meta--child td-page-meta__child" target=_blank rel=noopener><i class="fa-solid fa-pen-to-square fa-fw"></i> 添加子页面</a>
<a href="https://github.com/before80/go_docs/issues/new?title=Type%20Parameters%20Proposal" class="td-page-meta--issue td-page-meta__issue" target=_blank rel=noopener><i class="fa-solid fa-list-check fa-fw"></i> 提交文档问题</a>
<a href=https://github.com/before80/go_docs/issues/new class="td-page-meta--project td-page-meta__project-issue" target=_blank rel=noopener><i class="fa-solid fa-list-check fa-fw"></i> 提交项目问题</a></div><div class=td-toc><nav id=TableOfContents><ul><li><a href=#type-parameters-proposal>Type Parameters Proposal</a><ul><li><a href=#status>Status</a></li><li><a href=#abstract>Abstract</a></li><li><a href=#how-to-read-this-proposal>How to read this proposal</a></li><li><a href=#very-high-level-overview>Very high level overview</a></li><li><a href=#background>Background</a></li><li><a href=#design>Design</a><ul><li><a href=#type-parameters>Type parameters</a></li><li><a href=#constraints>Constraints</a></li><li><a href=#operations-permitted-for-any-type>Operations permitted for any type</a></li><li><a href=#defining-constraints>Defining constraints</a></li><li><a href=#the-any-constraint>The <code>any</code> constraint</a></li><li><a href=#using-a-constraint>Using a constraint</a></li><li><a href=#multiple-type-parameters>Multiple type parameters</a></li><li><a href=#generic-types>Generic types</a></li><li><a href=#methods-may-not-take-additional-type-arguments>Methods may not take additional type arguments</a></li><li><a href=#operators>Operators</a><ul><li><a href=#type-sets>Type sets</a></li><li><a href=#type-sets-of-constraints>Type sets of constraints</a></li><li><a href=#constraint-elements>Constraint elements</a><ul><li><a href=#arbitrary-type-constraint-element>Arbitrary type constraint element</a></li><li><a href=#approximation-constraint-element>Approximation constraint element</a></li><li><a href=#union-constraint-element>Union constraint element</a></li></ul></li><li><a href=#operations-based-on-type-sets>Operations based on type sets</a></li><li><a href=#comparable-types-in-constraints>Comparable types in constraints</a></li></ul></li><li><a href=#mutually-referencing-type-parameters>Mutually referencing type parameters</a></li><li><a href=#type-inference>Type inference</a><ul><li><a href=#type-unification>Type unification</a></li><li><a href=#function-argument-type-inference>Function argument type inference</a></li><li><a href=#constraint-type-inference>Constraint type inference</a><ul><li><a href=#element-constraint-example>Element constraint example</a></li><li><a href=#pointer-method-example>Pointer method example</a></li><li><a href=#constraints-apply-even-after-constraint-type-inference>Constraints apply even after constraint type inference</a></li></ul></li></ul></li><li><a href=#using-types-that-refer-to-themselves-in-constraints>Using types that refer to themselves in constraints</a></li><li><a href=#values-of-type-parameters-are-not-boxed>Values of type parameters are not boxed</a></li><li><a href=#more-on-type-sets>More on type sets</a><ul><li><a href=#both-elements-and-methods-in-constraints>Both elements and methods in constraints</a></li><li><a href=#composite-types-in-constraints>Composite types in constraints</a></li><li><a href=#type-parameters-in-type-sets>Type parameters in type sets</a></li><li><a href=#type-conversions>Type conversions</a></li><li><a href=#untyped-constants>Untyped constants</a></li><li><a href=#type-sets-of-embedded-constraints>Type sets of embedded constraints</a></li><li><a href=#interface-types-in-union-elements>Interface types in union elements</a></li><li><a href=#empty-type-sets>Empty type sets</a></li><li><a href=#general-notes-on-type-sets>General notes on type sets</a></li></ul></li><li><a href=#reflection>Reflection</a></li><li><a href=#implementation>Implementation</a></li><li><a href=#summary>Summary</a><ul><li><a href=#complexity>Complexity</a></li><li><a href=#pervasiveness>Pervasiveness</a></li><li><a href=#efficiency>Efficiency</a></li><li><a href=#omissions>Omissions</a></li><li><a href=#issues>Issues</a><ul><li><a href=#the-zero-value>The zero value</a></li><li><a href=#identifying-the-matched-predeclared-type>Identifying the matched predeclared type</a></li><li><a href=#no-way-to-express-convertibility>No way to express convertibility</a></li><li><a href=#no-parameterized-methods>No parameterized methods</a></li><li><a href=#no-way-to-require-pointer-methods>No way to require pointer methods</a></li><li><a href=#no-association-between-float-and-complex>No association between float and complex</a></li></ul></li><li><a href=#discarded-ideas>Discarded ideas</a><ul><li><a href=#what-happened-to-contracts>What happened to contracts?</a></li><li><a href=#why-not-use-methods-instead-of-type-sets>Why not use methods instead of type sets?</a></li><li><a href=#why-not-put-type-parameters-on-packages>Why not put type parameters on packages?</a></li><li><a href=#why-not-use-the-syntax-ft-like-c-and-java>Why not use the syntax <code>F&lt;T></code> like C++ and Java?</a></li><li><a href=#why-not-use-the-syntax-ft>Why not use the syntax <code>F(T)</code>?</a></li><li><a href=#why-not-use-ft>Why not use <code>F«T»</code>?</a></li><li><a href=#why-not-define-constraints-in-a-builtin-package>Why not define constraints in a builtin package?</a></li><li><a href=#why-not-permit-type-assertions-on-values-whose-type-is-a-type-parameter>Why not permit type assertions on values whose type is a type parameter?</a></li></ul></li><li><a href=#comparison-with-java>Comparison with Java</a></li><li><a href=#comparison-with-c>Comparison with C++</a></li><li><a href=#comparison-with-rust>Comparison with Rust</a></li></ul></li></ul></li><li><a href=#examples>Examples</a><ul><li><a href=#mapreducefilter>Map/Reduce/Filter</a></li><li><a href=#map-keys>Map keys</a></li><li><a href=#sets>Sets</a></li><li><a href=#sort>Sort</a></li><li><a href=#channels>Channels</a></li><li><a href=#containers>Containers</a></li><li><a href=#append>Append</a></li><li><a href=#metrics>Metrics</a></li><li><a href=#list-transform>List transform</a></li><li><a href=#dot-product>Dot product</a></li><li><a href=#absolute-difference>Absolute difference</a></li></ul></li><li><a href=#acknowledgements>Acknowledgements</a></li><li><a href=#appendix>Appendix</a><ul><li><a href=#generic-type-aliases>Generic type aliases</a></li><li><a href=#instantiating-a-function>Instantiating a function</a></li><li><a href=#embedded-type-parameter>Embedded type parameter</a></li><li><a href=#embedded-type-parameter-methods>Embedded type parameter methods</a></li><li><a href=#embedded-instantiated-type>Embedded instantiated type</a></li><li><a href=#generic-types-as-type-switch-cases>Generic types as type switch cases</a></li><li><a href=#method-sets-of-constraint-elements>Method sets of constraint elements</a></li><li><a href=#permitting-constraints-as-ordinary-interface-types>Permitting constraints as ordinary interface types</a></li><li><a href=#type-inference-for-composite-literals>Type inference for composite literals</a></li><li><a href=#type-inference-for-generic-function-arguments>Type inference for generic function arguments</a></li><li><a href=#reflection-on-type-arguments>Reflection on type arguments</a></li></ul></li></ul></li></ul></nav></div></aside><main class="col-12 col-md-9 col-xl-8 ps-md-5" role=main><nav aria-label=breadcrumb class=td-breadcrumbs><ol class=breadcrumb><li class=breadcrumb-item><a href=/go_docs/proposal/>提案</a></li><li class="breadcrumb-item active" aria-current=page>Type Parameters Proposal</li></ol></nav><div class=td-content><h1>Type Parameters Proposal</h1><header class=article-meta><p class=reading-time><i class="fa-solid fa-clock" style=color:#e90 aria-hidden=true></i>&nbsp; <span style=font-size:3rem;color:#006400 id=advice-reading-time>49 </span>分钟阅读 &nbsp;</p></header><h1 id=type-parameters-proposal>Type Parameters Proposal</h1><blockquote><p>原文：<a href=https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md>https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md</a></p></blockquote><p>Ian Lance Taylor
Robert Griesemer
August 20, 2021</p><h2 id=status>Status</h2><p>This is the design for adding generic programming using type parameters to the Go language. This design has been <a href=https://golang.org/issue/43651>proposed and accepted</a> as a future language change. We currently expect that this change will be available in the Go 1.18 release in early 2022.</p><h2 id=abstract>Abstract</h2><p>We suggest extending the Go language to add optional type parameters to type and function declarations. Type parameters are constrained by interface types. Interface types, when used as type constraints, support embedding additional elements that may be used to limit the set of types that satisfy the constraint. Parameterized types and functions may use operators with type parameters, but only when permitted by all types that satisfy the parameter&rsquo;s constraint. Type inference via a unification algorithm permits omitting type arguments from function calls in many cases. The design is fully backward compatible with Go 1.</p><h2 id=how-to-read-this-proposal>How to read this proposal</h2><p>This document is long. Here is some guidance on how to read it.</p><ul><li>We start with a high level overview, describing the concepts very briefly.</li><li>We then explain the full design starting from scratch, introducing the details as we need them, with simple examples.</li><li>After the design is completely described, we discuss implementation, some issues with the design, and a comparison with other approaches to generics.</li><li>We then present several complete examples of how this design would be used in practice.</li><li>Following the examples some minor details are discussed in an appendix.</li></ul><h2 id=very-high-level-overview>Very high level overview</h2><p>This section explains the changes suggested by the design very briefly. This section is intended for people who are already familiar with how generics would work in a language like Go. These concepts will be explained in detail in the following sections.</p><ul><li>Functions can have an additional type parameter list that uses square brackets but otherwise looks like an ordinary parameter list: <code>func F[T any](p T) { ... }</code>.</li><li>These type parameters can be used by the regular parameters and in the function body.</li><li>Types can also have a type parameter list: <code>type M[T any] []T</code>.</li><li>Each type parameter has a type constraint, just as each ordinary parameter has a type: <code>func F[T Constraint](p T) { ... }</code>.</li><li>Type constraints are interface types.</li><li>The new predeclared name <code>any</code> is a type constraint that permits any type.</li><li>Interface types used as type constraints can embed additional elements to restrict the set of type arguments that satisfy the contraint:<ul><li>an arbitrary type <code>T</code> restricts to that type</li><li>an approximation element <code>~T</code> restricts to all types whose underlying type is <code>T</code></li><li>a union element <code>T1 | T2 | ...</code> restricts to any of the listed elements</li></ul></li><li>Generic functions may only use operations supported by all the types permitted by the constraint.</li><li>Using a generic function or type requires passing type arguments.</li><li>Type inference permits omitting the type arguments of a function call in common cases.</li></ul><p>In the following sections we work through each of these language changes in great detail. You may prefer to skip ahead to the <a href=https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md#Examples>examples</a> to see what generic code written to this design will look like in practice.</p><h2 id=background>Background</h2><p>There have been many <a href=https://github.com/golang/go/wiki/ExperienceReports#generics>requests to add additional support for generic programming</a> in Go. There has been extensive discussion on <a href=https://golang.org/issue/15292>the issue tracker</a> and on <a href=https://docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4/view>a living document</a>.</p><p>This design suggests extending the Go language to add a form of parametric polymorphism, where the type parameters are bounded not by a declared subtyping relationship (as in some object oriented languages) but by explicitly defined structural constraints.</p><p>This version of the design has many similarities to a design draft presented on July 31, 2019, but contracts have been removed and replaced by interface types, and the syntax has changed.</p><p>There have been several proposals for adding type parameters, which can be found through the links above. Many of the ideas presented here have appeared before. The main new features described here are the syntax and the careful examination of interface types as constraints.</p><p>This design does not support template metaprogramming or any other form of compile time programming.</p><p>As the term <em>generic</em> is widely used in the Go community, we will use it below as a shorthand to mean a function or type that takes type parameters. Don&rsquo;t confuse the term generic as used in this design with the same term in other languages like C++, C#, Java, or Rust; they have similarities but are not the same.</p><h2 id=design>Design</h2><p>We will describe the complete design in stages based on simple examples.</p><h3 id=type-parameters>Type parameters</h3><p>Generic code is written using abstract data types that we call <em>type parameters</em>. When running the generic code, the type parameters are replaced by <em>type arguments</em>.</p><p>Here is a function that prints out each element of a slice, where the element type of the slice, here called <code>T</code>, is unknown. This is a trivial example of the kind of function we want to permit in order to support generic programming. (Later we&rsquo;ll also discuss <a href=https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md#Generic-types>generic types</a>).</p><pre tabindex=0><code>// Print prints the elements of a slice.
// It should be possible to call this with any slice value.
func Print(s []T) { // Just an example, not the suggested syntax.
	for _, v := range s {
		fmt.Println(v)
	}
}
</code></pre><p>With this approach, the first decision to make is: how should the type parameter <code>T</code> be declared? In a language like Go, we expect every identifier to be declared in some way.</p><p>Here we make a design decision: type parameters are similar to ordinary non-type function parameters, and as such should be listed along with other parameters. However, type parameters are not the same as non-type parameters, so although they appear in the list of parameters we want to distinguish them. That leads to our next design decision: we define an additional optional parameter list describing type parameters.</p><p>This type parameter list appears before the regular parameters. To distinguish the type parameter list from the regular parameter list, the type parameter list uses square brackets rather than parentheses. Just as regular parameters have types, type parameters have meta-types, also known as constraints. We will discuss the details of constraints later; for now, we will just note that <code>any</code> is a valid constraint, meaning that any type is permitted.</p><pre tabindex=0><code>// Print prints the elements of any slice.
// Print has a type parameter T and has a single (non-type)
// parameter s which is a slice of that type parameter.
func Print[T any](s []T) {
	// same as above
}
</code></pre><p>This says that within the function <code>Print</code> the identifier <code>T</code> is a type parameter, a type that is currently unknown but that will be known when the function is called. The <code>any</code> means that <code>T</code> can be any type at all. As seen above, the type parameter may be used as a type when describing the types of the ordinary non-type parameters. It may also be used as a type within the body of the function.</p><p>Unlike regular parameter lists, in type parameter lists names are required for the type parameters. This avoids a syntactic ambiguity, and, as it happens, there is no reason to ever omit the type parameter names.</p><p>Since <code>Print</code> has a type parameter, any call of <code>Print</code> must provide a type argument. Later we will see how this type argument can usually be deduced from the non-type argument, by using <a href=https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md#Type-inference>type inference</a>. For now, we&rsquo;ll pass the type argument explicitly. Type arguments are passed much like type parameters are declared: as a separate list of arguments. As with the type parameter list, the list of type arguments uses square brackets.</p><pre tabindex=0><code>	// Call Print with a []int.
	// Print has a type parameter T, and we want to pass a []int,
	// so we pass a type argument of int by writing Print[int].
	// The function Print[int] expects a []int as an argument.
	Print[int]([]int{1, 2, 3})

	// This will print:
	// 1
	// 2
	// 3
</code></pre><h3 id=constraints>Constraints</h3><p>Let‘s make our example slightly more complicated. Let’s turn it into a function that converts a slice of any type into a <code>[]string</code> by calling a <code>String</code> method on each element.</p><pre tabindex=0><code>// This function is INVALID.
func Stringify[T any](s []T) (ret []string) {
	for _, v := range s {
		ret = append(ret, v.String()) // INVALID
	}
	return ret
}
</code></pre><p>This might seem OK at first glance, but in this example <code>v</code> has type <code>T</code>, and <code>T</code> can be any type. This means that <code>T</code> need not have a <code>String</code> method. So the call to <code>v.String()</code> is invalid.</p><p>Naturally, the same issue arises in other languages that support generic programming. In C++, for example, a generic function (in C++ terms, a function template) can call any method on a value of generic type. That is, in the C++ approach, calling <code>v.String()</code> is fine. If the function is called with a type argument that does not have a <code>String</code> method, the error is reported when compiling the call to <code>v.String</code> with that type argument. These errors can be lengthy, as there may be several layers of generic function calls before the error occurs, all of which must be reported to understand what went wrong.</p><p>The C++ approach would be a poor choice for Go. One reason is the style of the language. In Go we don&rsquo;t refer to names, such as, in this case, <code>String</code>, and hope that they exist. Go resolves all names to their declarations when they are seen.</p><p>Another reason is that Go is designed to support programming at scale. We must consider the case in which the generic function definition (<code>Stringify</code>, above) and the call to the generic function (not shown, but perhaps in some other package) are far apart. In general, all generic code expects the type arguments to meet certain requirements. We refer to these requirements as <em>constraints</em> (other languages have similar ideas known as type bounds or trait bounds or concepts). In this case, the constraint is pretty obvious: the type has to have a <code>String() string</code> method. In other cases it may be much less obvious.</p><p>We don‘t want to derive the constraints from whatever <code>Stringify</code> happens to do (in this case, call the <code>String</code> method). If we did, a minor change to <code>Stringify</code> might change the constraints. That would mean that a minor change could cause code far away, that calls the function, to unexpectedly break. It’s fine for <code>Stringify</code> to deliberately change its constraints, and force callers to change. What we want to avoid is <code>Stringify</code> changing its constraints accidentally.</p><p>This means that the constraints must set limits on both the type arguments passed by the caller and the code in the generic function. The caller may only pass type arguments that satisfy the constraints. The generic function may only use those values in ways that are permitted by the constraints. This is an important rule that we believe should apply to any attempt to define generic programming in Go: generic code can only use operations that its type arguments are known to implement.</p><h3 id=operations-permitted-for-any-type>Operations permitted for any type</h3><p>Before we discuss constraints further, let&rsquo;s briefly note what happens when the constraint is <code>any</code>. If a generic function uses the <code>any</code> constraint for a type parameter, as is the case for the <code>Print</code> method above, then any type argument is permitted for that parameter. The only operations that the generic function can use with values of that type parameter are those operations that are permitted for values of any type. In the example above, the <code>Print</code> function declares a variable <code>v</code> whose type is the type parameter <code>T</code>, and it passes that variable to a function.</p><p>The operations permitted for any type are:</p><ul><li>declare variables of those types</li><li>assign other values of the same type to those variables</li><li>pass those variables to functions or return them from functions</li><li>take the address of those variables</li><li>convert or assign values of those types to the type <code>interface{}</code></li><li>convert a value of type <code>T</code> to type <code>T</code> (permitted but useless)</li><li>use a type assertion to convert an interface value to the type</li><li>use the type as a case in a type switch</li><li>define and use composite types that use those types, such as a slice of that type</li><li>pass the type to some predeclared functions such as <code>new</code></li></ul><p>It&rsquo;s possible that future language changes will add other such operations, though none are currently anticipated.</p><h3 id=defining-constraints>Defining constraints</h3><p>Go already has a construct that is close to what we need for a constraint: an interface type. An interface type is a set of methods. The only values that can be assigned to a variable of interface type are those whose types implement the same methods. The only operations that can be done with a value of interface type, other than operations permitted for any type, are to call the methods.</p><p>Calling a generic function with a type argument is similar to assigning to a variable of interface type: the type argument must implement the constraints of the type parameter. Writing a generic function is like using values of interface type: the generic code can only use the operations permitted by the constraint (or operations that are permitted for any type).</p><p>Therefore, in this design, constraints are simply interface types. Satisfying a constraint means implementing the interface type. (Later we&rsquo;ll restate this in order to define constraints for operations other than method calls, such as <a href=https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md#Operators>binary operators</a>).</p><p>For the <code>Stringify</code> example, we need an interface type with a <code>String</code> method that takes no arguments and returns a value of type <code>string</code>.</p><pre tabindex=0><code>// Stringer is a type constraint that requires the type argument to have
// a String method and permits the generic function to call String.
// The String method should return a string representation of the value.
type Stringer interface {
	String() string
}
</code></pre><p>(It doesn‘t matter for this discussion, but this defines the same interface as the standard library’s <code>fmt.Stringer</code> type, and real code would likely simply use <code>fmt.Stringer</code>.)</p><h3 id=the-any-constraint>The <code>any</code> constraint</h3><p>Now that we know that constraints are simply interface types, we can explain what <code>any</code> means as a constraint. As shown above, the <code>any</code> constraint permits any type as a type argument and only permits the function to use the operations permitted for any type. The interface type for that is the empty interface: <code>interface{}</code>. So we could write the <code>Print</code> example as</p><pre tabindex=0><code>// Print prints the elements of any slice.
// Print has a type parameter T and has a single (non-type)
// parameter s which is a slice of that type parameter.
func Print[T interface{}](s []T) {
	// same as above
}
</code></pre><p>However, it‘s tedious to have to write <code>interface{}</code> every time you write a generic function that doesn’t impose constraints on its type parameters. So in this design we suggest a type constraint <code>any</code> that is equivalent to <code>interface{}</code>. This will be a predeclared name, implicitly declared in the universe block. It will not be valid to use <code>any</code> as anything other than a type constraint.</p><p>(Note: clearly we could make <code>any</code> generally available as an alias for <code>interface{}</code>, or as a new defined type defined as <code>interface{}</code>. However, we don&rsquo;t want this design, which is about generics, to lead to a possibly significant change to non-generic code. Adding <code>any</code> as a general purpose name for <code>interface{}</code> can and should be <a href=https://golang.org/issue/33232>discussed separately</a>).</p><h3 id=using-a-constraint>Using a constraint</h3><p>For a generic function, a constraint can be thought of as the type of the type argument: a meta-type. As shown above, constraints appear in the type parameter list as the meta-type of a type parameter.</p><pre tabindex=0><code>// Stringify calls the String method on each element of s,
// and returns the results.
func Stringify[T Stringer](s []T) (ret []string) {
	for _, v := range s {
		ret = append(ret, v.String())
	}
	return ret
}
</code></pre><p>The single type parameter <code>T</code> is followed by the constraint that applies to <code>T</code>, in this case <code>Stringer</code>.</p><h3 id=multiple-type-parameters>Multiple type parameters</h3><p>Although the <code>Stringify</code> example uses only a single type parameter, functions may have multiple type parameters.</p><pre tabindex=0><code>// Print2 has two type parameters and two non-type parameters.
func Print2[T1, T2 any](s1 []T1, s2 []T2) { ... }
</code></pre><p>Compare this to</p><pre tabindex=0><code>// Print2Same has one type parameter and two non-type parameters.
func Print2Same[T any](s1 []T, s2 []T) { ... }
</code></pre><p>In <code>Print2</code> <code>s1</code> and <code>s2</code> may be slices of different types. In <code>Print2Same</code> <code>s1</code> and <code>s2</code> must be slices of the same element type.</p><p>Just as each ordinary parameter may have its own type, each type parameter may have its own constraint.</p><pre tabindex=0><code>// Stringer is a type constraint that requires a String method.
// The String method should return a string representation of the value.
type Stringer interface {
	String() string
}

// Plusser is a type constraint that requires a Plus method.
// The Plus method is expected to add the argument to an internal
// string and return the result.
type Plusser interface {
	Plus(string) string
}

// ConcatTo takes a slice of elements with a String method and a slice
// of elements with a Plus method. The slices should have the same
// number of elements. This will convert each element of s to a string,
// pass it to the Plus method of the corresponding element of p,
// and return a slice of the resulting strings.
func ConcatTo[S Stringer, P Plusser](s []S, p []P) []string {
	r := make([]string, len(s))
	for i, v := range s {
		r[i] = p[i].Plus(v.String())
	}
	return r
}
</code></pre><p>A single constraint can be used for multiple type parameters, just as a single type can be used for multiple non-type function parameters. The constraint applies to each type parameter separately.</p><pre tabindex=0><code>// Stringify2 converts two slices of different types to strings,
// and returns the concatenation of all the strings.
func Stringify2[T1, T2 Stringer](s1 []T1, s2 []T2) string {
	r := &#34;&#34;
	for _, v1 := range s1 {
		r += v1.String()
	}
	for _, v2 := range s2 {
		r += v2.String()
	}
	return r
}
</code></pre><h3 id=generic-types>Generic types</h3><p>We want more than just generic functions: we also want generic types. We suggest that types be extended to take type parameters.</p><pre tabindex=0><code>// Vector is a name for a slice of any element type.
type Vector[T any] []T
</code></pre><p>A type‘s type parameters are just like a function’s type parameters.</p><p>Within the type definition, the type parameters may be used like any other type.</p><p>To use a generic type, you must supply type arguments. This is called <em>instantiation</em>. The type arguments appear in square brackets, as usual. When we instantiate a type by supplying type arguments for the type parameters, we produce a type in which each use of a type parameter in the type definition is replaced by the corresponding type argument.</p><pre tabindex=0><code>// v is a Vector of int values.
//
// This is similar to pretending that &#34;Vector[int]&#34; is a valid identifier,
// and writing
//   type &#34;Vector[int]&#34; []int
//   var v &#34;Vector[int]&#34;
// All uses of Vector[int] will refer to the same &#34;Vector[int]&#34; type.
//
var v Vector[int]
</code></pre><p>Generic types can have methods. The receiver type of a method must declare the same number of type parameters as are declared in the receiver type&rsquo;s definition. They are declared without any constraint.</p><pre tabindex=0><code>// Push adds a value to the end of a vector.
func (v *Vector[T]) Push(x T) { *v = append(*v, x) }
</code></pre><p>The type parameters listed in a method declaration need not have the same names as the type parameters in the type declaration. In particular, if they are not used by the method, they can be <code>_</code>.</p><p>A generic type can refer to itself in cases where a type can ordinarily refer to itself, but when it does so the type arguments must be the type parameters, listed in the same order. This restriction prevents infinite recursion of type instantiation.</p><pre tabindex=0><code>// List is a linked list of values of type T.
type List[T any] struct {
	next *List[T] // this reference to List[T] is OK
	val  T
}

// This type is INVALID.
type P[T1, T2 any] struct {
	F *P[T2, T1] // INVALID; must be [T1, T2]
}
</code></pre><p>This restriction applies to both direct and indirect references.</p><pre tabindex=0><code>// ListHead is the head of a linked list.
type ListHead[T any] struct {
	head *ListElement[T]
}

// ListElement is an element in a linked list with a head.
// Each element points back to the head.
type ListElement[T any] struct {
	next *ListElement[T]
	val  T
	// Using ListHead[T] here is OK.
	// ListHead[T] refers to ListElement[T] refers to ListHead[T].
	// Using ListHead[int] would not be OK, as ListHead[T]
	// would have an indirect reference to ListHead[int].
	head *ListHead[T]
}
</code></pre><p>(Note: with more understanding of how people want to write code, it may be possible to relax this rule to permit some cases that use different type arguments.)</p><p>The type parameter of a generic type may have constraints other than <code>any</code>.</p><pre tabindex=0><code>// StringableVector is a slice of some type, where the type
// must have a String method.
type StringableVector[T Stringer] []T

func (s StringableVector[T]) String() string {
	var sb strings.Builder
	for i, v := range s {
		if i &gt; 0 {
			sb.WriteString(&#34;, &#34;)
		}
		// It&#39;s OK to call v.String here because v is of type T
		// and T&#39;s constraint is Stringer.
		sb.WriteString(v.String())
	}
	return sb.String()
}
</code></pre><h3 id=methods-may-not-take-additional-type-arguments>Methods may not take additional type arguments</h3><p>Although methods of a generic type may use the type&rsquo;s parameters, methods may not themselves have additional type parameters. Where it would be useful to add type arguments to a method, people will have to write a suitably parameterized top-level function.</p><p>There is more discussion of this in <a href=https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md#No-parameterized-methods>the issues section</a>.</p><h3 id=operators>Operators</h3><p>As we‘ve seen, we are using interface types as constraints. Interface types provide a set of methods, and nothing else. This means that with what we’ve seen so far, the only thing that generic functions can do with values of type parameters, other than operations that are permitted for any type, is call methods.</p><p>However, method calls are not sufficient for everything we want to express. Consider this simple function that returns the smallest element of a slice of values, where the slice is assumed to be non-empty.</p><pre tabindex=0><code>// This function is INVALID.
func Smallest[T any](s []T) T {
	r := s[0] // panic if slice is empty
	for _, v := range s[1:] {
		if v &lt; r { // INVALID
			r = v
		}
	}
	return r
}
</code></pre><p>Any reasonable generics implementation should let you write this function. The problem is the expression <code>v &lt; r</code>. This assumes that <code>T</code> supports the <code>&lt;</code> operator, but the constraint on <code>T</code> is simply <code>any</code>. With the <code>any</code> constraint the function <code>Smallest</code> can only use operations that are available for all types, but not all Go types support <code>&lt;</code>. Unfortunately, since <code>&lt;</code> is not a method, there is no obvious way to write a constraint—an interface type—that permits <code>&lt;</code>.</p><p>We need a way to write a constraint that accepts only types that support <code>&lt;</code>. In order to do that, we observe that, aside from two exceptions that we will discuss later, all the arithmetic, comparison, and logical operators defined by the language may only be used with types that are predeclared by the language, or with defined types whose underlying type is one of those predeclared types. That is, the operator <code>&lt;</code> can only be used with a predeclared type such as <code>int</code> or <code>float64</code>, or a defined type whose underlying type is one of those types. Go does not permit using <code>&lt;</code> with a composite type or with an arbitrary defined type.</p><p>This means that rather than try to write a constraint for <code>&lt;</code>, we can approach this the other way around: instead of saying which operators a constraint should support, we can say which types a constraint should accept. We do this by defining a <em>type set</em> for a constraint.</p><h4 id=type-sets>Type sets</h4><p>Although we are primarily interested in defining the type set of constraints, the most straightforward approach is to define the type set of all types. The type set of a constraint is then constructed out of the type sets of its elements. This may seem like a digression from the topic of using operators with parameterized types, but we&rsquo;ll get there in the end.</p><p>Every type has an associated type set. The type set of a non-interface type <code>T</code> is simply the set <code>{T}</code>: a set that contains just <code>T</code> itself. The type set of an ordinary interface type is the set of all types that declare all the methods of the interface.</p><p>Note that the type set of an ordinary interface type is an infinite set. For any given type <code>T</code> and interface type <code>IT</code> it&rsquo;s easy to tell whether <code>T</code> is in the type set of <code>IT</code> (by checking if all methods of <code>IT</code> are declared by <code>T</code>), but there is no reasonable way to enumerate all the types in the type set of <code>IT</code>. The type <code>IT</code> is a member of its own type set, because an interface inherently declares all of its own methods. The type set of the empty interface <code>interface{}</code> is the set of all possible types.</p><p>It will be useful to construct the type set of an interface type by looking at the elements of the interface. This will produce the same result in a different way. The elements of an interface can be either a method signature or an embedded interface type. Although a method signature is not a type, it&rsquo;s convenient to define a type set for it: the set of all types that declare that method. The type set of an embedded interface type <code>E</code> is simply that of <code>E</code>: the set of all types that declare all the methods of <code>E</code>.</p><p>For any method signature <code>M</code>, the type set of <code>interface{ M }</code> is the type of <code>M</code>: the set of all types that declare <code>M</code>. For any method signatures <code>M1</code> and <code>M2</code>, the type set of <code>interface{ M1; M2 }</code> is set of all types that declare both <code>M1</code> and <code>M2</code>. This is the intersection of the type set of <code>M1</code> and the type set of <code>M2</code>. To see this, observe that the type set of <code>M1</code> is the set of all types with a method <code>M1</code>, and similarly for <code>M2</code>. If we take the intersection of those two type sets, the result is the set of all types that declare both <code>M1</code> and <code>M2</code>. That is exactly the type set of <code>interface{ M1; M2 }</code>.</p><p>The same applies to embedded interface types. For any two interface types <code>E1</code> and <code>E2</code>, the type set of <code>interface{ E1; E2 }</code> is the intersection of the type sets of <code>E1</code> and <code>E2</code>.</p><p>Therefore, the type set of an interface type is the intersection of the type sets of the element of the interface.</p><h4 id=type-sets-of-constraints>Type sets of constraints</h4><p>Now that we have described the type set of an interface type, we will redefine what it means to satisfy the constraint. Earlier we said that a type argument satisfies a constraint if it implements the constraint. Now we will say that a type argument satisfies a constraint if it is a member of the constraint&rsquo;s type set.</p><p>For an ordinary interface type, one whose only elements are method signatures and embedded ordinary interface types, the meaning is exactly the same: the set of types that implement the interface type is exactly the set of types that are in its type set.</p><p>We will now proceed to define additional elements that may appear in an interface type that is used as a constraint, and define how those additional elements can be used to further control the type set of the constraint.</p><h4 id=constraint-elements>Constraint elements</h4><p>The elements of an ordinary interface type are method signatures and embedded interface types. We propose permitting three additional elements that may be used in an interface type used as a constraint. If any of these additional elements are used, the interface type may not be used as an ordinary type, but may only be used as a constraint.</p><h5 id=arbitrary-type-constraint-element>Arbitrary type constraint element</h5><p>The first new element is to simply permit listing any type, not just an interface type. For example: <code>type Integer interface{ int }</code>. When a non-interface type <code>T</code> is listed as an element of a constraint, its type set is simply <code>{T}</code>. The type set of <code>int</code> is <code>{int}</code>. Since the type set of a constraint is the intersection of the type sets of all elements, the type set of <code>Integer</code> is also <code>{int}</code>. This constraint <code>Integer</code> can be satisfied by any type that is a member of the set <code>{int}</code>. There is exactly one such type: <code>int</code>.</p><p>The type may be a type literal that refers to a type parameter (or more than one), but it may not be a plain type parameter.</p><pre tabindex=0><code>// EmbeddedParameter is INVALID.
type EmbeddedParameter[T any] interface {
	T // INVALID: may not list a plain type parameter
}
</code></pre><h5 id=approximation-constraint-element>Approximation constraint element</h5><p>Listing a single type is useless by itself. For constraint satisfaction, we want to be able to say not just <code>int</code>, but “any type whose underlying type is <code>int</code>”. Consider the <code>Smallest</code> example above. We want it to work not just for slices of the predeclared ordered types, but also for types defined by a program. If a program uses <code>type MyString string</code>, the program can use the <code>&lt;</code> operator with values of type <code>MyString</code>. It should be possible to instantiate <code>Smallest</code> with the type <code>MyString</code>.</p><p>To support this, the second new element we permit in a constraint is a new syntactic construct: an approximation element, written as <code>~T</code>. The type set of <code>~T</code> is the set of all types whose underlying type is <code>T</code>.</p><p>For example: <code>type AnyString interface{ ~string }</code>. The type set of <code>~string</code>, and therefore the type set of <code>AnyString</code>, is the set of all types whose underlying type is <code>string</code>. That includes the type <code>MyString</code>; <code>MyString</code> used as a type argument will satisfy the constraint <code>AnyString</code>.</p><p>This new <code>~T</code> syntax will be the first use of <code>~</code> as a token in Go.</p><p>Since <code>~T</code> means the set of all types whose underlying type is <code>T</code>, it will be an error to use <code>~T</code> with a type <code>T</code> whose underlying type is not itself. Types whose underlying types are themselves are:</p><ol><li>Type literals, such as <code>[]byte</code> or <code>struct{ f int }</code>.</li><li>Most predeclared types, such as <code>int</code> or <code>string</code> (but not <code>error</code>).</li></ol><p>Using <code>~T</code> is not permitted if <code>T</code> is a type parameter or if <code>T</code> is an interface type.</p><pre tabindex=0><code>type MyString string

// AnyString matches any type whose underlying type is string.
// This includes, among others, the type string itself, and
// the type MyString.
type AnyString interface {
	~string
}

// ApproximateMyString is INVALID.
type ApproximateMyString interface {
	~MyString // INVALID: underlying type of MyString is not MyString
}

// ApproximateParameter is INVALID.
type ApproximateParameter[T any] interface {
	~T // INVALID: T is a type parameter
}
</code></pre><h5 id=union-constraint-element>Union constraint element</h5><p>The third new element we permit in a constraint is also a new syntactic construct: a union element, written as a series of constraint elements separated by vertical bars (<code>|</code>). For example: <code>int | float32</code> or <code>~int8 | ~int16 | ~int32 | ~int64</code>. The type set of a union element is the union of the type sets of each element in the sequence. The elements listed in a union must all be different. For example:</p><pre tabindex=0><code>// PredeclaredSignedInteger is a constraint that matches the
// five predeclared signed integer types.
type PredeclaredSignedInteger interface {
	int | int8 | int16 | int32 | int64
}
</code></pre><p>The type set of this union element is the set <code>{int, int8, int16, int32, int64}</code>. Since the union is the only element of <code>PredeclaredSignedInteger</code>, that is also the type set of <code>PredeclaredSignedInteger</code>. This constraint can be satisfied by any of those five types.</p><p>Here is an example using approximation elements:</p><pre tabindex=0><code>// SignedInteger is a constraint that matches any signed integer type.
type SignedInteger interface {
	~int | ~int8 | ~int16 | ~int32 | ~int64
}
</code></pre><p>The type set of this constraint is the set of all types whose underlying type is one of <code>int</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, or <code>int64</code>. Any of those types will satisfy this constraint.</p><p>The new constraint element syntax is</p><pre tabindex=0><code>InterfaceType  = &#34;interface&#34; &#34;{&#34; {(MethodSpec | InterfaceTypeName | ConstraintElem) &#34;;&#34; } &#34;}&#34; .
ConstraintElem = ConstraintTerm { &#34;|&#34; ConstraintTerm } .
ConstraintTerm = [&#34;~&#34;] Type .
</code></pre><h4 id=operations-based-on-type-sets>Operations based on type sets</h4><p>The purpose of type sets is to permit generic functions to use operators, such as <code>&lt;</code>, with values whose type is a type parameter.</p><p>The rule is that a generic function may use a value whose type is a type parameter in any way that is permitted by every member of the type set of the parameter‘s constraint. This applies to operators like ‘&lt;’ or ‘+’ or other general operators. For special purpose operators like <code>range</code> loops, we permit their use if the type parameter has a structural constraint, as <a href=https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md#Constraint-type-inference>defined later</a>; the definition here is basically that the constraint has a single underlying type. If the function can be compiled successfully using each type in the constraint’s type set, or when applicable using the structural type, then the use is permitted.</p><p>For the <code>Smallest</code> example shown earlier, we could use a constraint like this:</p><pre tabindex=0><code>package constraints

// Ordered is a type constraint that matches any ordered type.
// An ordered type is one that supports the &lt;, &lt;=, &gt;, and &gt;= operators.
type Ordered interface {
	~int | ~int8 | ~int16 | ~int32 | ~int64 |
		~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr |
		~float32 | ~float64 |
		~string
}
</code></pre><p>In practice this constraint would likely be defined and exported in a new standard library package, <code>constraints</code>, so that it could be used by function and type definitions.</p><p>Given that constraint, we can write this function, now valid:</p><pre tabindex=0><code>// Smallest returns the smallest element in a slice.
// It panics if the slice is empty.
func Smallest[T constraints.Ordered](s []T) T {
	r := s[0] // panics if slice is empty
	for _, v := range s[1:] {
		if v &lt; r {
			r = v
		}
	}
	return r
}
</code></pre><h4 id=comparable-types-in-constraints>Comparable types in constraints</h4><p>Earlier we mentioned that there are two exceptions to the rule that operators may only be used with types that are predeclared by the language. The exceptions are <code>==</code> and <code>!=</code>, which are permitted for struct, array, and interface types. These are useful enough that we want to be able to write a constraint that accepts any comparable type.</p><p>To do this we introduce a new predeclared type constraint: <code>comparable</code>. The type set of the <code>comparable</code> constraint is the set of all comparable types. This permits the use of <code>==</code> and <code>!=</code> with values of that type parameter.</p><p>For example, this function may be instantiated with any comparable type:</p><pre tabindex=0><code>// Index returns the index of x in s, or -1 if not found.
func Index[T comparable](s []T, x T) int {
	for i, v := range s {
		// v and x are type T, which has the comparable
		// constraint, so we can use == here.
		if v == x {
			return i
		}
	}
	return -1
}
</code></pre><p>Since <code>comparable</code> is a constraint, it can be embedded in another interface type used as a constraint.</p><pre tabindex=0><code>// ComparableHasher is a type constraint that matches all
// comparable types with a Hash method.
type ComparableHasher interface {
	comparable
	Hash() uintptr
}
</code></pre><p>The constraint <code>ComparableHasher</code> is implemented by any type that is comparable and also has a <code>Hash() uintptr</code> method. A generic function that uses <code>ComparableHasher</code> as a constraint can compare values of that type and can call the <code>Hash</code> method.</p><p>It&rsquo;s possible to use <code>comparable</code> to produce a constraint that can not be satisfied by any type. See also the <a href=https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md#Empty-type-sets>discussion of empty type sets below</a>.</p><pre tabindex=0><code>// ImpossibleConstraint is a type constraint that no type can satisfy,
// because slice types are not comparable.
type ImpossibleConstraint interface {
	comparable
	[]int
}
</code></pre><h3 id=mutually-referencing-type-parameters>Mutually referencing type parameters</h3><p>Within a single type parameter list, constraints may refer to any of the other type parameters, even ones that are declared later in the same list. (The scope of a type parameter starts at the beginning of the type parameter list and extends to the end of the enclosing function or type declaration.)</p><p>For example, consider a generic graph package that contains generic algorithms that work with graphs. The algorithms use two types, <code>Node</code> and <code>Edge</code>. <code>Node</code> is expected to have a method <code>Edges() []Edge</code>. <code>Edge</code> is expected to have a method <code>Nodes() (Node, Node)</code>. A graph can be represented as a <code>[]Node</code>.</p><p>This simple representation is enough to implement graph algorithms like finding the shortest path.</p><pre tabindex=0><code>package graph

// NodeConstraint is the type constraint for graph nodes:
// they must have an Edges method that returns the Edge&#39;s
// that connect to this Node.
type NodeConstraint[Edge any] interface {
	Edges() []Edge
}

// EdgeConstraint is the type constraint for graph edges:
// they must have a Nodes method that returns the two Nodes
// that this edge connects.
type EdgeConstraint[Node any] interface {
	Nodes() (from, to Node)
}

// Graph is a graph composed of nodes and edges.
type Graph[Node NodeConstraint[Edge], Edge EdgeConstraint[Node]] struct { ... }

// New returns a new graph given a list of nodes.
func New[Node NodeConstraint[Edge], Edge EdgeConstraint[Node]] (nodes []Node) *Graph[Node, Edge] {
	...
}

// ShortestPath returns the shortest path between two nodes,
// as a list of edges.
func (g *Graph[Node, Edge]) ShortestPath(from, to Node) []Edge { ... }
</code></pre><p>There are a lot of type arguments and instantiations here. In the constraint on <code>Node</code> in <code>Graph</code>, the <code>Edge</code> being passed to the type constraint <code>NodeConstraint</code> is the second type parameter of <code>Graph</code>. This instantiates <code>NodeConstraint</code> with the type parameter <code>Edge</code>, so we see that <code>Node</code> must have a method <code>Edges</code> that returns a slice of <code>Edge</code>, which is what we want. The same applies to the constraint on <code>Edge</code>, and the same type parameters and constraints are repeated for the function <code>New</code>. We aren&rsquo;t claiming that this is simple, but we are claiming that it is possible.</p><p>It‘s worth noting that while at first glance this may look like a typical use of interface types, <code>Node</code> and <code>Edge</code> are non-interface types with specific methods. In order to use <code>graph.Graph</code>, the type arguments used for <code>Node</code> and <code>Edge</code> have to define methods that follow a certain pattern, but they don’t have to actually use interface types to do so. In particular, the methods do not return interface types.</p><p>For example, consider these type definitions in some other package:</p><pre tabindex=0><code>// Vertex is a node in a graph.
type Vertex struct { ... }

// Edges returns the edges connected to v.
func (v *Vertex) Edges() []*FromTo { ... }

// FromTo is an edge in a graph.
type FromTo struct { ... }

// Nodes returns the nodes that ft connects.
func (ft *FromTo) Nodes() (*Vertex, *Vertex) { ... }
</code></pre><p>There are no interface types here, but we can instantiate <code>graph.Graph</code> using the type arguments <code>*Vertex</code> and <code>*FromTo</code>.</p><pre tabindex=0><code>var g = graph.New[*Vertex, *FromTo]([]*Vertex{ ... })
</code></pre><p><code>*Vertex</code> and <code>*FromTo</code> are not interface types, but when used together they define methods that implement the constraints of <code>graph.Graph</code>. Note that we couldn&rsquo;t pass plain <code>Vertex</code> or <code>FromTo</code> to <code>graph.New</code>, since <code>Vertex</code> and <code>FromTo</code> do not implement the constraints. The <code>Edges</code> and <code>Nodes</code> methods are defined on the pointer types <code>*Vertex</code> and <code>*FromTo</code>; the types <code>Vertex</code> and <code>FromTo</code> do not have any methods.</p><p>When we use a generic interface type as a constraint, we first instantiate the type with the type argument(s) supplied in the type parameter list, and then compare the corresponding type argument against the instantiated constraint. In this example, the <code>Node</code> type argument to <code>graph.New</code> has a constraint <code>NodeConstraint[Edge]</code>. When we call <code>graph.New</code> with a <code>Node</code> type argument of <code>*Vertex</code> and an <code>Edge</code> type argument of <code>*FromTo</code>, in order to check the constraint on <code>Node</code> the compiler instantiates <code>NodeConstraint</code> with the type argument <code>*FromTo</code>. That produces an instantiated constraint, in this case a requirement that <code>Node</code> have a method <code>Edges() []*FromTo</code>, and the compiler verifies that <code>*Vertex</code> satisfies that constraint.</p><p>Although <code>Node</code> and <code>Edge</code> do not have to be instantiated with interface types, it is also OK to use interface types if you like.</p><pre tabindex=0><code>type NodeInterface interface { Edges() []EdgeInterface }
type EdgeInterface interface { Nodes() (NodeInterface, NodeInterface) }
</code></pre><p>We could instantiate <code>graph.Graph</code> with the types <code>NodeInterface</code> and <code>EdgeInterface</code>, since they implement the type constraints. There isn&rsquo;t much reason to instantiate a type this way, but it is permitted.</p><p>This ability for type parameters to refer to other type parameters illustrates an important point: it should be a requirement for any attempt to add generics to Go that it be possible to instantiate generic code with multiple type arguments that refer to each other in ways that the compiler can check.</p><h3 id=type-inference>Type inference</h3><p>In many cases we can use type inference to avoid having to explicitly write out some or all of the type arguments. We can use <em>function argument type inference</em> for a function call to deduce type arguments from the types of the non-type arguments. We can use <em>constraint type inference</em> to deduce unknown type arguments from known type arguments.</p><p>In the examples above, when instantiating a generic function or type, we always specified type arguments for all the type parameters. We also permit specifying just some of the type arguments, or omitting the type arguments entirely, when the missing type arguments can be inferred. When only some type arguments are passed, they are the arguments for the first type parameters in the list.</p><p>For example, a function like this:</p><pre tabindex=0><code>func Map[F, T any](s []F, f func(F) T) []T { ... }
</code></pre><p>can be called in these ways. (We&rsquo;ll explain below how type inference works in detail; this example is to show how an incomplete list of type arguments is handled.)</p><pre tabindex=0><code>	var s []int
	f := func(i int) int64 { return int64(i) }
	var r []int64
	// Specify both type arguments explicitly.
	r = Map[int, int64](s, f)
	// Specify just the first type argument, for F,
	// and let T be inferred.
	r = Map[int](s, f)
	// Don&#39;t specify any type arguments, and let both be inferred.
	r = Map(s, f)
</code></pre><p>If a generic function or type is used without specifying all the type arguments, it is an error if any of the unspecified type arguments cannot be inferred.</p><p>(Note: type inference is a convenience feature. Although we think it is an important feature, it does not add any functionality to the design, only convenience in using it. It would be possible to omit it from the initial implementation, and see whether it seems to be needed. That said, this feature doesn&rsquo;t require additional syntax, and produces more readable code.)</p><h4 id=type-unification>Type unification</h4><p>Type inference is based on <em>type unification</em>. Type unification applies to two types, either or both of which may be or contain type parameters.</p><p>Type unification works by comparing the structure of the types. Their structure disregarding type parameters must be identical, and types other than type parameters must be equivalent. A type parameter in one type may match any complete subtype in the other type. If the structure differs, or types other than type parameters are not equivalent, then type unification fails. A successful type unification provides a list of associations of type parameters with other types (which may themselves be or contain type parameters).</p><p>For type unification, two types that don‘t contain any type parameters are equivalent if they are <a href=https://golang.org/ref/spec#Type_identity>identical</a>, or if they are channel types that are identical ignoring channel direction, or if their underlying types are equivalent. It’s OK to permit types to not be identical during type inference, because we will still check the constraints if inference succeeds, and we will still check that the function arguments are assignable to the inferred types.</p><p>For example, if <code>T1</code> and <code>T2</code> are type parameters, <code>[]map[int]bool</code> can be unified with any of the following:</p><ul><li><code>[]map[int]bool</code></li><li><code>T1</code> (<code>T1</code> matches <code>[]map[int]bool</code>)</li><li><code>[]T1</code> (<code>T1</code> matches <code>map[int]bool</code>)</li><li><code>[]map[T1]T2</code> (<code>T1</code> matches <code>int</code>, <code>T2</code> matches <code>bool</code>)</li></ul><p>(This is not an exclusive list, there are other possible successful unifications.)</p><p>On the other hand, <code>[]map[int]bool</code> cannot be unified with any of</p><ul><li><code>int</code></li><li><code>struct{}</code></li><li><code>[]struct{}</code></li><li><code>[]map[T1]string</code></li></ul><p>(This list is of course also not exclusive; there are an infinite number of types that cannot be successfully unified.)</p><p>In general we can also have type parameters on both sides, so in some cases we might associate <code>T1</code> with, for example, <code>T2</code>, or <code>[]T2</code>.</p><h4 id=function-argument-type-inference>Function argument type inference</h4><p>Function argument type inference is used with a function call to infer type arguments from non-type arguments. Function argument type inference is not used when a type is instantiated, and it is not used when a function is instantiated but not called.</p><p>To see how it works, let&rsquo;s go back to <a href=https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md#Type-parameters>the example</a> of a call to the simple <code>Print</code> function:</p><pre tabindex=0><code>	Print[int]([]int{1, 2, 3})
</code></pre><p>The type argument <code>int</code> in this function call can be inferred from the type of the non-type argument.</p><p>The only type arguments that can be inferred are those that are used for the types of the function‘s (non-type) input parameters. If there are some type parameters that are used only for the function’s result parameter types, or only in the body of the function, then those type arguments cannot be inferred using function argument type inference.</p><p>To infer function type arguments, we unify the types of the function call arguments with the types of the function‘s non-type parameters. On the caller side we have the list of types of the actual (non-type) arguments, which for the <code>Print</code> example is simply <code>[]int</code>. On the function side is the list of the types of the function’s non-type parameters, which for <code>Print</code> is <code>[]T</code>. In the lists, we discard respective arguments for which the function side does not use a type parameter. We must then apply type unification to the remaining argument types.</p><p>Function argument type inference is a two-pass algorithm. In the first pass, we ignore untyped constants on the caller side and their corresponding types in the function definition. We use two passes so that in some cases later arguments can determine the type of an untyped constant.</p><p>We unify corresponding types in the lists. This will give us an association of type parameters on the function side to types on the caller side. If the same type parameter appears more than once on the function side, it will match multiple argument types on the caller side. If those caller types are not equivalent, we report an error.</p><p>After the first pass, we check any untyped constants on the caller side. If there are no untyped constants, or if the type parameters in the corresponding function types have matched other input types, then type unification is complete.</p><p>Otherwise, for the second pass, for any untyped constants whose corresponding function types are not yet set, we determine the default type of the untyped constant in <a href=https://golang.org/ref/spec#Constants>the usual way</a>. Then we unify the remaining types again, this time with no untyped constants.</p><p>When constraint type inference is possible, as described below, it is applied between the two passes.</p><p>In this example</p><pre tabindex=0><code>	s1 := []int{1, 2, 3}
	Print(s1)
</code></pre><p>we compare <code>[]int</code> with <code>[]T</code>, match <code>T</code> with <code>int</code>, and we are done. The single type parameter <code>T</code> is <code>int</code>, so we infer that the call to <code>Print</code> is really a call to <code>Print[int]</code>.</p><p>For a more complex example, consider</p><pre tabindex=0><code>// Map calls the function f on every element of the slice s,
// returning a new slice of the results.
func Map[F, T any](s []F, f func(F) T) []T {
	r := make([]T, len(s))
	for i, v := range s {
		r[i] = f(v)
	}
	return r
}
</code></pre><p>The two type parameters <code>F</code> and <code>T</code> are both used for input parameters, so function argument type inference is possible. In the call</p><pre tabindex=0><code>	strs := Map([]int{1, 2, 3}, strconv.Itoa)
</code></pre><p>we unify <code>[]int</code> with <code>[]F</code>, matching <code>F</code> with <code>int</code>. We unify the type of <code>strconv.Itoa</code>, which is <code>func(int) string</code>, with <code>func(F) T</code>, matching <code>F</code> with <code>int</code> and <code>T</code> with <code>string</code>. The type parameter <code>F</code> is matched twice, both times with <code>int</code>. Unification succeeds, so the call written as <code>Map</code> is a call of <code>Map[int, string]</code>.</p><p>To see the untyped constant rule in effect, consider:</p><pre tabindex=0><code>// NewPair returns a pair of values of the same type.
func NewPair[F any](f1, f2 F) *Pair[F] { ... }
</code></pre><p>In the call <code>NewPair(1, 2)</code> both arguments are untyped constants, so both are ignored in the first pass. There is nothing to unify. We still have two untyped constants after the first pass. Both are set to their default type, <code>int</code>. The second run of the type unification pass unifies <code>F</code> with <code>int</code>, so the final call is <code>NewPair[int](1, 2)</code>.</p><p>In the call <code>NewPair(1, int64(2))</code> the first argument is an untyped constant, so we ignore it in the first pass. We then unify <code>int64</code> with <code>F</code>. At this point the type parameter corresponding to the untyped constant is fully determined, so the final call is <code>NewPair[int64](1, int64(2))</code>.</p><p>In the call <code>NewPair(1, 2.5)</code> both arguments are untyped constants, so we move on the second pass. This time we set the first constant to <code>int</code> and the second to <code>float64</code>. We then try to unify <code>F</code> with both <code>int</code> and <code>float64</code>, so unification fails, and we report a compilation error.</p><p>As mentioned earlier, function argument type inference is done without regard to constraints. First we use function argument type inference to determine type arguments to use for the function, and then, if that succeeds, we check whether those type arguments implement the constraints (if any).</p><p>Note that after successful function argument type inference, the compiler must still check that the arguments can be assigned to the parameters, as for any function call.</p><h4 id=constraint-type-inference>Constraint type inference</h4><p>Constraint type inference permits inferring a type argument from another type argument, based on type parameter constraints. Constraint type inference is useful when a function wants to have a type name for an element of some other type parameter, or when a function wants to apply a constraint to a type that is based on some other type parameter.</p><p>Constraint type inference can only infer types if some type parameter has a constraint that has a type set with exactly one type in it, or a type set for which the underlying type of every type in the type set is the same type. The two cases are slightly different, as in the first case, in which the type set has exactly one type, the single type need not be its own underlying type. Either way, the single type is called a <em>structural type</em>, and the constraint is called a <em>structural constraint</em>. The structural type describes the required structure of the type parameter. A structural constraint may also define methods, but the methods are ignored by constraint type inference. For constraint type inference to be useful, the structural type will normally be defined using one or more type parameters.</p><p>Constraint type inference is only tried if there is at least one type parameter whose type argument is not yet known.</p><p>While the algorithm we describe here may seem complex, for typical concrete examples it is straightforward to see what constraint type inference will deduce. The description of the algorithm is followed by a couple of examples.</p><p>We start by creating a mapping from type parameters to type arguments. We initialize the mapping with all type parameters whose type arguments are already known, if any.</p><p>For each type parameter with a structural constraint, we unify the type parameter with the structural type. This will have the effect of associating the type parameter with its constraint. We add the result into the mapping we are maintaining. If unification finds any associations of type parameters, we add those to the mapping as well. When we find multiple associations of any one type parameter, we unify each such association to produce a single mapping entry. If a type parameter is associated directly with another type parameter, meaning that they must both be matched with the same type, we unify the associations of each parameter together. If any of these various unifications fail, then constraint type inference fails.</p><p>After merging all type parameters with structural constraints, we have a mapping of various type parameters to types (which may be or contain other type parameters). We continue by looking for a type parameter <code>T</code> that is mapped to a fully known type argument <code>A</code>, one that does not contain any type parameters. Anywhere that <code>T</code> appears in a type argument in the mapping, we replace <code>T</code> with <code>A</code>. We repeat this process until we have replaced every type parameter.</p><p>When constraint type inference is possible, type inference proceeds as followed:</p><ul><li>Build the mapping using known type arguments.</li><li>Apply constraint type inference.</li><li>Apply function type inference using typed arguments.</li><li>Apply constraint type inference again.</li><li>Apply function type inference using the default types of any remaining untyped arguments.</li><li>Apply constraint type inference again.</li></ul><h5 id=element-constraint-example>Element constraint example</h5><p>For an example of where constraint type inference is useful, let&rsquo;s consider a function that takes a defined type that is a slice of numbers, and returns an instance of that same defined type in which each number is doubled.</p><p>It&rsquo;s easy to write a function similar to this if we ignore the <a href=https://golang.org/ref/spec#Type_definitions>defined type</a> requirement.</p><pre tabindex=0><code>// Double returns a new slice that contains all the elements of s, doubled.
func Double[E constraints.Integer](s []E) []E {
	r := make([]E, len(s))
	for i, v := range s {
		r[i] = v + v
	}
	return r
}
</code></pre><p>However, with that definition, if we call the function with a defined slice type, the result will not be that defined type.</p><pre tabindex=0><code>// MySlice is a slice of ints.
type MySlice []int

// The type of V1 will be []int, not MySlice.
// Here we are using function argument type inference,
// but not constraint type inference.
var V1 = Double(MySlice{1})
</code></pre><p>We can do what we want by introducing a new type parameter.</p><pre tabindex=0><code>// DoubleDefined returns a new slice that contains the elements of s,
// doubled, and also has the same type as s.
func DoubleDefined[S ~[]E, E constraints.Integer](s S) S {
	// Note that here we pass S to make, where above we passed []E.
	r := make(S, len(s))
	for i, v := range s {
		r[i] = v + v
	}
	return r
}
</code></pre><p>Now if we use explicit type arguments, we can get the right type.</p><pre tabindex=0><code>// The type of V2 will be MySlice.
var V2 = DoubleDefined[MySlice, int](MySlice{1})
</code></pre><p>Function argument type inference by itself is not enough to infer the type arguments here, because the type parameter E is not used for any input parameter. But a combination of function argument type inference and constraint type inference works.</p><pre tabindex=0><code>// The type of V3 will be MySlice.
var V3 = DoubleDefined(MySlice{1})
</code></pre><p>First we apply function argument type inference. We see that the type of the argument is <code>MySlice</code>. Function argument type inference matches the type parameter <code>S</code> with <code>MySlice</code>.</p><p>We then move on to constraint type inference. We know one type argument, <code>S</code>. We see that the type argument <code>S</code> has a structural type constraint.</p><p>We create a mapping of known type arguments:</p><pre tabindex=0><code>{S -&gt; MySlice}
</code></pre><p>We then unify each type parameter with a structural constraint with the single type in that constraint&rsquo;s type set. In this case the structural constraint is <code>~[]E</code> which has the structural type <code>[]E</code>, so we unify <code>S</code> with <code>[]E</code>. Since we already have a mapping for <code>S</code>, we then unify <code>[]E</code> with <code>MySlice</code>. As <code>MySlice</code> is defined as <code>[]int</code>, that associates <code>E</code> with <code>int</code>. We now have:</p><pre tabindex=0><code>{S -&gt; MySlice, E -&gt; int}
</code></pre><p>We then substitute <code>E</code> with <code>int</code>, which changes nothing, and we are done. The type arguments for this call to <code>DoubleDefined</code> are <code>[MySlice, int]</code>.</p><p>This example shows how we can use constraint type inference to set a type name for an element of some other type parameter. In this case we can name the element type of <code>S</code> as <code>E</code>, and we can then apply further constraints to <code>E</code>, in this case requiring that it be a number.</p><h5 id=pointer-method-example>Pointer method example</h5><p>Consider this example of a function that expects a type <code>T</code> that has a <code>Set(string)</code> method that initializes a value based on a string.</p><pre tabindex=0><code>// Setter is a type constraint that requires that the type
// implement a Set method that sets the value from a string.
type Setter interface {
	Set(string)
}

// FromStrings takes a slice of strings and returns a slice of T,
// calling the Set method to set each returned value.
//
// Note that because T is only used for a result parameter,
// function argument type inference does not work when calling
// this function.
func FromStrings[T Setter](s []string) []T {
	result := make([]T, len(s))
	for i, v := range s {
		result[i].Set(v)
	}
	return result
}
</code></pre><p>Now let&rsquo;s see some calling code (this example is invalid).</p><pre tabindex=0><code>// Settable is an integer type that can be set from a string.
type Settable int

// Set sets the value of *p from a string.
func (p *Settable) Set(s string) {
	i, _ := strconv.Atoi(s) // real code should not ignore the error
	*p = Settable(i)
}

func F() {
	// INVALID
	nums := FromStrings[Settable]([]string{&#34;1&#34;, &#34;2&#34;})
	// Here we want nums to be []Settable{1, 2}.
	...
}
</code></pre><p>The goal is to use <code>FromStrings</code> to get a slice of type <code>[]Settable</code>. Unfortunately, this example is not valid and will not compile.</p><p>The problem is that <code>FromStrings</code> requires a type that has a <code>Set(string)</code> method. The function <code>F</code> is trying to instantiate <code>FromStrings</code> with <code>Settable</code>, but <code>Settable</code> does not have a <code>Set</code> method. The type that has a <code>Set</code> method is <code>*Settable</code>.</p><p>So let&rsquo;s rewrite <code>F</code> to use <code>*Settable</code> instead.</p><pre tabindex=0><code>func F() {
	// Compiles but does not work as desired.
	// This will panic at run time when calling the Set method.
	nums := FromStrings[*Settable]([]string{&#34;1&#34;, &#34;2&#34;})
	...
}
</code></pre><p>This compiles but unfortunately it will panic at run time. The problem is that <code>FromStrings</code> creates a slice of type <code>[]T</code>. When instantiated with <code>*Settable</code>, that means a slice of type <code>[]*Settable</code>. When <code>FromStrings</code> calls <code>result[i].Set(v)</code>, that invokes the <code>Set</code> method on the pointer stored in <code>result[i]</code>. That pointer is <code>nil</code>. The <code>Settable.Set</code> method will be invoked with a <code>nil</code> receiver, and will raise a panic due to a <code>nil</code> dereference error.</p><p>The pointer type <code>*Settable</code> implements the constraint, but the code really wants to use the non-pointer type<code>Settable</code>. What we need is a way to write <code>FromStrings</code> such that it can take the type <code>Settable</code> as an argument but invoke a pointer method. To repeat, we can‘t use <code>Settable</code> because it doesn’t have a <code>Set</code> method, and we can‘t use <code>*Settable</code> because then we can’t create a slice of type <code>Settable</code>.</p><p>What we can do is pass both types.</p><pre tabindex=0><code>// Setter2 is a type constraint that requires that the type
// implement a Set method that sets the value from a string,
// and also requires that the type be a pointer to its type parameter.
type Setter2[B any] interface {
	Set(string)
	*B // non-interface type constraint element
}

// FromStrings2 takes a slice of strings and returns a slice of T,
// calling the Set method to set each returned value.
//
// We use two different type parameters so that we can return
// a slice of type T but call methods on *T aka PT.
// The Setter2 constraint ensures that PT is a pointer to T.
func FromStrings2[T any, PT Setter2[T]](s []string) []T {
	result := make([]T, len(s))
	for i, v := range s {
		// The type of &amp;result[i] is *T which is in the type set
		// of Setter2, so we can convert it to PT.
		p := PT(&amp;result[i])
		// PT has a Set method.
		p.Set(v)
	}
	return result
}
</code></pre><p>We can then call <code>FromStrings2</code> like this:</p><pre tabindex=0><code>func F2() {
	// FromStrings2 takes two type parameters.
	// The second parameter must be a pointer to the first.
	// Settable is as above.
	nums := FromStrings2[Settable, *Settable]([]string{&#34;1&#34;, &#34;2&#34;})
	// Now nums is []Settable{1, 2}.
	...
}
</code></pre><p>This approach works as expected, but it is awkward to have to repeat <code>Settable</code> in the type arguments. Fortunately, constraint type inference makes it less awkward. Using constraint type inference we can write</p><pre tabindex=0><code>func F3() {
	// Here we just pass one type argument.
	nums := FromStrings2[Settable]([]string{&#34;1&#34;, &#34;2&#34;})
	// Now nums is []Settable{1, 2}.
	...
}
</code></pre><p>There is no way to avoid passing the type argument <code>Settable</code>. But given that type argument, constraint type inference can infer the type argument <code>*Settable</code> for the type parameter <code>PT</code>.</p><p>As before, we create a mapping of known type arguments:</p><pre tabindex=0><code>{T -&gt; Settable}
</code></pre><p>We then unify each type parameter with a structural constraint. In this case, we unify <code>PT</code> with the single type of <code>Setter2[T]</code>, which is <code>*T</code>. The mapping is now</p><pre tabindex=0><code>{T -&gt; Settable, PT -&gt; *T}
</code></pre><p>We then replace <code>T</code> with <code>Settable</code> throughout, giving us:</p><pre tabindex=0><code>{T -&gt; Settable, PT -&gt; *Settable}
</code></pre><p>After this nothing changes, and we are done. Both type arguments are known.</p><p>This example shows how we can use constraint type inference to apply a constraint to a type that is based on some other type parameter. In this case we are saying that <code>PT</code>, which is <code>*T</code>, must have a <code>Set</code> method. We can do this without requiring the caller to explicitly mention <code>*T</code>.</p><h5 id=constraints-apply-even-after-constraint-type-inference>Constraints apply even after constraint type inference</h5><p>Even when constraint type inference is used to infer type arguments based on constraints, we must still check the constraints after the type arguments are determined.</p><p>In the <code>FromStrings2</code> example above, we were able to deduce the type argument for <code>PT</code> based on the <code>Setter2</code> constraint. But in doing so we only looked at the type set, we didn&rsquo;t look at the methods. We still have to verify that the method is there, satisfying the constraint, even if constraint type inference succeeds.</p><p>For example, consider this invalid code:</p><pre tabindex=0><code>// Unsettable is a type that does not have a Set method.
type Unsettable int

func F4() {
	// This call is INVALID.
	nums := FromStrings2[Unsettable]([]string{&#34;1&#34;, &#34;2&#34;})
	...
}
</code></pre><p>When this call is made, we will apply constraint type inference just as before. It will succeed, just as before, and infer that the type arguments are <code>[Unsettable, *Unsettable]</code>. Only after constraint type inference is complete will we check whether <code>*Unsettable</code> implements the constraint <code>Setter2[Unsettable]</code>. Since <code>*Unsettable</code> does not have a <code>Set</code> method, constraint checking will fail, and this code will not compile.</p><h3 id=using-types-that-refer-to-themselves-in-constraints>Using types that refer to themselves in constraints</h3><p>It can be useful for a generic function to require a type argument with a method whose argument is the type itself. For example, this arises naturally in comparison methods. (Note that we are talking about methods here, not operators.) Suppose we want to write an <code>Index</code> method that uses an <code>Equal</code> method to check whether it has found the desired value. We would like to write that like this:</p><pre tabindex=0><code>// Index returns the index of e in s, or -1 if not found.
func Index[T Equaler](s []T, e T) int {
	for i, v := range s {
		if e.Equal(v) {
			return i
		}
	}
	return -1
}
</code></pre><p>In order to write the <code>Equaler</code> constraint, we have to write a constraint that can refer to the type argument being passed in. The easiest way to do this is to take advantage of the fact that a constraint does not have to be a defined type, it can simply be an interface type literal. This interface type literal can then refer to the type parameter.</p><pre tabindex=0><code>// Index returns the index of e in s, or -1 if not found.
func Index[T interface { Equal(T) bool }](s []T, e T) int {
	// same as above
}
</code></pre><p>This version of <code>Index</code> would be used with a type like <code>equalInt</code> defined here:</p><pre tabindex=0><code>// equalInt is a version of int that implements Equaler.
type equalInt int

// The Equal method lets equalInt implement the Equaler constraint.
func (a equalInt) Equal(b equalInt) bool { return a == b }

// indexEqualInts returns the index of e in s, or -1 if not found.
func indexEqualInt(s []equalInt, e equalInt) int {
	// The type argument equalInt is shown here for clarity.
	// Function argument type inference would permit omitting it.
	return Index[equalInt](s, e)
}
</code></pre><p>In this example, when we pass <code>equalInt</code> to <code>Index</code>, we check whether <code>equalInt</code> implements the constraint <code>interface { Equal(T) bool }</code>. The constraint has a type parameter, so we replace the type parameter with the type argument, which is <code>equalInt</code> itself. That gives us <code>interface { Equal(equalInt) bool }</code>. The <code>equalInt</code> type has an <code>Equal</code> method with that signature, so all is well, and the compilation succeeds.</p><h3 id=values-of-type-parameters-are-not-boxed>Values of type parameters are not boxed</h3><p>In the current implementations of Go, interface values always hold pointers. Putting a non-pointer value in an interface variable causes the value to be <em>boxed</em>. That means that the actual value is stored somewhere else, on the heap or stack, and the interface value holds a pointer to that location.</p><p>In this design, values of generic types are not boxed. For example, let&rsquo;s look back at our earlier example of <code>FromStrings2</code>. When it is instantiated with type <code>Settable</code>, it returns a value of type <code>[]Settable</code>. For example, we can write</p><pre tabindex=0><code>// Settable is an integer type that can be set from a string.
type Settable int

// Set sets the value of *p from a string.
func (p *Settable) Set(s string) {
	// same as above
}

func F() {
	// The type of nums is []Settable.
	nums := FromStrings2[Settable]([]string{&#34;1&#34;, &#34;2&#34;})
	// Settable can be converted directly to int.
	// This will set first to 1.
	first := int(nums[0])
	...
}
</code></pre><p>When we call <code>FromStrings2</code> instantiated with the type <code>Settable</code> we get back a <code>[]Settable</code>. The elements of that slice will be <code>Settable</code> values, which is to say, they will be integers. They will not be boxed, even though they were created and set by a generic function.</p><p>Similarly, when a generic type is instantiated it will have the expected types as components.</p><pre tabindex=0><code>type Pair[F1, F2 any] struct {
	first  F1
	second F2
}
</code></pre><p>When this is instantiated, the fields will not be boxed, and no unexpected memory allocations will occur. The type <code>Pair[int, string]</code> is convertible to <code>struct { first int; second string }</code>.</p><h3 id=more-on-type-sets>More on type sets</h3><p>Let&rsquo;s return now to type sets to cover some less important details that are still worth noting.</p><h4 id=both-elements-and-methods-in-constraints>Both elements and methods in constraints</h4><p>As seen earlier for <code>Setter2</code>, a constraint may use both constraint elements and methods.</p><pre tabindex=0><code>// StringableSignedInteger is a type constraint that matches any
// type that is both 1) defined as a signed integer type;
// 2) has a String method.
type StringableSignedInteger interface {
	~int | ~int8 | ~int16 | ~int32 | ~int64
	String() string
}
</code></pre><p>The rules for type sets define what this means. The type set of the union element is the set of all types whose underlying type is one of the predeclared signed integer types. The type set of <code>String() string</code> is the set of all types that define that method. The type set of <code>StringableSignedInteger</code> is the intersection of those two type sets. The result is the set of all types whose underlying type is one of the predeclared signed integer types and that defines the method <code>String() string</code>. A function that uses a parameterized type <code>P</code> that uses <code>StringableSignedInteger</code> as a constraint may use the operations permitted for any integer type (<code>+</code>, <code>*</code>, and so forth) on a value of type <code>P</code>. It may also call the <code>String</code> method on a value of type <code>P</code> to get back a <code>string</code>.</p><p>It&rsquo;s worth noting that the <code>~</code> is essential here. The <code>StringableSignedInteger</code> constraint uses <code>~int</code>, not <code>int</code>. The type <code>int</code> would not itself be permitted as a type argument, since <code>int</code> does not have a <code>String</code> method. An example of a type argument that would be permitted is <code>MyInt</code>, defined as:</p><pre tabindex=0><code>// MyInt is a stringable int.
type MyInt int

// The String method returns a string representation of mi.
func (mi MyInt) String() string {
	return fmt.Sprintf(&#34;MyInt(%d)&#34;, mi)
}
</code></pre><h4 id=composite-types-in-constraints>Composite types in constraints</h4><p>As we&rsquo;ve seen in some earlier examples, a constraint element may be a type literal.</p><pre tabindex=0><code>type byteseq interface {
	string | []byte
}
</code></pre><p>The usual rules apply: the type argument for this constraint may be <code>string</code> or <code>[]byte</code>; a generic function with this constraint may use any operation permitted by both <code>string</code> and <code>[]byte</code>.</p><p>The <code>byteseq</code> constraint permits writing generic functions that work for either <code>string</code> or <code>[]byte</code> types.</p><pre tabindex=0><code>// Join concatenates the elements of its first argument to create a
// single value. sep is placed between elements in the result.
// Join works for string and []byte types.
func Join[T byteseq](a []T, sep T) (ret T) {
	if len(a) == 0 {
		// Use the result parameter as a zero value;
		// see discussion of zero value in the Issues section.
		return ret
	}
	if len(a) == 1 {
		// We know that a[0] is either a string or a []byte.
		// We can append either a string or a []byte to a []byte,
		// producing a []byte. We can convert that []byte to
		// either a []byte (a no-op conversion) or a string.
		return T(append([]byte(nil), a[0]...))
	}
	// We can call len on sep because we can call len
	// on both string and []byte.
	n := len(sep) * (len(a) - 1)
	for _, v := range a {
		// Another case where we call len on string or []byte.
		n += len(v)
	}

	b := make([]byte, n)
	// We can call copy to a []byte with an argument of
	// either string or []byte.
	bp := copy(b, a[0])
	for _, s := range a[1:] {
		bp += copy(b[bp:], sep)
		bp += copy(b[bp:], s)
	}
	// As above, we can convert b to either []byte or string.
	return T(b)
}
</code></pre><p>For composite types (string, pointer, array, slice, struct, function, map, channel) we impose an additional restriction: an operation may only be used if the operator accepts identical input types (if any) and produces identical result types for all of the types in the type set. To be clear, this additional restriction is only imposed when a composite type appears in a type set. It does not apply when a composite type is formed from a type parameter outside of a type set, as in <code>var v []T</code> for some type parameter <code>T</code>.</p><pre tabindex=0><code>// structField is a type constraint whose type set consists of some
// struct types that all have a field named x.
type structField interface {
	struct { a int; x int } |
		struct { b int; x float64 } |
		struct { c int; x uint64 }
}

// This function is INVALID.
func IncrementX[T structField](p *T) {
	v := p.x // INVALID: type of p.x is not the same for all types in set
	v++
	p.x = v
}

// sliceOrMap is a type constraint for a slice or a map.
type sliceOrMap interface {
	[]int | map[int]int
}

// Entry returns the i&#39;th entry in a slice or the value of a map
// at key i. This is valid as the result of the operator is always int.
func Entry[T sliceOrMap](c T, i int) int {
	// This is either a slice index operation or a map key lookup.
	// Either way, the index and result types are type int.
	return c[i]
}

// sliceOrFloatMap is a type constraint for a slice or a map.
type sliceOrFloatMap interface {
	[]int | map[float64]int
}

// This function is INVALID.
// In this example the input type of the index operation is either
// int (for a slice) or float64 (for a map), so the operation is
// not permitted.
func FloatEntry[T sliceOrFloatMap](c T) int {
	return c[1.0] // INVALID: input type is either int or float64.
}
</code></pre><p>Imposing this restriction makes it easier to reason about the type of some operation in a generic function. It avoids introducing the notion of a value with a constructed type set based on applying some operation to each element of a type set.</p><p>(Note: with more understanding of how people want to write code, it may be possible to relax this restriction in the future.)</p><h4 id=type-parameters-in-type-sets>Type parameters in type sets</h4><p>A type literal in a constraint element can refer to type parameters of the constraint. In this example, the generic function <code>Map</code> takes two type parameters. The first type parameter is required to have an underlying type that is a slice of the second type parameter. There are no constraints on the second type parameter.</p><pre tabindex=0><code>// SliceConstraint is a type constraint that matches a slice of
// the type parameter.
type SliceConstraint[T any] interface {
	~[]T
}

// Map takes a slice of some element type and a transformation function,
// and returns a slice of the function applied to each element.
// Map returns a slice that is the same type as its slice argument,
// even if that is a defined type.
func Map[S SliceConstraint[E], E any](s S, f func(E) E) S {
	r := make(S, len(s))
	for i, v := range s {
		r[i] = f(v)
	}
	return r
}

// MySlice is a simple defined type.
type MySlice []int

// DoubleMySlice takes a value of type MySlice and returns a new
// MySlice value with each element doubled in value.
func DoubleMySlice(s MySlice) MySlice {
	// The type arguments listed explicitly here could be inferred.
	v := Map[MySlice, int](s, func(e int) int { return 2 * e })
	// Here v has type MySlice, not type []int.
	return v
}
</code></pre><p>We showed other examples of this earlier in the discussion of <a href=https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md#Constraint-type-inference>constraint type inference</a>.</p><h4 id=type-conversions>Type conversions</h4><p>In a function with two type parameters <code>From</code> and <code>To</code>, a value of type <code>From</code> may be converted to a value of type <code>To</code> if all the types in the type set of <code>From</code>&rsquo;s constraint can be converted to all the types in the type set of <code>To</code>&rsquo;s constraint.</p><p>This is a consequence of the general rule that a generic function may use any operation that is permitted by all types listed in the type set.</p><p>For example:</p><pre tabindex=0><code>type integer interface {
	~int | ~int8 | ~int16 | ~int32 | ~int64 |
		~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr
}

func Convert[To, From integer](from From) To {
	to := To(from)
	if From(to) != from {
		panic(&#34;conversion out of range&#34;)
	}
	return to
}
</code></pre><p>The type conversions in <code>Convert</code> are permitted because Go permits every integer type to be converted to every other integer type.</p><h4 id=untyped-constants>Untyped constants</h4><p>Some functions use untyped constants. An untyped constant is permitted with a value of a type parameter if it is permitted with every type in the type set of the type parameter&rsquo;s constraint.</p><p>As with type conversions, this is a consequence of the general rule that a generic function may use any operation that is permitted by all types in the type set.</p><pre tabindex=0><code>type integer interface {
	~int | ~int8 | ~int16 | ~int32 | ~int64 |
		~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr
}

func Add10[T integer](s []T) {
	for i, v := range s {
		s[i] = v + 10 // OK: 10 can convert to any integer type
	}
}

// This function is INVALID.
func Add1024[T integer](s []T) {
	for i, v := range s {
		s[i] = v + 1024 // INVALID: 1024 not permitted by int8/uint8
	}
}
</code></pre><h4 id=type-sets-of-embedded-constraints>Type sets of embedded constraints</h4><p>When a constraint embeds another constraint, the type set of the outer constraint is the intersection of all the type sets involved. If there are multiple embedded types, intersection preserves the property that any type argument must satisfy the requirements of all constraint elements.</p><pre tabindex=0><code>// Addable is types that support the + operator.
type Addable interface {
	~int | ~int8 | ~int16 | ~int32 | ~int64 |
		~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr |
		~float32 | ~float64 | ~complex64 | ~complex128 |
		~string
}

// Byteseq is a byte sequence: either string or []byte.
type Byteseq interface {
	~string | ~[]byte
}

// AddableByteseq is a byte sequence that supports +.
// This is every type that is both Addable and Byteseq.
// In other words, just the type set ~string.
type AddableByteseq interface {
	Addable
	Byteseq
}
</code></pre><p>An embedded constraint may appear in a union element. The type set of the union is, as usual, the union of the type sets of the elements listed in the union.</p><pre tabindex=0><code>// Signed is a constraint with a type set of all signed integer
// types.
type Signed interface {
	~int | ~int8 | ~int16 | ~int32 | ~int64
}

// Unsigned is a constraint with a type set of all unsigned integer
// types.
type Unsigned interface {
	~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr
}

// Integer is a constraint with a type set of all integer types.
type Integer interface {
	Signed | Unsigned
}
</code></pre><h4 id=interface-types-in-union-elements>Interface types in union elements</h4><p>We&rsquo;ve said that the type set of a union element is the union of the type sets of all types in the union. For most types <code>T</code> the type set of <code>T</code> is simply <code>T</code> itself. For interface types (and approximation elements), however, that is not the case.</p><p>The type set of an interface type that does not embed a non-interface element is, as we said earlier, the set of all types that declare all the methods of the interface, including the interface type itself. Using such an interface type in a union element will add that type set to the union.</p><pre tabindex=0><code>type Stringish interface {
	string | fmt.Stringer
}
</code></pre><p>The type set of <code>Stringish</code> is the type <code>string</code> and all types that implement <code>fmt.Stringer</code>. Any of those types (including <code>fmt.Stringer</code> itself) will be permitted as a type argument for this constraint. No operations will be permitted for a value of a type parameter that uses <code>Stringish</code> as a constraint (other than operations supported by all types). This is because <code>fmt.Stringer</code> is in the type set of <code>Stringish</code>, and <code>fmt.Stringer</code>, an interface type, does not support any type-specific operations. The operations permitted by <code>Stringish</code> are those operations supported by all the types in the type set, including <code>fmt.Stringer</code>, so in this case there are no operations other than those supported by all types. A parameterized function that uses this constraint will have to use type assertions or reflection in order to use the values. Still, this may be useful in some cases for stronger static type checking. The main point is that it follows directly from the definition of type sets and constraint satisfaction.</p><h4 id=empty-type-sets>Empty type sets</h4><p>It is possible to write a constraint with an empty type set. There is no type argument that will satisfy such a constraint, so any attempt to instantiate a function that uses constraint with an empty type set will fail. It is not possible in general for the compiler to detect all such cases. Probably the vet tool should give an error for cases that it is able to detect.</p><pre tabindex=0><code>// Unsatisfiable is an unsatisfiable constraint with an empty type set.
// No predeclared types have any methods.
// If this used ~int | ~float32 the type set would not be empty.
type Unsatisfiable interface {
	int | float32
	String() string
}
</code></pre><h4 id=general-notes-on-type-sets>General notes on type sets</h4><p>It may seem awkward to explicitly list types in a constraint, but it is clear both as to which type arguments are permitted at the call site, and which operations are permitted by the generic function.</p><p>If the language later changes to support operator methods (there are no such plans at present), then constraints will handle them as they do any other kind of method.</p><p>There will always be a limited number of predeclared types, and a limited number of operators that those types support. Future language changes will not fundamentally change those facts, so this approach will continue to be useful.</p><p>This approach does not attempt to handle every possible operator. The expectation is that composite types will normally be handled using composite types in generic function and type declarations, rather than putting composite types in a type set. For example, we expect functions that want to index into a slice to be parameterized on the slice element type <code>T</code>, and to use parameters or variables of type <code>[]T</code>.</p><p>As shown in the <code>DoubleMySlice</code> example above, this approach makes it awkward to declare generic functions that accept and return a composite type and want to return the same result type as their argument type. Defined composite types are not common, but they do arise. This awkwardness is a weakness of this approach. Constraint type inference can help at the call site.</p><h3 id=reflection>Reflection</h3><p>We do not propose to change the reflect package in any way. When a type or function is instantiated, all of the type parameters will become ordinary non-generic types. The <code>String</code> method of a <code>reflect.Type</code> value of an instantiated type will return the name with the type arguments in square brackets. For example, <code>List[int]</code>.</p><p>It&rsquo;s impossible for non-generic code to refer to generic code without instantiating it, so there is no reflection information for uninstantiated generic types or functions.</p><h3 id=implementation>Implementation</h3><p>Russ Cox <a href=https://research.swtch.com/generic>famously observed</a> that generics require choosing among slow programmers, slow compilers, or slow execution times.</p><p>We believe that this design permits different implementation choices. Code may be compiled separately for each set of type arguments, or it may be compiled as though each type argument is handled similarly to an interface type with method calls, or there may be some combination of the two.</p><p>In other words, this design permits people to stop choosing slow programmers, and permits the implementation to decide between slow compilers (compile each set of type arguments separately) or slow execution times (use method calls for each operation on a value of a type argument).</p><h3 id=summary>Summary</h3><p>While this document is long and detailed, the actual design reduces to a few major points.</p><ul><li>Functions and types can have type parameters, which are defined using constraints, which are interface types.</li><li>Constraints describe the methods required and the types permitted for a type argument.</li><li>Constraints describe the methods and operations permitted for a type parameter.</li><li>Type inference will often permit omitting type arguments when calling functions with type parameters.</li></ul><p>This design is completely backward compatible.</p><p>We believe that this design addresses people&rsquo;s needs for generic programming in Go, without making the language any more complex than necessary.</p><p>We can&rsquo;t truly know the impact on the language without years of experience with this design. That said, here are some speculations.</p><h4 id=complexity>Complexity</h4><p>One of the great aspects of Go is its simplicity. Clearly this design makes the language more complex.</p><p>We believe that the increased complexity is small for people reading well written generic code, rather than writing it. Naturally people must learn the new syntax for declaring type parameters. This new syntax, and the new support for type sets in interfaces, are the only new syntactic constructs in this design. The code within a generic function reads like ordinary Go code, as can be seen in the examples below. It is an easy shift to go from <code>[]int</code> to <code>[]T</code>. Type parameter constraints serve effectively as documentation, describing the type.</p><p>We expect that most packages will not define generic types or functions, but many packages are likely to use generic types or functions defined elsewhere. In the common case, generic functions work exactly like non-generic functions: you simply call them. Type inference means that you do not have to write out the type arguments explicitly. The type inference rules are designed to be unsurprising: either the type arguments are deduced correctly, or the call fails and requires explicit type parameters. Type inference uses type equivalence, with no attempt to resolve two types that are similar but not equivalent, which removes significant complexity.</p><p>Packages using generic types will have to pass explicit type arguments. The syntax for this is straightforward. The only change is passing arguments to types rather than only to functions.</p><p>In general, we have tried to avoid surprises in the design. Only time will tell whether we succeeded.</p><h4 id=pervasiveness>Pervasiveness</h4><p>We expect that a few new packages will be added to the standard library. A new <code>slices</code> packages will be similar to the existing bytes and strings packages, operating on slices of any element type. New <code>maps</code> and <code>chans</code> packages will provide algorithms that are currently duplicated for each element type. A <code>sets</code> package may be added.</p><p>A new <code>constraints</code> package will provide standard constraints, such as constraints that permit all integer types or all numeric types.</p><p>Packages like <code>container/list</code> and <code>container/ring</code>, and types like <code>sync.Map</code> and <code>sync/atomic.Value</code>, will be updated to be compile-time type-safe, either using new names or new versions of the packages.</p><p>The <code>math</code> package will be extended to provide a set of simple standard algorithms for all numeric types, such as the ever popular <code>Min</code> and <code>Max</code> functions.</p><p>We may add generic variants to the <code>sort</code> package.</p><p>It is likely that new special purpose compile-time type-safe container types will be developed.</p><p>We do not expect approaches like the C++ STL iterator types to become widely used. In Go that sort of idea is more naturally expressed using an interface type. In C++ terms, using an interface type for an iterator can be seen as carrying an abstraction penalty, in that run-time efficiency will be less than C++ approaches that in effect inline all code; we believe that Go programmers will continue to find that sort of penalty to be acceptable.</p><p>As we get more container types, we may develop a standard <code>Iterator</code> interface. That may in turn lead to pressure to modify the language to add some mechanism for using an <code>Iterator</code> with the <code>range</code> clause. That is very speculative, though.</p><h4 id=efficiency>Efficiency</h4><p>It is not clear what sort of efficiency people expect from generic code.</p><p>Generic functions, rather than generic types, can probably be compiled using an interface-based approach. That will optimize compile time, in that the function is only compiled once, but there will be some run time cost.</p><p>Generic types may most naturally be compiled multiple times for each set of type arguments. This will clearly carry a compile time cost, but there shouldn&rsquo;t be any run time cost. Compilers can also choose to implement generic types similarly to interface types, using special purpose methods to access each element that depends on a type parameter.</p><p>Only experience will show what people expect in this area.</p><h4 id=omissions>Omissions</h4><p>We believe that this design covers the basic requirements for generic programming. However, there are a number of programming constructs that are not supported.</p><ul><li>No specialization. There is no way to write multiple versions of a generic function that are designed to work with specific type arguments.</li><li>No metaprogramming. There is no way to write code that is executed at compile time to generate code to be executed at run time.</li><li>No higher level abstraction. There is no way to use a function with type arguments other than to call it or instantiate it. There is no way to use a generic type other than to instantiate it.</li><li>No general type description. In order to use operators in a generic function, constraints list specific types, rather than describing the characteristics that a type must have. This is easy to understand but may be limiting at times.</li><li>No covariance or contravariance of function parameters.</li><li>No operator methods. You can write a generic container that is compile-time type-safe, but you can only access it with ordinary methods, not with syntax like <code>c[k]</code>.</li><li>No currying. There is no way to partially instantiate a generic function or type, other than by using a helper function or a wrapper type. All type arguments must be either explicitly passed or inferred at instantiation time.</li><li>No variadic type parameters. There is no support for variadic type parameters, which would permit writing a single generic function that takes different numbers of both type parameters and regular parameters.</li><li>No adaptors. There is no way for a constraint to define adaptors that could be used to support type arguments that do not already implement the constraint, such as, for example, defining an <code>==</code> operator in terms of an <code>Equal</code> method, or vice-versa.</li><li>No parameterization on non-type values such as constants. This arises most obviously for arrays, where it might sometimes be convenient to write <code>type Matrix[n int] [n][n]float64</code>. It might also sometimes be useful to specify significant values for a container type, such as a default value for elements.</li></ul><h4 id=issues>Issues</h4><p>There are some issues with this design that deserve a more detailed discussion. We think these issues are relatively minor compared to the design as a whole, but they still deserve a complete hearing and discussion.</p><h5 id=the-zero-value>The zero value</h5><p>This design has no simple expression for the zero value of a type parameter. For example, consider this implementation of optional values that uses pointers:</p><pre tabindex=0><code>type Optional[T any] struct {
	p *T
}

func (o Optional[T]) Val() T {
	if o.p != nil {
		return *o.p
	}
	var zero T
	return zero
}
</code></pre><p>In the case where <code>o.p == nil</code>, we want to return the zero value of <code>T</code>, but we have no way to write that. It would be nice to be able to write <code>return nil</code>, but that wouldn&rsquo;t work if <code>T</code> is, say, <code>int</code>; in that case we would have to write <code>return 0</code>. And, of course, there is no way to write a constraint to support either <code>return nil</code> or <code>return 0</code>.</p><p>Some approaches to this are:</p><ul><li>Use <code>var zero T</code>, as above, which works with the existing design but requires an extra statement.</li><li>Use <code>*new(T)</code>, which is cryptic but works with the existing design.</li><li>For results only, name the result parameter, and use a naked <code>return</code> statement to return the zero value.</li><li>Extend the design to permit using <code>nil</code> as the zero value of any generic type (but see <a href=https://golang.org/issue/22729>issue 22729</a>).</li><li>Extend the design to permit using <code>T{}</code>, where <code>T</code> is a type parameter, to indicate the zero value of the type.</li><li>Change the language to permit using <code>_</code> on the right hand of an assignment (including <code>return</code> or a function call) as proposed in <a href=https://golang.org/issue/19642>issue 19642</a>.</li><li>Change the language to permit <code>return ...</code> to return zero values of the result types, as proposed in <a href=https://golang.org/issue/21182>issue 21182</a>.</li></ul><p>We feel that more experience with this design is needed before deciding what, if anything, to do here.</p><h5 id=identifying-the-matched-predeclared-type>Identifying the matched predeclared type</h5><p>The design doesn&rsquo;t provide any way to test the underlying type matched by a <code>~T</code> constraint element. Code can test the actual type argument through the somewhat awkward approach of converting to an empty interface type and using a type assertion or a type switch. But that lets code test the actual type argument, which is not the same as the underlying type.</p><p>Here is an example that shows the difference.</p><pre tabindex=0><code>type Float interface {
	~float32 | ~float64
}

func NewtonSqrt[T Float](v T) T {
	var iterations int
	switch (interface{})(v).(type) {
	case float32:
		iterations = 4
	case float64:
		iterations = 5
	default:
		panic(fmt.Sprintf(&#34;unexpected type %T&#34;, v))
	}
	// Code omitted.
}

type MyFloat float32

var G = NewtonSqrt(MyFloat(64))
</code></pre><p>This code will panic when initializing <code>G</code>, because the type of <code>v</code> in the <code>NewtonSqrt</code> function will be <code>MyFloat</code>, not <code>float32</code> or <code>float64</code>. What this function actually wants to test is not the type of <code>v</code>, but the approximate type that <code>v</code> matched in the constraint&rsquo;s type set.</p><p>One way to handle this would be to permit writing approximate types in a type switch, as in <code>case ~float32:</code>. Such a case would match any type whose underlying type is <code>float32</code>. This would be meaningful, and potentially useful, even in type switches outside of generic functions.</p><h5 id=no-way-to-express-convertibility>No way to express convertibility</h5><p>The design has no way to express convertibility between two different type parameters. For example, there is no way to write this function:</p><pre tabindex=0><code>// Copy copies values from src to dst, converting them as they go.
// It returns the number of items copied, which is the minimum of
// the lengths of dst and src.
// This implementation is INVALID.
func Copy[T1, T2 any](dst []T1, src []T2) int {
	for i, x := range src {
		if i &gt; len(dst) {
			return i
		}
		dst[i] = T1(x) // INVALID
	}
	return len(src)
}
</code></pre><p>The conversion from type <code>T2</code> to type <code>T1</code> is invalid, as there is no constraint on either type that permits the conversion. Worse, there is no way to write such a constraint in general. In the particular case where both <code>T1</code> and <code>T2</code> have limited type sets this function can be written as described earlier when discussing <a href=https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md#Type-conversions>type conversions using type sets</a>. But, for example, there is no way to write a constraint for the case in which <code>T1</code> is an interface type and <code>T2</code> is a type that implements that interface.</p><p>It&rsquo;s worth noting that if <code>T1</code> is an interface type then this can be written using a conversion to the empty interface type and a type assertion, but this is, of course, not compile-time type-safe.</p><pre tabindex=0><code>// Copy copies values from src to dst, converting them as they go.
// It returns the number of items copied, which is the minimum of
// the lengths of dst and src.
func Copy[T1, T2 any](dst []T1, src []T2) int {
	for i, x := range src {
		if i &gt; len(dst) {
			return i
		}
		dst[i] = (interface{})(x).(T1)
	}
	return len(src)
}
</code></pre><h5 id=no-parameterized-methods>No parameterized methods</h5><p>This design does not permit methods to declare type parameters that are specific to the method. The receiver may have type parameters, but the method may not add any type parameters.</p><p>In Go, one of the main roles of methods is to permit types to implement interfaces. It is not clear whether it is reasonably possible to permit parameterized methods to implement interfaces. For example, consider this code, which uses the obvious syntax for parameterized methods. This code uses multiple packages to make the problem clearer.</p><pre tabindex=0><code>package p1

// S is a type with a parameterized method Identity.
type S struct{}

// Identity is a simple identity method that works for any type.
func (S) Identity[T any](v T) T { return v }

package p2

// HasIdentity is an interface that matches any type with a
// parameterized Identity method.
type HasIdentity interface {
	Identity[T any](T) T
}

package p3

import &#34;p2&#34;

// CheckIdentity checks the Identity method if it exists.
// Note that although this function calls a parameterized method,
// this function is not itself parameterized.
func CheckIdentity(v interface{}) {
	if vi, ok := v.(p2.HasIdentity); ok {
		if got := vi.Identity[int](0); got != 0 {
			panic(got)
		}
	}
}

package p4

import (
	&#34;p1&#34;
	&#34;p3&#34;
)

// CheckSIdentity passes an S value to CheckIdentity.
func CheckSIdentity() {
	p3.CheckIdentity(p1.S{})
}
</code></pre><p>In this example, we have a type <code>p1.S</code> with a parameterized method and a type <code>p2.HasIdentity</code> that also has a parameterized method. <code>p1.S</code> implements <code>p2.HasIdentity</code>. Therefore, the function <code>p3.CheckIdentity</code> can call <code>vi.Identity</code> with an <code>int</code> argument, which in the call from <code>p4.CheckSIdentity</code> will be a call to <code>p1.S.Identity[int]</code>. But package p3 does not know anything about the type <code>p1.S</code>. There may be no other call to <code>p1.S.Identity</code> elsewhere in the program. We need to instantiate <code>p1.S.Identity[int]</code> somewhere, but how?</p><p>We could instantiate it at link time, but in the general case that requires the linker to traverse the complete call graph of the program to determine the set of types that might be passed to <code>CheckIdentity</code>. And even that traversal is not sufficient in the general case when type reflection gets involved, as reflection might look up methods based on strings input by the user. So in general instantiating parameterized methods in the linker might require instantiating every parameterized method for every possible type argument, which seems untenable.</p><p>Or, we could instantiate it at run time. In general this means using some sort of JIT, or compiling the code to use some sort of reflection based approach. Either approach would be very complex to implement, and would be surprisingly slow at run time.</p><p>Or, we could decide that parameterized methods do not, in fact, implement interfaces, but then it&rsquo;s much less clear why we need methods at all. If we disregard interfaces, any parameterized method can be implemented as a parameterized function.</p><p>So while parameterized methods seem clearly useful at first glance, we would have to decide what they mean and how to implement that.</p><h5 id=no-way-to-require-pointer-methods>No way to require pointer methods</h5><p>In some cases a parameterized function is naturally written such that it always invokes methods on addressable values. For example, this happens when calling a method on each element of a slice. In such a case, the function only requires that the method be in the slice element type&rsquo;s pointer method set. The type constraints described in this design have no way to write that requirement.</p><p>For example, consider a variant of the <code>Stringify</code> example we <a href=https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md#Using-a-constraint>showed earlier</a>.</p><pre tabindex=0><code>// Stringify2 calls the String method on each element of s,
// and returns the results.
func Stringify2[T Stringer](s []T) (ret []string) {
	for i := range s {
		ret = append(ret, s[i].String())
	}
	return ret
}
</code></pre><p>Suppose we have a <code>[]bytes.Buffer</code> and we want to convert it into a <code>[]string</code>. The <code>Stringify2</code> function here won‘t help us. We want to write <code>Stringify2[bytes.Buffer]</code>, but we can’t, because <code>bytes.Buffer</code> doesn‘t have a <code>String</code> method. The type that has a <code>String</code> method is <code>*bytes.Buffer</code>. Writing <code>Stringify2[*bytes.Buffer]</code> doesn’t help because that function expects a <code>[]*bytes.Buffer</code>, but we have a <code>[]bytes.Buffer</code>.</p><p>We discussed a similar case in the <a href=https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md#Pointer-method-example>pointer method example</a> above. There we used constraint type inference to help simplify the problem. Here that doesn‘t help, because <code>Stringify2</code> doesn’t really care about calling a pointer method. It just wants a type that has a <code>String</code> method, and it&rsquo;s OK if the method is only in the pointer method set, not the value method set. But we also want to accept the case where the method is in the value method set, for example if we really do have a <code>[]*bytes.Buffer</code>.</p><p>What we need is a way to say that the type constraint applies to either the pointer method set or the value method set. The body of the function would be required to only call the method on addressable values of the type.</p><p>It&rsquo;s not clear how often this problem comes up in practice.</p><h5 id=no-association-between-float-and-complex>No association between float and complex</h5><p>Constraint type inference lets us give a name to the element of a slice type, and to apply other similar type decompositions. However, there is no way to associate a float type and a complex type. For example, there is no way to write the predeclared <code>real</code>, <code>imag</code>, or <code>complex</code> functions with this design. There is no way to say “if the argument type is <code>complex64</code>, then the result type is <code>float32</code>.”</p><p>One possible approach here would be to permit <code>real(T)</code> as a type constraint meaning “the float type associated with the complex type <code>T</code>”. Similarly, <code>complex(T)</code> would mean “the complex type associated with the floating point type <code>T</code>”. Constraint type inference would simplify the call site. However, that would be unlike other type constraints.</p><h4 id=discarded-ideas>Discarded ideas</h4><p>This design is not perfect, and there may be ways to improve it. That said, there are many ideas that we&rsquo;ve already considered in detail. This section lists some of those ideas in the hopes that it will help to reduce repetitive discussion. The ideas are presented in the form of a FAQ.</p><h5 id=what-happened-to-contracts>What happened to contracts?</h5><p>An earlier draft design of generics implemented constraints using a new language construct called contracts. Type sets appeared only in contracts, rather than in interface types. However, many people had a hard time understanding the difference between contracts and interface types. It also turned out that contracts could be represented as a set of corresponding interfaces; there was no loss in expressive power without contracts. We decided to simplify the approach to use only interface types.</p><h5 id=why-not-use-methods-instead-of-type-sets>Why not use methods instead of type sets?</h5><p><em>Type sets are weird.</em> <em>Why not write methods for all operators?</em></p><p>It is possible to permit operator tokens as method names, leading to methods such as <code>+(T) T</code>. Unfortunately, that is not sufficient. We would need some mechanism to describe a type that matches any integer type, for operations such as shifts <code>&lt;&lt;(integer) T</code> and indexing <code>[](integer) T</code> which are not restricted to a single int type. We would need an untyped boolean type for operations such as <code>==(T) untyped bool</code>. We would need to introduce new notation for operations such as conversions, or to express that one may range over a type, which would likely require some new syntax. We would need some mechanism to describe valid values of untyped constants. We would have to consider whether support for <code>&lt;(T) bool</code> means that a generic function can also use <code>&lt;=</code>, and similarly whether support for <code>+(T) T</code> means that a function can also use <code>++</code>. It might be possible to make this approach work but it&rsquo;s not straightforward. The approach used in this design seems simpler and relies on only one new syntactic construct (type sets) and one new name (<code>comparable</code>).</p><h5 id=why-not-put-type-parameters-on-packages>Why not put type parameters on packages?</h5><p>We investigated this extensively. It becomes problematic when you want to write a <code>list</code> package, and you want that package to include a <code>Transform</code> function that converts a <code>List</code> of one element type to a <code>List</code> of another element type. It&rsquo;s very awkward for a function in one instantiation of a package to return a type that requires a different instantiation of the same package.</p><p>It also confuses package boundaries with type definitions. There is no particular reason to think that the uses of generic types will break down neatly into packages. Sometimes they will, sometimes they won&rsquo;t.</p><h5 id=why-not-use-the-syntax-ft-like-c-and-java>Why not use the syntax <code>F&lt;T></code> like C++ and Java?</h5><p>When parsing code within a function, such as <code>v := F&lt;T></code>, at the point of seeing the <code>&lt;</code> it&rsquo;s ambiguous whether we are seeing a type instantiation or an expression using the <code>&lt;</code> operator. This is very difficult to resolve without type information.</p><p>For example, consider a statement like</p><pre tabindex=0><code>	a, b = w &lt; x, y &gt; (z)
</code></pre><p>Without type information, it is impossible to decide whether the right hand side of the assignment is a pair of expressions (<code>w &lt; x</code> and <code>y > (z)</code>), or whether it is a generic function instantiation and call that returns two result values (<code>(w&lt;x, y>)(z)</code>).</p><p>It is a key design decision of Go that parsing be possible without type information, which seems impossible when using angle brackets for generics.</p><h5 id=why-not-use-the-syntax-ft>Why not use the syntax <code>F(T)</code>?</h5><p>An earlier version of this design used that syntax. It was workable but it introduced several parsing ambiguities. For example, when writing <code>var f func(x(T))</code> it wasn&rsquo;t clear whether the type was a function with a single unnamed parameter of the instantiated type <code>x(T)</code> or whether it was a function with a parameter named <code>x</code> with type <code>(T)</code> (more usually written as <code>func(x T)</code>, but in this case with a parenthesized type).</p><p>There were other ambiguities as well. For <code>[]T(v1)</code> and <code>[]T(v2){}</code>, at the point of the open parentheses we don‘t know whether this is a type conversion (of the value <code>v1</code> to the type <code>[]T</code>) or a type literal (whose type is the instantiated type <code>T(v2)</code>). For <code>interface { M(T) }</code> we don’t know whether this an interface with a method <code>M</code> or an interface with an embedded instantiated interface <code>M(T)</code>. These ambiguities are solvable, by adding more parentheses, but awkward.</p><p>Also some people were troubled by the number of parenthesized lists involved in declarations like <code>func F(T any)(v T)(r1, r2 T)</code> or in calls like <code>F(int)(1)</code>.</p><h5 id=why-not-use-ft>Why not use <code>F«T»</code>?</h5><p>We considered it but we couldn&rsquo;t bring ourselves to require non-ASCII.</p><h5 id=why-not-define-constraints-in-a-builtin-package>Why not define constraints in a builtin package?</h5><p><em>Instead of writing out type sets, use names like</em> <em><code>constraints.Arithmetic</code> and <code>constraints.Comparable</code>.</em></p><p>Listing all the possible combinations of types gets rather lengthy. It also introduces a new set of names that not only the writer of generic code, but, more importantly, the reader, must remember. One of the driving goals of this design is to introduce as few new names as possible. In this design we introduce only two new predeclared names, <code>comparable</code> and <code>any</code>.</p><p>We expect that if people find such names useful, we can introduce a package <code>constraints</code> that defines those names in the form of constraints that can be used by other types and functions and embedded in other constraints. That will define the most useful names in the standard library while giving programmers the flexibility to use other combinations of types where appropriate.</p><h5 id=why-not-permit-type-assertions-on-values-whose-type-is-a-type-parameter>Why not permit type assertions on values whose type is a type parameter?</h5><p>In an earlier version of this design, we permitted using type assertions and type switches on variables whose type was a type parameter, or whose type was based on a type parameter. We removed this facility because it is always possible to convert a value of any type to the empty interface type, and then use a type assertion or type switch on that. Also, it was sometimes confusing that in a constraint with a type set that uses approximation elements, a type assertion or type switch would use the actual type argument, not the underlying type of the type argument (the difference is explained in the section on <a href=https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md#Identifying-the-matched-predeclared-type>identifying the matched predeclared type</a>).</p><h4 id=comparison-with-java>Comparison with Java</h4><p>Most complaints about Java generics center around type erasure. This design does not have type erasure. The reflection information for a generic type will include the full compile-time type information.</p><p>In Java type wildcards (<code>List&lt;? extends Number></code>, <code>List&lt;? super Number></code>) implement covariance and contravariance. These concepts are missing from Go, which makes generic types much simpler.</p><h4 id=comparison-with-c>Comparison with C++</h4><p>C++ templates do not enforce any constraints on the type arguments (unless the concept proposal is adopted). This means that changing template code can accidentally break far-off instantiations. It also means that error messages are reported only at instantiation time, and can be deeply nested and difficult to understand. This design avoids these problems through mandatory and explicit constraints.</p><p>C++ supports template metaprogramming, which can be thought of as ordinary programming done at compile time using a syntax that is completely different than that of non-template C++. This design has no similar feature. This saves considerable complexity while losing some power and run time efficiency.</p><p>C++ uses two-phase name lookup, in which some names are looked up in the context of the template definition, and some names are looked up in the context of the template instantiation. In this design all names are looked up at the point where they are written.</p><p>In practice, all C++ compilers compile each template at the point where it is instantiated. This can slow down compilation time. This design offers flexibility as to how to handle the compilation of generic functions.</p><h4 id=comparison-with-rust>Comparison with Rust</h4><p>The generics described in this design are similar to generics in Rust.</p><p>One difference is that in Rust the association between a trait bound and a type must be defined explicitly, either in the crate that defines the trait bound or the crate that defines the type. In Go terms, this would mean that we would have to declare somewhere whether a type satisfied a constraint. Just as Go types can satisfy Go interfaces without an explicit declaration, in this design Go type arguments can satisfy a constraint without an explicit declaration.</p><p>Where this design uses type sets, the Rust standard library defines standard traits for operations like comparison. These standard traits are automatically implemented by Rust&rsquo;s primitive types, and can be implemented by user defined types as well. Rust provides a fairly extensive list of traits, at least 34, covering all of the operators.</p><p>Rust supports type parameters on methods, which this design does not.</p><h2 id=examples>Examples</h2><p>The following sections are examples of how this design could be used. This is intended to address specific areas where people have created user experience reports concerned with Go&rsquo;s lack of generics.</p><h3 id=mapreducefilter>Map/Reduce/Filter</h3><p>Here is an example of how to write map, reduce, and filter functions for slices. These functions are intended to correspond to the similar functions in Lisp, Python, Java, and so forth.</p><pre tabindex=0><code>// Package slices implements various slice algorithms.
package slices

// Map turns a []T1 to a []T2 using a mapping function.
// This function has two type parameters, T1 and T2.
// This works with slices of any type.
func Map[T1, T2 any](s []T1, f func(T1) T2) []T2 {
	r := make([]T2, len(s))
	for i, v := range s {
		r[i] = f(v)
	}
	return r
}

// Reduce reduces a []T1 to a single value using a reduction function.
func Reduce[T1, T2 any](s []T1, initializer T2, f func(T2, T1) T2) T2 {
	r := initializer
	for _, v := range s {
		r = f(r, v)
	}
	return r
}

// Filter filters values from a slice using a filter function.
// It returns a new slice with only the elements of s
// for which f returned true.
func Filter[T any](s []T, f func(T) bool) []T {
	var r []T
	for _, v := range s {
		if f(v) {
			r = append(r, v)
		}
	}
	return r
}
</code></pre><p>Here are some example calls of these functions. Type inference is used to determine the type arguments based on the types of the non-type arguments.</p><pre tabindex=0><code>	s := []int{1, 2, 3}

	floats := slices.Map(s, func(i int) float64 { return float64(i) })
	// Now floats is []float64{1.0, 2.0, 3.0}.

	sum := slices.Reduce(s, 0, func(i, j int) int { return i + j })
	// Now sum is 6.

	evens := slices.Filter(s, func(i int) bool { return i%2 == 0 })
	// Now evens is []int{2}.
</code></pre><h3 id=map-keys>Map keys</h3><p>Here is how to get a slice of the keys of any map.</p><pre tabindex=0><code>// Package maps provides general functions that work for all map types.
package maps

// Keys returns the keys of the map m in a slice.
// The keys will be returned in an unpredictable order.
// This function has two type parameters, K and V.
// Map keys must be comparable, so key has the predeclared
// constraint comparable. Map values can be any type.
func Keys[K comparable, V any](m map[K]V) []K {
	r := make([]K, 0, len(m))
	for k := range m {
		r = append(r, k)
	}
	return r
}
</code></pre><p>In typical use the map key and val types will be inferred.</p><pre tabindex=0><code>	k := maps.Keys(map[int]int{1:2, 2:4})
	// Now k is either []int{1, 2} or []int{2, 1}.
</code></pre><h3 id=sets>Sets</h3><p>Many people have asked for Go&rsquo;s builtin map type to be extended, or rather reduced, to support a set type. Here is a type-safe implementation of a set type, albeit one that uses methods rather than operators like <code>[]</code>.</p><pre tabindex=0><code>// Package sets implements sets of any comparable type.
package sets

// Set is a set of values.
type Set[T comparable] map[T]struct{}

// Make returns a set of some element type.
func Make[T comparable]() Set[T] {
	return make(Set[T])
}

// Add adds v to the set s.
// If v is already in s this has no effect.
func (s Set[T]) Add(v T) {
	s[v] = struct{}{}
}

// Delete removes v from the set s.
// If v is not in s this has no effect.
func (s Set[T]) Delete(v T) {
	delete(s, v)
}

// Contains reports whether v is in s.
func (s Set[T]) Contains(v T) bool {
	_, ok := s[v]
	return ok
}

// Len reports the number of elements in s.
func (s Set[T]) Len() int {
	return len(s)
}

// Iterate invokes f on each element of s.
// It&#39;s OK for f to call the Delete method.
func (s Set[T]) Iterate(f func(T)) {
	for v := range s {
		f(v)
	}
}
</code></pre><p>Example use:</p><pre tabindex=0><code>	// Create a set of ints.
	// We pass int as a type argument.
	// Then we write () because Make does not take any non-type arguments.
	// We have to pass an explicit type argument to Make.
	// Function argument type inference doesn&#39;t work because the
	// type argument to Make is only used for a result parameter type.
	s := sets.Make[int]()

	// Add the value 1 to the set s.
	s.Add(1)

	// Check that s does not contain the value 2.
	if s.Contains(2) { panic(&#34;unexpected 2&#34;) }
</code></pre><p>This example shows how to use this design to provide a compile-time type-safe wrapper around an existing API.</p><h3 id=sort>Sort</h3><p>Before the introduction of <code>sort.Slice</code>, a common complaint was the need for boilerplate definitions in order to use <code>sort.Sort</code>. With this design, we can add to the sort package as follows:</p><pre tabindex=0><code>// Ordered is a type constraint that matches all ordered types.
// (An ordered type is one that supports the &lt; &lt;= &gt;= &gt; operators.)
// In practice this type constraint would likely be defined in
// a standard library package.
type Ordered interface {
	~int | ~int8 | ~int16 | ~int32 | ~int64 |
		~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr |
		~float32 | ~float64 |
		~string
}

// orderedSlice is an internal type that implements sort.Interface.
// The Less method uses the &lt; operator. The Ordered type constraint
// ensures that T has a &lt; operator.
type orderedSlice[T Ordered] []T

func (s orderedSlice[T]) Len() int           { return len(s) }
func (s orderedSlice[T]) Less(i, j int) bool { return s[i] &lt; s[j] }
func (s orderedSlice[T]) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }

// OrderedSlice sorts the slice s in ascending order.
// The elements of s must be ordered using the &lt; operator.
func OrderedSlice[T Ordered](s []T) {
	// Convert s to the type orderedSlice[T].
	// As s is []T, and orderedSlice[T] is defined as []T,
	// this conversion is permitted.
	// orderedSlice[T] implements sort.Interface,
	// so can pass the result to sort.Sort.
	// The elements will be sorted using the &lt; operator.
	sort.Sort(orderedSlice[T](s))
}
</code></pre><p>Now we can write:</p><pre tabindex=0><code>	s1 := []int32{3, 5, 2}
	sort.OrderedSlice(s1)
	// Now s1 is []int32{2, 3, 5}

	s2 := []string{&#34;a&#34;, &#34;c&#34;, &#34;b&#34;})
	sort.OrderedSlice(s2)
	// Now s2 is []string{&#34;a&#34;, &#34;b&#34;, &#34;c&#34;}
</code></pre><p>Along the same lines, we can add a function for sorting using a comparison function, similar to <code>sort.Slice</code> but writing the function to take values rather than slice indexes.</p><pre tabindex=0><code>// sliceFn is an internal type that implements sort.Interface.
// The Less method calls the cmp field.
type sliceFn[T any] struct {
	s   []T
	cmp func(T, T) bool
}

func (s sliceFn[T]) Len() int           { return len(s.s) }
func (s sliceFn[T]) Less(i, j int) bool { return s.cmp(s.s[i], s.s[j]) }
func (s sliceFn[T]) Swap(i, j int)      { s.s[i], s.s[j] = s.s[j], s.s[i] }

// SliceFn sorts the slice s according to the function cmp.
func SliceFn[T any](s []T, cmp func(T, T) bool) {
	sort.Sort(sliceFn[T]{s, cmp})
}
</code></pre><p>An example of calling this might be:</p><pre tabindex=0><code>	var s []*Person
	// ...
	sort.SliceFn(s, func(p1, p2 *Person) bool { return p1.Name &lt; p2.Name })
</code></pre><h3 id=channels>Channels</h3><p>Many simple general purpose channel functions are never written, because they must be written using reflection and the caller must type assert the results. With this design they become straightforward to write.</p><pre tabindex=0><code>// Package chans implements various channel algorithms.
package chans

import &#34;runtime&#34;

// Drain drains any elements remaining on the channel.
func Drain[T any](c &lt;-chan T) {
	for range c {
	}
}

// Merge merges two channels of some element type into a single channel.
func Merge[T any](c1, c2 &lt;-chan T) &lt;-chan T {
	r := make(chan T)
	go func(c1, c2 &lt;-chan T, r chan&lt;- T) {
		defer close(r)
		for c1 != nil || c2 != nil {
			select {
			case v1, ok := &lt;-c1:
				if ok {
					r &lt;- v1
				} else {
					c1 = nil
				}
			case v2, ok := &lt;-c2:
				if ok {
					r &lt;- v2
				} else {
					c2 = nil
				}
			}
		}
	}(c1, c2, r)
	return r
}

// Ranger provides a convenient way to exit a goroutine sending values
// when the receiver stops reading them.
//
// Ranger returns a Sender and a Receiver. The Receiver provides a
// Next method to retrieve values. The Sender provides a Send method
// to send values and a Close method to stop sending values. The Next
// method indicates when the Sender has been closed, and the Send
// method indicates when the Receiver has been freed.
func Ranger[T any]() (*Sender[T], *Receiver[T]) {
	c := make(chan T)
	d := make(chan bool)
	s := &amp;Sender[T]{values: c, done: d}
	r := &amp;Receiver[T]{values: c, done: d}
	// The finalizer on the receiver will tell the sender
	// if the receiver stops listening.
	runtime.SetFinalizer(r, r.finalize)
	return s, r
}

// A Sender is used to send values to a Receiver.
type Sender[T any] struct {
	values chan&lt;- T
	done   &lt;-chan bool
}

// Send sends a value to the receiver. It reports whether any more
// values may be sent; if it returns false the value was not sent.
func (s *Sender[T]) Send(v T) bool {
	select {
	case s.values &lt;- v:
		return true
	case &lt;-s.done:
		// The receiver has stopped listening.
		return false
	}
}

// Close tells the receiver that no more values will arrive.
// After Close is called, the Sender may no longer be used.
func (s *Sender[T]) Close() {
	close(s.values)
}

// A Receiver receives values from a Sender.
type Receiver[T any] struct {
	values &lt;-chan T
	done  chan&lt;- bool
}

// Next returns the next value from the channel. The bool result
// reports whether the value is valid. If the value is not valid, the
// Sender has been closed and no more values will be received.
func (r *Receiver[T]) Next() (T, bool) {
	v, ok := &lt;-r.values
	return v, ok
}

// finalize is a finalizer for the receiver.
// It tells the sender that the receiver has stopped listening.
func (r *Receiver[T]) finalize() {
	close(r.done)
}
</code></pre><p>There is an example of using this function in the next section.</p><h3 id=containers>Containers</h3><p>One of the frequent requests for generics in Go is the ability to write compile-time type-safe containers. This design makes it easy to write a compile-time type-safe wrapper around an existing container; we won&rsquo;t write out an example for that. This design also makes it easy to write a compile-time type-safe container that does not use boxing.</p><p>Here is an example of an ordered map implemented as a binary tree. The details of how it works are not too important. The important points are:</p><ul><li>The code is written in a natural Go style, using the key and value types where needed.</li><li>The keys and values are stored directly in the nodes of the tree, not using pointers and not boxed as interface values.</li></ul><pre tabindex=0><code>// Package orderedmaps provides an ordered map, implemented as a binary tree.
package orderedmaps

import &#34;chans&#34;

// Map is an ordered map.
type Map[K, V any] struct {
	root    *node[K, V]
	compare func(K, K) int
}

// node is the type of a node in the binary tree.
type node[K, V any] struct {
	k           K
	v           V
	left, right *node[K, V]
}

// New returns a new map.
// Since the type parameter V is only used for the result,
// type inference does not work, and calls to New must always
// pass explicit type arguments.
func New[K, V any](compare func(K, K) int) *Map[K, V] {
	return &amp;Map[K, V]{compare: compare}
}

// find looks up k in the map, and returns either a pointer
// to the node holding k, or a pointer to the location where
// such a node would go.
func (m *Map[K, V]) find(k K) **node[K, V] {
	pn := &amp;m.root
	for *pn != nil {
		switch cmp := m.compare(k, (*pn).k); {
		case cmp &lt; 0:
			pn = &amp;(*pn).left
		case cmp &gt; 0:
			pn = &amp;(*pn).right
		default:
			return pn
		}
	}
	return pn
}

// Insert inserts a new key/value into the map.
// If the key is already present, the value is replaced.
// Reports whether this is a new key.
func (m *Map[K, V]) Insert(k K, v V) bool {
	pn := m.find(k)
	if *pn != nil {
		(*pn).v = v
		return false
	}
	*pn = &amp;node[K, V]{k: k, v: v}
	return true
}

// Find returns the value associated with a key, or zero if not present.
// The bool result reports whether the key was found.
func (m *Map[K, V]) Find(k K) (V, bool) {
	pn := m.find(k)
	if *pn == nil {
		var zero V // see the discussion of zero values, above
		return zero, false
	}
	return (*pn).v, true
}

// keyValue is a pair of key and value used when iterating.
type keyValue[K, V any] struct {
	k K
	v V
}

// InOrder returns an iterator that does an in-order traversal of the map.
func (m *Map[K, V]) InOrder() *Iterator[K, V] {
	type kv = keyValue[K, V] // convenient shorthand
	sender, receiver := chans.Ranger[kv]()
	var f func(*node[K, V]) bool
	f = func(n *node[K, V]) bool {
		if n == nil {
			return true
		}
		// Stop sending values if sender.Send returns false,
		// meaning that nothing is listening at the receiver end.
		return f(n.left) &amp;&amp;
			sender.Send(kv{n.k, n.v}) &amp;&amp;
			f(n.right)
	}
	go func() {
		f(m.root)
		sender.Close()
	}()
	return &amp;Iterator[K, V]{receiver}
}

// Iterator is used to iterate over the map.
type Iterator[K, V any] struct {
	r *chans.Receiver[keyValue[K, V]]
}

// Next returns the next key and value pair. The bool result reports
// whether the values are valid. If the values are not valid, we have
// reached the end.
func (it *Iterator[K, V]) Next() (K, V, bool) {
	kv, ok := it.r.Next()
	return kv.k, kv.v, ok
}
</code></pre><p>This is what it looks like to use this package:</p><pre tabindex=0><code>import &#34;container/orderedmaps&#34;

// Set m to an ordered map from string to string,
// using strings.Compare as the comparison function.
var m = orderedmaps.New[string, string](strings.Compare)

// Add adds the pair a, b to m.
func Add(a, b string) {
	m.Insert(a, b)
}
</code></pre><h3 id=append>Append</h3><p>The predeclared <code>append</code> function exists to replace the boilerplate otherwise required to grow a slice. Before <code>append</code> was added to the language, there was a function <code>Add</code> in the bytes package:</p><pre tabindex=0><code>// Add appends the contents of t to the end of s and returns the result.
// If s has enough capacity, it is extended in place; otherwise a
// new array is allocated and returned.
func Add(s, t []byte) []byte
</code></pre><p><code>Add</code> appended two <code>[]byte</code> values together, returning a new slice. That was fine for <code>[]byte</code>, but if you had a slice of some other type, you had to write essentially the same code to append more values. If this design were available back then, perhaps we would not have added <code>append</code> to the language. Instead, we could write something like this:</p><pre tabindex=0><code>// Package slices implements various slice algorithms.
package slices

// Append appends the contents of t to the end of s and returns the result.
// If s has enough capacity, it is extended in place; otherwise a
// new array is allocated and returned.
func Append[T any](s []T, t ...T) []T {
	lens := len(s)
	tot := lens + len(t)
	if tot &lt; 0 {
		panic(&#34;Append: cap out of range&#34;)
	}
	if tot &gt; cap(s) {
		news := make([]T, tot, tot + tot/2)
		copy(news, s)
		s = news
	}
	s = s[:tot]
	copy(s[lens:], t)
	return s
}
</code></pre><p>That example uses the predeclared <code>copy</code> function, but that&rsquo;s OK, we can write that one too:</p><pre tabindex=0><code>// Copy copies values from t to s, stopping when either slice is
// full, returning the number of values copied.
func Copy[T any](s, t []T) int {
	i := 0
	for ; i &lt; len(s) &amp;&amp; i &lt; len(t); i++ {
		s[i] = t[i]
	}
	return i
}
</code></pre><p>These functions can be used as one would expect:</p><pre tabindex=0><code>	s := slices.Append([]int{1, 2, 3}, 4, 5, 6)
	// Now s is []int{1, 2, 3, 4, 5, 6}.
	slices.Copy(s[3:], []int{7, 8, 9})
	// Now s is []int{1, 2, 3, 7, 8, 9}
</code></pre><p>This code doesn‘t implement the special case of appending or copying a <code>string</code> to a <code>[]byte</code>, and it’s unlikely to be as efficient as the implementation of the predeclared function. Still, this example shows that using this design would permit <code>append</code> and <code>copy</code> to be written generically, once, without requiring any additional special language features.</p><h3 id=metrics>Metrics</h3><p>In a <a href=https://medium.com/@sameer_74231/go-experience-report-for-generics-google-metrics-api-b019d597aaa4>Go experience report</a> Sameer Ajmani describes a metrics implementation. Each metric has a value and one or more fields. The fields have different types. Defining a metric requires specifying the types of the fields. The <code>Add</code> method takes the field types as arguments, and records an instance of that set of fields. The C++ implementation uses a variadic template. The Java implementation includes the number of fields in the name of the type. Both the C++ and Java implementations provide compile-time type-safe Add methods.</p><p>Here is how to use this design to provide similar functionality in Go with a compile-time type-safe <code>Add</code> method. Because there is no support for a variadic number of type arguments, we must use different names for a different number of arguments, as in Java. This implementation only works for comparable types. A more complex implementation could accept a comparison function to work with arbitrary types.</p><pre tabindex=0><code>// Package metrics provides a general mechanism for accumulating
// metrics of different values.
package metrics

import &#34;sync&#34;

// Metric1 accumulates metrics of a single value.
type Metric1[T comparable] struct {
	mu sync.Mutex
	m  map[T]int
}

// Add adds an instance of a value.
func (m *Metric1[T]) Add(v T) {
	m.mu.Lock()
	defer m.mu.Unlock()
	if m.m == nil {
		m.m = make(map[T]int)
	}
	m.m[v]++
}

// key2 is an internal type used by Metric2.
type key2[T1, T2 comparable] struct {
	f1 T1
	f2 T2
}

// Metric2 accumulates metrics of pairs of values.
type Metric2[T1, T2 comparable] struct {
	mu sync.Mutex
	m  map[key2[T1, T2]]int
}

// Add adds an instance of a value pair.
func (m *Metric2[T1, T2]) Add(v1 T1, v2 T2) {
	m.mu.Lock()
	defer m.mu.Unlock()
	if m.m == nil {
		m.m = make(map[key2[T1, T2]]int)
	}
	m.m[key2[T1, T2]{v1, v2}]++
}

// key3 is an internal type used by Metric3.
type key3[T1, T2, T3 comparable] struct {
	f1 T1
	f2 T2
	f3 T3
}

// Metric3 accumulates metrics of triples of values.
type Metric3[T1, T2, T3 comparable] struct {
	mu sync.Mutex
	m  map[key3[T1, T2, T3]]int
}

// Add adds an instance of a value triplet.
func (m *Metric3[T1, T2, T3]) Add(v1 T1, v2 T2, v3 T3) {
	m.mu.Lock()
	defer m.mu.Unlock()
	if m.m == nil {
		m.m = make(map[key3[T1, T2, T3]]int)
	}
	m.m[key3[T1, T2, T3]{v1, v2, v3}]++
}

// Repeat for the maximum number of permitted arguments.
</code></pre><p>Using this package looks like this:</p><pre tabindex=0><code>import &#34;metrics&#34;

var m = metrics.Metric2[string, int]{}

func F(s string, i int) {
	m.Add(s, i) // this call is type checked at compile time
}
</code></pre><p>This implementation has a certain amount of repetition due to the lack of support for variadic type parameters. Using the package, though, is easy and type safe.</p><h3 id=list-transform>List transform</h3><p>While slices are efficient and easy to use, there are occasional cases where a linked list is appropriate. This example primarily shows transforming a linked list of one type to another type, as an example of using different instantiations of the same generic type.</p><pre tabindex=0><code>// Package lists provides a linked list of any type.
package lists

// List is a linked list.
type List[T any] struct {
	head, tail *element[T]
}

// An element is an entry in a linked list.
type element[T any] struct {
	next *element[T]
	val  T
}

// Push pushes an element to the end of the list.
func (lst *List[T]) Push(v T) {
	if lst.tail == nil {
		lst.head = &amp;element[T]{val: v}
		lst.tail = lst.head
	} else {
		lst.tail.next = &amp;element[T]{val: v}
		lst.tail = lst.tail.next
	}
}

// Iterator ranges over a list.
type Iterator[T any] struct {
	next **element[T]
}

// Range returns an Iterator starting at the head of the list.
func (lst *List[T]) Range() *Iterator[T] {
	return &amp;Iterator[T]{next: &amp;lst.head}
}

// Next advances the iterator.
// It reports whether there are more elements.
func (it *Iterator[T]) Next() bool {
	if *it.next == nil {
		return false
	}
	it.next = &amp;(*it.next).next
	return true
}

// Val returns the value of the current element.
// The bool result reports whether the value is valid.
func (it *Iterator[T]) Val() (T, bool) {
	if *it.next == nil {
		var zero T
		return zero, false
	}
	return (*it.next).val, true
}

// Transform runs a transform function on a list returning a new list.
func Transform[T1, T2 any](lst *List[T1], f func(T1) T2) *List[T2] {
	ret := &amp;List[T2]{}
	it := lst.Range()
	for {
		if v, ok := it.Val(); ok {
			ret.Push(f(v))
		}
		if !it.Next() {
			break
		}
	}
	return ret
}
</code></pre><h3 id=dot-product>Dot product</h3><p>A generic dot product implementation that works for slices of any numeric type.</p><pre tabindex=0><code>// Numeric is a constraint that matches any numeric type.
// It would likely be in a constraints package in the standard library.
type Numeric interface {
	~int | ~int8 | ~int16 | ~int32 | ~int64 |
		~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr |
		~float32 | ~float64 |
		~complex64 | ~complex128
}

// DotProduct returns the dot product of two slices.
// This panics if the two slices are not the same length.
func DotProduct[T Numeric](s1, s2 []T) T {
	if len(s1) != len(s2) {
		panic(&#34;DotProduct: slices of unequal length&#34;)
	}
	var r T
	for i := range s1 {
		r += s1[i] * s2[i]
	}
	return r
}
</code></pre><p>(Note: the generics implementation approach may affect whether <code>DotProduct</code> uses FMA, and thus what the exact results are when using floating point types. It&rsquo;s not clear how much of a problem this is, or whether there is any way to fix it.)</p><h3 id=absolute-difference>Absolute difference</h3><p>Compute the absolute difference between two numeric values, by using an <code>Abs</code> method. This uses the same <code>Numeric</code> constraint defined in the last example.</p><p>This example uses more machinery than is appropriate for the simple case of computing the absolute difference. It is intended to show how the common part of algorithms can be factored into code that uses methods, where the exact definition of the methods can vary based on the kind of type being used.</p><p>Note: the code used in this example will not work in Go 1.18. We hope to resolve this and make it work in future releases.</p><pre tabindex=0><code>// NumericAbs matches numeric types with an Abs method.
type NumericAbs[T any] interface {
	~int | ~int8 | ~int16 | ~int32 | ~int64 |
		~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr |
		~float32 | ~float64 |
		~complex64 | ~complex128
	Abs() T
}

// AbsDifference computes the absolute value of the difference of
// a and b, where the absolute value is determined by the Abs method.
func AbsDifference[T NumericAbs[T]](a, b T) T {
	d := a - b
	return d.Abs()
}
</code></pre><p>We can define an <code>Abs</code> method appropriate for different numeric types.</p><pre tabindex=0><code>// OrderedNumeric matches numeric types that support the &lt; operator.
type OrderedNumeric interface {
	~int | ~int8 | ~int16 | ~int32 | ~int64 |
		~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr |
		~float32 | ~float64
}

// Complex matches the two complex types, which do not have a &lt; operator.
type Complex interface {
	~complex64 | ~complex128
}

// OrderedAbs is a helper type that defines an Abs method for
// ordered numeric types.
type OrderedAbs[T OrderedNumeric] T

func (a OrderedAbs[T]) Abs() OrderedAbs[T] {
	if a &lt; 0 {
		return -a
	}
	return a
}

// ComplexAbs is a helper type that defines an Abs method for
// complex types.
type ComplexAbs[T Complex] T

func (a ComplexAbs[T]) Abs() ComplexAbs[T] {
	d := math.Hypot(float64(real(a)), float64(imag(a)))
	return ComplexAbs[T](complex(d, 0))
}
</code></pre><p>We can then define functions that do the work for the caller by converting to and from the types we just defined.</p><pre tabindex=0><code>// OrderedAbsDifference returns the absolute value of the difference
// between a and b, where a and b are of an ordered type.
func OrderedAbsDifference[T OrderedNumeric](a, b T) T {
	return T(AbsDifference(OrderedAbs[T](a), OrderedAbs[T](b)))
}

// ComplexAbsDifference returns the absolute value of the difference
// between a and b, where a and b are of a complex type.
func ComplexAbsDifference[T Complex](a, b T) T {
	return T(AbsDifference(ComplexAbs[T](a), ComplexAbs[T](b)))
}
</code></pre><p>It&rsquo;s worth noting that this design is not powerful enough to write code like the following:</p><pre tabindex=0><code>// This function is INVALID.
func GeneralAbsDifference[T Numeric](a, b T) T {
	switch (interface{})(a).(type) {
	case int, int8, int16, int32, int64,
		uint, uint8, uint16, uint32, uint64, uintptr,
		float32, float64:
		return OrderedAbsDifference(a, b) // INVALID
	case complex64, complex128:
		return ComplexAbsDifference(a, b) // INVALID
	}
}
</code></pre><p>The calls to <code>OrderedAbsDifference</code> and <code>ComplexAbsDifference</code> are invalid, because not all the types that implement the <code>Numeric</code> constraint can implement the <code>OrderedNumeric</code> or <code>Complex</code> constraints. Although the type switch means that this code would conceptually work at run time, there is no support for writing this code at compile time. This is another way of expressing one of the omissions listed above: this design does not provide for specialization.</p><h2 id=acknowledgements>Acknowledgements</h2><p>We‘d like to thank many people on the Go team, many contributors to the Go issue tracker, and all the people who have shared their ideas and their feedback on earlier design drafts. We read all of it, and we’re grateful.</p><p>For this version of the proposal in particular we received detailed feedback from Josh Bleecher-Snyder, Jon Bodner, Dave Cheney, Jaana Dogan, Kevin Gillette, Mitchell Hashimoto, Chris Hines, Bill Kennedy, Ayke van Laethem, Daniel Martí, Elena Morozova, Roger Peppe, and Ronna Steinberg.</p><h2 id=appendix>Appendix</h2><p>This appendix covers various details of the design that don&rsquo;t seem significant enough to cover in earlier sections.</p><h3 id=generic-type-aliases>Generic type aliases</h3><p>A type alias may refer to a generic type, but the type alias may not have its own parameters. This restriction exists because it is unclear how to handle a type alias with type parameters that have constraints.</p><pre tabindex=0><code>type VectorAlias = Vector
</code></pre><p>In this case uses of the type alias will have to provide type arguments appropriate for the generic type being aliased.</p><pre tabindex=0><code>var v VectorAlias[int]
</code></pre><p>Type aliases may also refer to instantiated types.</p><pre tabindex=0><code>type VectorInt = Vector[int]
</code></pre><h3 id=instantiating-a-function>Instantiating a function</h3><p>Go normally permits you to refer to a function without passing any arguments, producing a value of function type. You may not do this with a function that has type parameters; all type arguments must be known at compile time. That said, you can instantiate the function, by passing type arguments, but you don&rsquo;t have to call the instantiation. This will produce a function value with no type parameters.</p><pre tabindex=0><code>// PrintInts is type func([]int).
var PrintInts = Print[int]
</code></pre><h3 id=embedded-type-parameter>Embedded type parameter</h3><p>When a generic type is a struct, and the type parameter is embedded as a field in the struct, the name of the field is the name of the type parameter.</p><pre tabindex=0><code>// A Lockable is a value that may be safely simultaneously accessed
// from multiple goroutines via the Get and Set methods.
type Lockable[T any] struct {
	T
	mu sync.Mutex
}

// Get returns the value stored in a Lockable.
func (l *Lockable[T]) Get() T {
	l.mu.Lock()
	defer l.mu.Unlock()
	return l.T
}

// Set sets the value in a Lockable.
func (l *Lockable[T]) Set(v T) {
	l.mu.Lock()
	defer l.mu.Unlock()
	l.T = v
}
</code></pre><h3 id=embedded-type-parameter-methods>Embedded type parameter methods</h3><p>When a generic type is a struct, and the type parameter is embedded as a field in the struct, any methods of the type parameter&rsquo;s constraint are promoted to be methods of the struct. (For purposes of <a href=https://golang.org/ref/spec#Selectors>selector resolution</a>, these methods are treated as being at depth 0 of the type parameter, even if in the actual type argument the methods were themselves promoted from an embedded type.)</p><pre tabindex=0><code>// NamedInt is an int with a name. The name can be any type with
// a String method.
type NamedInt[Name fmt.Stringer] struct {
	Name
	val int
}

// Name returns the name of a NamedInt.
func (ni NamedInt[Name]) Name() string {
	// The String method is promoted from the embedded Name.
	return ni.String()
}
</code></pre><h3 id=embedded-instantiated-type>Embedded instantiated type</h3><p>When embedding an instantiated type, the name of the field is the name of type without the type arguments.</p><pre tabindex=0><code>type S struct {
	T[int] // field name is T
}

func F(v S) int {
	return v.T // not v.T[int]
}
</code></pre><h3 id=generic-types-as-type-switch-cases>Generic types as type switch cases</h3><p>A generic type may be used as the type in a type assertion or as a case in a type switch.</p><p>Here are some trivial examples:</p><pre tabindex=0><code>func Assertion[T any](v interface{}) (T, bool) {
	t, ok := v.(T)
	return t, ok
}

func Switch[T any](v interface{}) (T, bool) {
	switch v := v.(type) {
	case T:
		return v, true
	default:
		var zero T
		return zero, false
	}
}
</code></pre><p>In a type switch, it&rsquo;s OK if a generic type turns out to duplicate some other case in the type switch. The first matching case is chosen.</p><pre tabindex=0><code>func Switch2[T any](v interface{}) int {
	switch v.(type) {
	case T:
		return 0
	case string:
		return 1
	default:
		return 2
	}
}

// S2a will be set to 0.
var S2a = Switch2[string](&#34;a string&#34;)

// S2b will be set to 1.
var S2b = Switch2[int](&#34;another string&#34;)
</code></pre><h3 id=method-sets-of-constraint-elements>Method sets of constraint elements</h3><p>Much as the type set of an interface type is the intersection of the type sets of the elements of the interface, the method set of an interface type can be defined as the union of the method sets of the elements of the interface. In most cases, an embedded element will have no methods, and as such will not contribute any methods to the interface type. That said, for completeness, we&rsquo;ll note that the method set of <code>~T</code> is the method set of <code>T</code>. The method set of a union element is the intersection of the method sets of the elements of the union. These rules are implied by the definition of type sets, but they are not needed for understanding the behavior of constraints.</p><h3 id=permitting-constraints-as-ordinary-interface-types>Permitting constraints as ordinary interface types</h3><p>This is a feature we are not suggesting now, but could consider for later versions of the language.</p><p>We have proposed that constraints can embed some additional elements. With this proposal, any interface type that embeds anything other than an interface type can only be used as a constraint or as an embedded element in another constraint. A natural next step would be to permit using interface types that embed any type, or that embed these new elements, as an ordinary type, not just as a constraint.</p><p>We are not proposing that now. But the rules for type sets and method sets above describe how they would behave. Any type that is an element of the type set could be assigned to such an interface type. A value of such an interface type would permit calling any member of the method set.</p><p>This would permit a version of what other languages call sum types or union types. It would be a Go interface type to which only specific types could be assigned. Such an interface type could still take the value <code>nil</code>, of course, so it would not be quite the same as a typical sum type as found in other languages.</p><p>Another natural next step would be to permit approximation elements and union elements in type switch cases. That would make it easier to determine the contents of an interface type that used those elements. That said, approximation elements and union elements are not types, and as such could not be used in type assertions.</p><h3 id=type-inference-for-composite-literals>Type inference for composite literals</h3><p>This is a feature we are not suggesting now, but could consider for later versions of the language.</p><p>We could also consider supporting type inference for composite literals of generic types.</p><pre tabindex=0><code>type Pair[T any] struct { f1, f2 T }
var V = Pair{1, 2} // inferred as Pair[int]{1, 2}
</code></pre><p>It&rsquo;s not clear how often this will arise in real code.</p><h3 id=type-inference-for-generic-function-arguments>Type inference for generic function arguments</h3><p>This is a feature we are not suggesting now, but could consider for later versions of the language.</p><p>In the following example, consider the call to <code>Find</code> in <code>FindClose</code>. Type inference can determine that the type argument to <code>Find</code> is <code>T4</code>, and from that we know that the type of the final argument must be <code>func(T4, T4) bool</code>, and from that we could deduce that the type argument to <code>IsClose</code> must also be <code>T4</code>. However, the type inference algorithm described earlier cannot do that, so we must explicitly write <code>IsClose[T4]</code>.</p><p>This may seem esoteric at first, but it comes up when passing generic functions to generic <code>Map</code> and <code>Filter</code> functions.</p><pre tabindex=0><code>// Differ has a Diff method that returns how different a value is.
type Differ[T1 any] interface {
	Diff(T1) int
}

// IsClose returns whether a and b are close together, based on Diff.
func IsClose[T2 Differ](a, b T2) bool {
	return a.Diff(b) &lt; 2
}

// Find returns the index of the first element in s that matches e,
// based on the cmp function. It returns -1 if no element matches.
func Find[T3 any](s []T3, e T3, cmp func(a, b T3) bool) int {
	for i, v := range s {
		if cmp(v, e) {
			return i
		}
	}
	return -1
}

// FindClose returns the index of the first element in s that is
// close to e, based on IsClose.
func FindClose[T4 Differ](s []T4, e T4) int {
	// With the current type inference algorithm we have to
	// explicitly write IsClose[T4] here, although it
	// is the only type argument we could possibly use.
	return Find(s, e, IsClose[T4])
}
</code></pre><h3 id=reflection-on-type-arguments>Reflection on type arguments</h3><p>Although we don‘t suggest changing the reflect package, one possibility to consider for the future would be to add two new methods to <code>reflect.Type</code>: <code>NumTypeArgument() int</code> would return the number of type arguments to a type, and <code>TypeArgument(i) Type</code> would return the i’th type argument. <code>NumTypeArgument</code> would return non-zero for an instantiated generic type. Similar methods could be defined for <code>reflect.Value</code>, for which <code>NumTypeArgument</code> would return non-zero for an instantiated generic function. There might be programs that care about this information.</p><div class=td-page-meta__lastmod>最后修改 October 10, 2024: <a href=https://github.com/before80/go_docs/commit/a4b8f854f736d720ad19943e1274acc7bb0e3264>更新 (a4b8f85)</a></div></div></main></div></div><footer class="td-footer row d-print-none"><div class=container-fluid><div class="row mx-md-2"><div class="td-footer__left col-6 col-sm-4 order-sm-1"><ul class=td-footer__links-list><li class=td-footer__links-item data-bs-toggle=tooltip title="User mailing list" aria-label="User mailing list"><a target=_blank rel=noopener href=https://example.org/mail aria-label="User mailing list"><i class="fa fa-envelope"></i></a></li><li class=td-footer__links-item data-bs-toggle=tooltip title=Twitter aria-label=Twitter><a target=_blank rel=noopener href=https://example.org/twitter aria-label=Twitter><i class="fab fa-twitter"></i></a></li><li class=td-footer__links-item data-bs-toggle=tooltip title="Stack Overflow" aria-label="Stack Overflow"><a target=_blank rel=noopener href=https://example.org/stack aria-label="Stack Overflow"><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="td-footer__right col-6 col-sm-4 order-sm-3"><ul class=td-footer__links-list><li class=td-footer__links-item data-bs-toggle=tooltip title=GitHub aria-label=GitHub><a target=_blank rel=noopener href=https://github.com/before80/go_docs aria-label=GitHub><i class="fab fa-github"></i></a></li><li class=td-footer__links-item data-bs-toggle=tooltip title=Slack aria-label=Slack><a target=_blank rel=noopener href=https://example.org/slack aria-label=Slack><i class="fab fa-slack"></i></a></li><li class=td-footer__links-item data-bs-toggle=tooltip title="Developer mailing list" aria-label="Developer mailing list"><a target=_blank rel=noopener href=https://example.org/mail aria-label="Developer mailing list"><i class="fa fa-envelope"></i></a></li></ul></div><div class="td-footer__center col-12 col-sm-4 py-2 order-sm-2"><span class=td-footer__copyright>&copy;
2025
<span class=td-footer__authors>作者zlongx</span></span><span class=td-footer__all_rights_reserved>保留所有权利</span><span class=ms-2><a href=https://policies.google.com/privacy target=_blank rel=noopener>隐私政策</a></span><p class="td-footer__about mt-2"><a href=/go_docs/thirdPkg/lua/about/>关于</a></p></div></div></div></footer></div><style>.markmap>svg{width:100%;height:300px}</style><script>window.markmap={autoLoader:{manual:!0,onReady(){const{autoLoader:e,builtInPlugins:t}=window.markmap;e.transformPlugins=t.filter(e=>e.name!=="prism")}}}</script><script src=https://cdn.jsdelivr.net/npm/markmap-autoloader></script>
<script src=/go_docs/js/main.min.4fb55790d81bdab4cd314586e186d385cad5508994c45abe27c6daee34d84160.js integrity="sha256-T7VXkNgb2rTNMUWG4YbThcrVUImUxFq+J8ba7jTYQWA=" crossorigin=anonymous></script>
<script defer src=/go_docs/js/click-to-copy.min.14c7dd84004258325d147b971421f1d4dfd3f28500954f32ef71d1cfd0938f51.js integrity="sha256-FMfdhABCWDJdFHuXFCHx1N/T8oUAlU8y73HRz9CTj1E=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@docsearch/js@3.6.0 integrity="sha512-FtDaTWf3IS29TLuYzTPlytjGqcXkwrzG9ivq7xXElnOZeiYTbcIy/hwXAgrrRNnI0+PfN+WFz4/+4phhJmuS8Q==" crossorigin=anonymous></script>
<script type=text/javascript>const containers=["#docsearch-0","#docsearch-1"];for(let e of containers)docsearch({container:e,appId:"DV76UK9EIH",apiKey:"227dec0ac6cbc8dfad748f27b2974507",indexName:"go-"})</script><script src=/go_docs/js/tabpane-persist.js></script>
<script src=/go_docs/js/tocbot.min.js></script>
<script src=/go_docs/js/markmap-autoloader.js></script>
<script type=text/javascript>window.addEventListener("load",function(){tocbot.init({tocSelector:".td-toc",contentSelector:".td-content",headingSelector:"h2, h3, h4, h5, h6",ignoreHiddenElements:!0,collapseDepth:6});let t=0,e=0,n=document.getElementById("show-timer"),s=document.getElementById("advice-reading-time"),o=s.textContent.trim();function i(){e++,e>=60&&(e=0,t++);let i=e<10?"0"+e:e;s!==null?n.textContent=t+":"+i+" <- "+o:n.textContent=t+":"+i}setInterval(i,1e3)})</script><script src=/go_docs/js/jquery-3.6.3.min.js></script>
<script src=/go_docs/js/deal-zero-width-space.js></script>
<script src=/go_docs/js/tabpane-persist.js></script></body></html>