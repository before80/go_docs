<!doctype html>
<html itemscope itemtype="http://schema.org/WebPage" lang="cn" class="no-js">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="generator" content="Hugo 0.111.3">
<link rel="canonical" type="text/html" href="http://ngd.cn/docs/References/GoModulesReference/">
<link rel="alternate" type="application/rss&#43;xml" href="http://ngd.cn/docs/References/GoModulesReference/index.xml">
<meta name="robots" content="noindex, nofollow">


<link rel="shortcut icon" href="/favicons/favicon.ico" >
<link rel="apple-touch-icon" href="/favicons/apple-touch-icon-180x180.png" sizes="180x180">
<link rel="icon" type="image/png" href="/favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="/favicons/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/favicons/android-36x36.png" sizes="36x36">
<link rel="icon" type="image/png" href="/favicons/android-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="/favicons/android-72x72.png" sizes="72x72">
<link rel="icon" type="image/png" href="/favicons/android-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="/favicons/android-144x144.png" sizes="144x144">
<link rel="icon" type="image/png" href="/favicons/android-192x192.png" sizes="192x192">

<title>Go Modules Reference | go文档集</title>
<meta name="description" content="The most popular HTML, CSS, and JS library in the world.">
<meta property="og:title" content="Go Modules Reference" />
<meta property="og:description" content="The most popular HTML, CSS, and JS library in the world." />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://ngd.cn/docs/References/GoModulesReference/" />
<meta itemprop="name" content="Go Modules Reference">
<meta itemprop="description" content="The most popular HTML, CSS, and JS library in the world."><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go Modules Reference"/>
<meta name="twitter:description" content="The most popular HTML, CSS, and JS library in the world."/>




<link rel="preload" href="/scss/main.min.bb1f3a37154c4661ae02d3cb1a733edd8005db70f626370ca004c689a63ab7d4.css" as="style">
<link href="/scss/main.min.bb1f3a37154c4661ae02d3cb1a733edd8005db70f626370ca004c689a63ab7d4.css" rel="stylesheet" integrity="">

<link href="/css/extra.css" rel="stylesheet">
<script
  src="https://code.jquery.com/jquery-3.6.0.min.js"
  integrity="sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK"
  crossorigin="anonymous"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-00000000-0"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'UA-00000000-0');
}
</script>
  </head>
  <body class="td-section">
    <header>
      <nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar">
  <a class="navbar-brand" href="/"><span class="navbar-brand__logo navbar-logo"><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 500 500" style="enable-background:new 0 0 500 500"><g><path style="fill:#fff" d="M116.8525 421.9722c-5.7041.0-10.3442-4.3127-10.3442-9.6129V88.183c0-5.3002 4.6401-9.6117 10.3442-9.6117H320.858c3.0347.0 9.3959.5498 11.7506 2.6302l.3545.3442 58.905 63.2912c2.3101 2.491 2.9202 8.4928 2.9202 11.3184v256.2039c0 5.3002-4.6407 9.6129-10.3436 9.6129H116.8525z"/><g><g><g><path style="fill:#767676" d="M384.4445 423.2066H116.852c-6.3839.0-11.5786-4.8658-11.5786-10.8474V88.1831c0-5.9804 5.1947-10.8461 11.5786-10.8461h204.0062c.377.0 9.2786.0329 12.568 2.9389l.3947.3833 58.9508 63.337c3.2135 3.4652 3.2514 11.7924 3.2514 12.1593v256.2036C396.0231 418.3408 390.8284 423.2066 384.4445 423.2066zM116.5079 411.9189c.0848.0278.1999.0531.3441.0531h267.5925c.1442.0.2581-.0253.3441-.0531V156.1556c-.0076-.9033-.3593-3.7347-.7034-5.0037l-57.6527-61.9416c-1.4651-.3176-4.4533-.6389-5.5742-.6389H116.852c-.143.0-.2594.024-.3441.0531V411.9189zm267.4533-261.149zM327.0321 89.371v.0013V89.371z"/></g></g></g><g><g><path style="fill:#5b7fc0" d="M189.0874 210.1754l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.025 2.454-11.4897 6.4116-15.4473C177.5953 212.627 183.0601 210.1742 189.0874 210.1754zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403S197.0816 234.1722 197.0804 232.033z"/><path style="opacity:.3;fill:#fff" d="M189.0898 210.176c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 212.6276 183.0612 210.176 189.0898 210.176zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 236.239 197.0839 234.2399 197.0839 232.0372z"/><g><defs><path id="SVGID_1_" d="M194.7376 237.6875c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.999 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 234.2399 196.1861 236.239 194.7376 237.6875z"/></defs><clipPath id="SVGID_2_"><use xlink:href="#SVGID_1_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_2_);fill:#fff" d="M190.0704 225.0237c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 225.7247 191.9774 225.0237 190.0704 225.0237z"/><path style="opacity:.13;clip-path:url(#SVGID_2_);fill:#020202" d="M190.0704 225.0237c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 225.7247 191.9774 225.0237 190.0704 225.0237z"/></g><g><defs><path id="SVGID_3_" d="M189.0898 210.176c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 212.6276 183.0612 210.176 189.0898 210.176zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 236.239 197.0839 234.2399 197.0839 232.0372z"/></defs><clipPath id="SVGID_4_"><use xlink:href="#SVGID_3_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_4_);fill:#5b7fc0" d="M172.6595 215.6045c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8612 12.0547.0024 21.8636-9.797 21.8613-21.8612.0024-3.8475-1.0151-7.6326-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 209.1953 176.6171 211.647 172.6595 215.6045z"/></g></g><rect x="198.8952" y="225.1043" style="fill:#5b7fc0" width="122.6266" height="13.8671"/></g><g><path style="fill:#d95140" d="M189.0874 155.7611l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.0249 2.454-11.4897 6.4116-15.4473C177.5953 158.2128 183.0601 155.7599 189.0874 155.7611zm7.993 21.8577c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403C196.2508 181.7667 197.0816 179.758 197.0804 177.6188z"/><path style="opacity:.3;fill:#fff" d="M189.0898 155.7617c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 158.2134 183.0612 155.7617 189.0898 155.7617zm7.9941 21.8613c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 181.8248 197.0839 179.8256 197.0839 177.623z"/><g><defs><path id="SVGID_5_" d="M194.7376 183.2733c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.9989 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 179.8256 196.1861 181.8248 194.7376 183.2733z"/></defs><clipPath id="SVGID_6_"><use xlink:href="#SVGID_5_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_6_);fill:#fff" d="M190.0704 170.6095c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 171.3104 191.9774 170.6095 190.0704 170.6095z"/><path style="opacity:.13;clip-path:url(#SVGID_6_);fill:#020202" d="M190.0704 170.6095c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 171.3104 191.9774 170.6095 190.0704 170.6095z"/></g><g><defs><path id="SVGID_7_" d="M189.0898 155.7617c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 158.2134 183.0612 155.7617 189.0898 155.7617zm7.9941 21.8613c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 181.8248 197.0839 179.8256 197.0839 177.623z"/></defs><clipPath id="SVGID_8_"><use xlink:href="#SVGID_7_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_8_);fill:#d95140" d="M172.6595 161.1903c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8613 12.0547.0024 21.8636-9.797 21.8613-21.8613.0024-3.8474-1.0151-7.6326-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 154.7811 176.6171 157.2327 172.6595 161.1903z"/></g><rect x="198.8952" y="170.69" style="fill:#d95140" width="122.6266" height="13.8671"/></g><g><g><path style="fill:#56a55c" d="M189.5379 264.6147l.0012-.0012c7.7751.0012 15.0294 4.1862 18.932 10.9235 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032-5.8394.0-11.3281-2.2733-15.458-6.4032-4.13-4.13-6.4032-9.6186-6.4056-15.4628.0012-6.0249 2.454-11.4897 6.4116-15.4472C178.0458 267.0663 183.5105 264.6135 189.5379 264.6147zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6538 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403C196.7013 290.6202 197.5321 288.6115 197.5309 286.4723z"/><path style="opacity:.3;fill:#fff" d="M189.5403 264.6153c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8065-21.8612-21.8613.0-6.0285 2.4516-11.492 6.4116-15.452C178.0482 267.0669 183.5117 264.6153 189.5403 264.6153zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.6366 290.6783 197.5344 288.6792 197.5344 286.4765z"/><g><defs><path id="SVGID_9_" d="M195.1881 292.1268c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.9989 7.9942-7.9941 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.5344 288.6792 196.6366 290.6783 195.1881 292.1268z"/></defs><clipPath id="SVGID_10_"><use xlink:href="#SVGID_9_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_10_);fill:#fff" d="M190.5209 279.463c-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7446-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9941 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C194.239 280.164 192.4279 279.463 190.5209 279.463z"/><path style="opacity:.13;clip-path:url(#SVGID_10_);fill:#020202" d="M190.5209 279.463c-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7446-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9941 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C194.239 280.164 192.4279 279.463 190.5209 279.463z"/></g><g><defs><path id="SVGID_11_" d="M189.5403 264.6153c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8065-21.8612-21.8613.0-6.0285 2.4516-11.492 6.4116-15.452C178.0482 267.0669 183.5117 264.6153 189.5403 264.6153zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.6366 290.6783 197.5344 288.6792 197.5344 286.4765z"/></defs><clipPath id="SVGID_12_"><use xlink:href="#SVGID_11_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_12_);fill:#56a55c" d="M173.11 270.0439c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8613 12.0547.0024 21.8636-9.797 21.8613-21.8613.0024-3.8474-1.0151-7.6326-2.9353-10.9462-3.8977-6.7325-11.1497-10.9151-18.926-10.9151C182.5311 263.6346 177.0676 266.0863 173.11 270.0439z"/></g></g><rect x="199.3456" y="279.5436" style="fill:#56a55c" width="122.6266" height="13.8671"/></g><g><g><path style="fill:#f1bc42" d="M189.0874 318.7208l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3305-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.025 2.454-11.4897 6.4116-15.4472C177.5953 321.1724 183.0601 318.7196 189.0874 318.7208zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403S197.0816 342.7176 197.0804 340.5784z"/><path style="opacity:.3;fill:#fff" d="M189.0898 318.7214c7.7763.0 15.0283 4.1826 18.926 10.915 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8612-12.0547.0024-21.8636-9.8065-21.8612-21.8612.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 321.173 183.0612 318.7214 189.0898 318.7214zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 344.7844 197.0839 342.7853 197.0839 340.5826z"/><g><defs><path id="SVGID_13_" d="M194.7376 346.2329c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.999 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 342.7853 196.1861 344.7844 194.7376 346.2329z"/></defs><clipPath id="SVGID_14_"><use xlink:href="#SVGID_13_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_14_);fill:#fff" d="M190.0704 333.5691c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0834 6.1218 2.8788C193.7885 334.2701 191.9774 333.5691 190.0704 333.5691z"/><path style="opacity:.13;clip-path:url(#SVGID_14_);fill:#020202" d="M190.0704 333.5691c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0834 6.1218 2.8788C193.7885 334.2701 191.9774 333.5691 190.0704 333.5691z"/></g><g><defs><path id="SVGID_15_" d="M189.0898 318.7214c7.7763.0 15.0283 4.1826 18.926 10.915 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8612-12.0547.0024-21.8636-9.8065-21.8612-21.8612.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 321.173 183.0612 318.7214 189.0898 318.7214zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 344.7844 197.0839 342.7853 197.0839 340.5826z"/></defs><clipPath id="SVGID_16_"><use xlink:href="#SVGID_15_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_16_);fill:#f1bc42" d="M172.6595 324.15c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8612 12.0547.0024 21.8636-9.797 21.8613-21.8612.0024-3.8474-1.0151-7.6327-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 317.7407 176.6171 320.1924 172.6595 324.15z"/></g></g><rect x="198.8952" y="333.6497" style="fill:#f1bc42" width="122.6266" height="13.8671"/></g></g></svg></span><span class="navbar-brand__name">go文档集</span></a>
  <div class="td-navbar-nav-scroll ml-md-auto" id="main_navbar">
    <ul class="navbar-nav mt-2 mt-lg-0">
      <li class="nav-item mr-4 mb-2 mb-lg-0">
        <a class="nav-link active" href="/docs/"><span class="active">文档</span></a>
      </li>
      </ul>
  </div>
  <div class="navbar-nav d-none d-lg-block">
    <div class="td-search">
  <div class="td-search__icon"></div>
  <input type="search" class="td-search__input form-control td-search-input" placeholder="" aria-label="" autocomplete="off">
</div>

  </div>
</nav>
    </header>
    <div class="container-fluid td-outer">
      <div class="td-main">
        <div class="row flex-xl-nowrap">
          <main class="col-12 col-md-9 col-xl-8 pl-md-5" role="main">
            




<div class="td-content">
<div class="pageinfo pageinfo-primary d-print-none">
<p>

<a href="#" onclick="print();return false;"></a>.
</p><p>
<a href="/docs/References/GoModulesReference/"></a>.
</p>
</div>



<h1 class="title">Go Modules Reference</h1>





    <ul>
    
  
  
  
  

  
    
    
	
<li>1: <a href="#pg-2a0512809248d42a0d8f3db252862f28">简介</a></li>


    
  
    
    
	
<li>2: <a href="#pg-6399010d356a063c606eddd990f65e9c">模块、包和版本</a></li>


    
  
    
    
	
<li>3: <a href="#pg-e5a749e2b095eb21e9034038f8db3e55">go.mod 文件</a></li>


    
  
    
    
	
<li>4: <a href="#pg-a2f3c0a94659ff151eed86d11c371f72">最小版本选择 (MVS)</a></li>


    
  
    
    
	
<li>5: <a href="#pg-74008b805544fd3d8aab4b9f34b8aac3">模块图的修剪</a></li>


    
  
    
    
	
<li>6: <a href="#pg-cb69927624b9473a082eb855aaa8d583">工作区</a></li>


    
  
    
    
	
<li>7: <a href="#pg-f68c752dd537895a2595481a9e6b35e7">与非模块存储库的兼容性</a></li>


    
  
    
    
	
<li>8: <a href="#pg-a5aab63856f0e0c52b2e02d67fbdf698">具有模块感知的命令</a></li>


    
  
    
    
	
<li>9: <a href="#pg-e75c5c33eb8f2925135889dd2765fa8d">模块代理</a></li>


    
  
    
    
	
<li>10: <a href="#pg-5b15e9e426fb8d044d2c0cbf6caefb23">版本控制系统</a></li>


    
  
    
    
	
<li>11: <a href="#pg-ce178d2d9de1acb9e30aaf12fe74171a">模块zip文件</a></li>


    
  
    
    
	
<li>12: <a href="#pg-0506cdbac677dc7d8ce10022df8bac37">私有模块</a></li>


    
  
    
    
	
<li>13: <a href="#pg-83706bb3f8d11c662bef82051b50593b">模块缓存</a></li>


    
  
    
    
	
<li>14: <a href="#pg-cba8b7700bd065b7d7d571cf0b19c65a">验证模块</a></li>


    
  
    
    
	
<li>15: <a href="#pg-cf1289104d703cf5e4a8add67477c590">环境变量</a></li>


    
  
    
    
	
<li>16: <a href="#pg-f8defab094078f5ecc58e86abcfcf2ad">词汇表</a></li>


    
  

    </ul>


<div class="content">
      
</div>
</div>


  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="">
    
	<h1 id="pg-2a0512809248d42a0d8f3db252862f28">1 - 简介</h1>
    
	<h2 id="introduction-简介">Introduction 简介</h2>
<blockquote>
<p>原文：<a href="https://go.dev/ref/mod#introduction" target="_blank" rel="noopener">https://go.dev/ref/mod#introduction</a></p>
</blockquote>
<p>​	模块是Go管理依赖关系的方式。</p>
<p>​	本文档是关于 Go 的模块系统的详细参考手册。关于创建 Go 项目的介绍，请参见 <a href="../../../GettingStarted/HowToWriteGoCode">How to Write Go Code（如何编写 Go 代码）</a>。有关使用模块、将项目迁移到模块以及其他主题的信息，请参见从 <a href="../../../GoBlog/2019/UsingGoModules">Using Go Modules（使用 Go 模块）</a>开始的博客系列。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-6399010d356a063c606eddd990f65e9c">2 - 模块、包和版本</h1>
    
	<h2 id="modules-packages-and-versions-模块包和版本">Modules, packages, and versions 模块、包和版本</h2>
<blockquote>
<p>原文：https://go.dev/ref/mod#modules-overview</p>
</blockquote>
<p>​	模块是发布、版本化和一起分发的包的集合。模块可以直接从版本控制存储库或模块代理服务器上下载。</p>
<p>​	模块由<a href="#module-paths">模块路径</a>来识别，该路径在 <a href="../gomodFiles">go.mod 文件</a>中声明，同时还有关于该模块的依赖项信息。模块根目录是包含<code>go.mod</code>文件的目录。主模块是包含调用<code>go</code>命令的目录的模块。</p>
<p>​	模块内的每个包是同一目录下的源文件的集合，这些文件被编译在一起。包路径是与包含包（相对于模块根目录）的子目录相连接的模块路径。例如，模块 &ldquo;<code>golang.org/x/net</code>&ldquo;在 &ldquo;<code>html</code>&ldquo;目录下包含一个包。那个包的路径是 &ldquo;<code>golang.org/x/net/html</code>&quot;。</p>
<h3 id="module-paths-模块路径">Module paths 模块路径</h3>
<p>​	模块路径是模块的规范名称，在模块的 <a href="../gomodFiles">go.mod 文件</a>中用<a href="../gomodFiles#module-directive">module指令</a>声明。模块的路径是该模块中包路径的前缀。</p>
<p>​	模块路径应该同时描述模块的作用和查找模块的位置。通常，模块路径由存储库根路径、存储库中的目录（通常为空）和主版本后缀（仅适用于主版本2或更高版本）组成。</p>
<ul>
<li>存储库根路径是模块路径中与开发模块的版本控制存储库的根目录相对应的部分。大多数模块都定义在其存储库的根目录下，所以这通常是整个路径。例如，<code>golang.org/x/net</code>是同名模块的存储库根目录。关于 <code>go</code> 命令如何使用从模块路径派生的 HTTP 请求来定位存储库的信息，请参见<a href="../VersionControlSystems#finding-a-repository-for-a-module-path">Finding a repository for a module path（寻找模块路径的存储库）</a>。</li>
<li>如果模块没有定义在存储库的根目录中，模块子目录是模块路径中命名目录的一部分，不包括主版本后缀。这也可以作为语义版本标签的前缀。例如，模块<code>golang.org/x/tools/gopls</code>位于根目录<code>golang.org/x/tools</code>的<code>gopls</code>子目录中，所以它的模块子目录是<code>gopls</code>。参见<a href="../VersionControlSystems#mapping-versions-to-commits">Mapping versions to commits</a>和<a href="../VersionControlSystems#module-directories-within-a-repository">Module directories within a repository</a>。</li>
<li>如果模块是在主版本2或更高版本发布的，模块路径必须以主版本后缀结尾，如<code>/v2</code>。这可能是也可能不是子目录名称的一部分。例如，路径为 <code>golang.org/x/repo/sub/v2</code> 的模块可能在 <code>golang.org/x/repo</code> 仓库的 <code>/sub</code> 或 <code>/sub/v2</code> 子目录下。</li>
</ul>
<p>​	如果模块可能被其他模块所依赖，就必须遵循这些规则，以便<code>go</code>命令能够找到并下载该模块。对于模块路径中允许的字符也有一些<a href="../gomodFiles#module-paths-and-versions">lexical restrictions（词法限制）</a>。</p>
<h3 id="versions-版本">Versions 版本</h3>
<p>​	一个版本标识了模块的不可改变的快照，它可以是一个发布版或预发布版。每个版本以字母<code>v</code>开头，后面是语义版本。关于如何对版本进行格式化、解释和比较的细节，请参见<a href="https://semver.org/lang/zh-CN/" target="_blank" rel="noopener">Semantic Versioning 2.0.0（语义化版本2.0.0）</a>。</p>
<p>​	简而言之，语义版本由三个非负整数（从左到右分别为：主版本号，次版本号，修订版本号）组成，中间用点分开。修订版本号后面可以有一个以连字符（<code>-</code>或<code>+</code>）开头的可选预发布字符串。预发布字符串或补丁版本后面可以有一个以加号开头的构建元数据字符串。例如，<code>v0.0.0</code>、<code>v1.12.134</code>、<code>v8.0.5-pre</code>和<code>v2.0.9+meta</code>是有效的版本。</p>
<p>​	版本的每一部分都指示该版本是否稳定，以及是否与以前的版本兼容。</p>
<ul>
<li>
<p>在对模块的公共接口或文档功能进行了向后不兼容的更改（例如，在删除了一个包）之后，<a href="../Glossary#major-version">major version（主版本号）</a>必须被递增，次版本号和修订版本号必须被设置为零。</p>
</li>
<li>
<p>在进行向后兼容的更改（例如，增加了一个新的功能）之后，<a href="../Glossary#minor-version">minor version（次版本号）</a>必须被递增，修订版本号必须被设置为零。</p>
</li>
<li>
<p><a href="../Glossary#patch-version">patch version（修订版本号）</a>必须在不影响模块的公共接口的更改（例如错误修复或优化）之后被递增。</p>
</li>
<li>
<p><a href="../Glossary#pre-release-version">pre-release （预发布）</a>后缀表示版本是预发布版本。预发布版本在相应的发布版本之前排序。例如，<code>v1.2.3-pre</code>排在<code>v1.2.3</code>之前。</p>
</li>
<li>
<p>在比较版本时，build metadata的后缀被忽略。带有build metadata的标签在版本控制存储库中被忽略，但build metadata在 <a href="../gomodFiles">go.mod 文件</a>中指定的版本中被保留下来。后缀<code>+incompatible</code>表示在迁移到模块版本主版本2或更高版本之前发布的版本（参见<a href="../CompatibilityWithNon-moduleRepositories">与非模块存储库的兼容性</a>）。</p>
</li>
</ul>
<p>​	如果一个版本的主版本号是<code>0</code>，或者它有一个预发布的后缀，则被认为是不稳定的。不稳定的版本不受兼容性要求的限制。例如，<code>v0.2.0</code> 可能与 <code>v0.1.0</code> 不兼容，<code>v1.5.0-beta</code> 可能与 <code>v1.5.0</code> 不兼容。</p>
<p>​	Go可以使用不遵循这些约定的标签、分支或修订版来访问在版本控制系统的模块。然而，在主模块中，<code>go</code>命令会自动将不遵循此标准的修订版名称转换为规范的版本号。在这个过程中，<code>go</code>命令也会删除build metadata的后缀（除了<code>+incompatible</code>）。这可能会产生一个<a href="../Glossary#pseudo-version">pseudo-version（伪版本号）</a>，一个编码修订版标识符（如Git提交的哈希值）的预先发布的版本号和一个版本控制系统的时间戳。例如，命令<code>go get golang.org/x/net@daa7c041</code>将把提交的哈希值<code>daa7c041</code>转换为伪版本<code>v0.0.0-20191109021931-daa7c04131f5</code>。 在主模块之外需要规范的版本，如果在 <a href="../gomodFiles">go.mod 文件</a>中出现类似<code>master</code>的非规范版本，<code>go</code>命令将报告错误。</p>
<h3 id="pseudo-versions-伪版本号">Pseudo-versions 伪版本号</h3>
<p>​	伪版本号是一个特殊格式的<a href="../Glossary#pre-release-version">pre-release version（预发布版本号）</a>，它对版本控制存储库中的特定版本信息进行编码。例如，<code>v0.0.0-20191109021931-daa7c04131f5</code>就是一个伪版本号。</p>
<p>​	伪版本号可以指那些没有语义版本标签可用的修订版。例如，在开发分支上创建版本标签之前，可以使用它们来测试提交的内容。</p>
<p>每个伪版本都有三个部分：</p>
<ul>
<li>基础版本前缀（<code>base version prefix</code>）（<code>vX.0.0</code>或<code>vX.Y.Z-0</code>），该前缀来自于该修订版之前的语义版本标签，如果没有这样的标签，则是<code>vX.0.0</code>。</li>
<li>时间戳（<code>timestamp</code>）（<code>yyyymmddhhmmss</code>），这是修订版创建的UTC时间。在Git中，这是提交的时间，而不是作者时间。</li>
<li>修订版标识符（<code>revision identifier</code>）（<code>abcdefabcdef</code>），它是提交哈希值的一个12个字符的前缀，或者在Subversion中，是一个零填充的修订号。</li>
</ul>
<p>​	每个伪版本可以是三种形式之一，取决于基础版本（base version）。这些形式保证了伪版本比其基础版本高，但比下一个标记的版本低。</p>
<ul>
<li><code>vX.0.0-yyyymmddhhmmss-abcdefabcdef</code>在没有已知基础版本时使用。与所有版本一样，主版本<code>X</code>必须与模块的<a href="../Glossary#major-version-suffix">major version suffix（主版本后缀）</a>相匹配。</li>
<li><code>vX.Y.Z-pre.0.yyyymmddhhmmss-abcdefabcdef</code>在基础版本是预发布版本（如 <code>vX.Y.Z-pre</code>）时使用。</li>
<li><code>vX.Y.(Z+1)-0.yyyymmddhhmmss-abcdefabcdef</code>在基础版本是发布版本（如<code>vX.Y.Z</code>）时使用。例如，如果基础版本是<code>v1.2.3</code>，那么伪版本可能是<code>v1.2.4-0.20191109021931-daa7c04131f5</code>。</li>
</ul>
<p>​	通过使用不同的基础版本，多个伪版本可以引用相同的提交。这发生在写完伪版本后，低版本被标记的时候。</p>
<p>​	这些形式给了伪版本两个有用的属性：</p>
<ul>
<li>具有已知基础版本的伪版本排序高于这些版本，但低于其他预发布的后续版本。</li>
<li>具有相同基础版本前缀的伪版本按时间顺序排序。</li>
</ul>
<p>​	<code>go</code>命令进行了一些检查，以确保模块作者能够控制伪版本与其他版本的比较，并确保伪版本引用的修订版是实际属于模块提交历史的一部分。</p>
<ul>
<li>如果指定了基础版本（base version），就必须有相应的语义版本标签，该标签是伪版本所描述的修订版的祖先。这可以防止开发者使用伪版本来绕过<a href="../Glossary#minimal-version-selection">minimal version selection（最小版本）</a>的选择，该伪版本比所有标签的版本（比如<code>v1.999.999-9999999999-daa7c04131f5</code>）都要高。</li>
<li>时间戳（timestamp）必须与修订版的时间戳匹配。这可以防止攻击者用无限数量的其他相同伪版本来 flooding <a href="../Glossary#module-proxy">module proxies （模块代理）</a>。这也可以防止模块使用者更改版本的相对顺序。</li>
<li>修订版必须是模块存储库的一个分支或标签的祖先。这可以防止攻击者引用未经批准的更改或拉取请求。</li>
</ul>
<p>​	伪版本从不需要手工输入。许多命令接受提交哈希值或分支名称，并将其自动翻译成伪版本（或标签版本（如果可用））。比如说：</p>
<pre tabindex="0"><code>go get example.com/mod@master
go list -m -json example.com/mod@abcd1234
</code></pre><h3 id="major-version-suffixes-主版本的后缀">Major version suffixes 主版本的后缀</h3>
<p>​	从主版本2开始，模块路径必须有一个主版本后缀，如<code>/v2</code>，与主版本相匹配。例如，如果模块的路径<code>example.com/mod</code>是<code>v1.0.0</code>版本，那么它的路径<code>example.com/mod/v2</code>必须是<code>v2.0.0</code>版本。</p>
<p>​	主版本后缀实现了<a href="https://research.swtch.com/vgo-import" target="_blank" rel="noopener">import compatibility rule（导入兼容性规则）</a>：</p>
<blockquote>
<p>如果旧包和新包有相同的导入路径，则新包必须向后兼容旧包。</p>
</blockquote>
<p>​	根据定义，模块的新的主版本中的包不向后兼容之前的主版本中的相应包。因此，从<code>v2</code>开始，包需要新的导入路径。这是通过在模块路径上添加一个主版本的后缀来实现的。由于模块路径是模块内每个包的导入路径的前缀，在模块路径上添加主版本后缀为每个不兼容的版本提供了一个不同的导入路径。</p>
<p>​	主版本后缀在主版本<code>v0</code>或<code>v1</code>时是不允许的。没有必要在<code>v0</code>和<code>v1</code>之间改变模块路径，因为<code>v0</code>版本是不稳定的，没有兼容性保证。此外，对于大多数模块来说，<code>v1</code>是向后兼容最后一个<code>v0</code>版本的；<code>v1</code>版本是对兼容性的一种承诺，而不是表明与<code>v0</code>相比有不兼容的变化。</p>
<p>​	作为一种特殊情况，以<code>gopkg.in/</code>开始的模块路径必须始终有一个主版本后缀，即使是<code>v0</code>和<code>v1</code>。 后缀必须以<strong>点</strong>开始，而不是斜线（例如，<code>gopkg.in/yaml.v2</code>）。</p>
<p>​	主版本后缀允许模块的多个主版本共存于同一个构建中。这可能是由于<a href="https://research.swtch.com/vgo-import#dependency_story" target="_blank" rel="noopener">diamond dependency problem（钻石依赖性问题）</a>而需要的。通常，如果一个模块在两个不同的版本中被传递依赖关系所需要，则将使用更高的版本。然而，如果这两个版本不兼容，那么这两个版本都不能满足所有的客户。由于不兼容的版本必须有不同的主版本号，因此由于主版本后缀，它们也必须具有不同的模块路径。这就解决了冲突：具有不同后缀的模块被视为独立的模块，它们的包 —— 即使是相对于它们的模块根的同一子目录下的包 —— 也是不同的。</p>
<p>​	许多Go项目在迁移到模块之前（也许在模块被引入之前）发布了<code>v2</code>或更高的版本，但没有使用主版本后缀。这些版本使用<code>+incompatible</code>的构建标签进行注释（例如，<code>v2.0.0+incompatible</code>）。更多信息请参见<a href="../CompatibilityWithNon-moduleRepositories">Compatibility with non-module repositories（与非模块存储库的兼容性）</a>。</p>
<h3 id="resolving-a-package-to-a-module-将一个包解析为模块">Resolving a package to a module 将一个包解析为模块</h3>
<p>​	当 <code>go</code> 命令使用<a href="../Glossary#package-path">package path（包路径）</a>加载包时，它需要确定哪个模块提供该包。</p>
<p>​	<code>go</code>命令首先在<a href="../Glossary#build-list">build list（构建列表）</a>中搜索路径为包路径前缀的模块。例如，如果包 <code>example.com/a/b</code> 被导入，并且模块 <code>example.com/a</code> 在构建列表中，<code>go</code> 命令将在目录 <code>b</code> 中检查 <code>example.com/a</code> 是否包含该包。在一个目录中至少要有一个扩展名为 <code>.go</code> 的文件，才能被视为一个包。<a href="https://pkg.go.dev/go/build#hdr-Build_Constraints" target="_blank" rel="noopener">Build constraints（构建限制）</a>并不适用这个目的。如果在构建列表中正好有模块提供了该包，那么就使用该模块。如果没有模块提供该包，或者有两个或更多的模块提供该包，<code>go</code>命令会报告一个错误。<code>-mod=mod</code>标志指示<code>go</code>命令尝试寻找提供缺失包的新模块，并更新<code>go.mod</code>和<code>go.sum</code>。<a href="../Module-awareCommands#go-get">go get</a>和<a href="../Module-awareCommands#go-mod-tidy">go mod tidy</a>命令会自动完成这项工作。</p>
<p>​	当<code>go</code>命令查找一个包路径的新模块时，它会检查<code>GOPROXY</code>环境变量，它是一个用逗号分隔的代理URL列表或关键词<code>direct</code>或<code>off</code>。代理URL表示<code>go</code>命令应该使用<a href="../ModuleProxies#goproxy-protocol">GOPROXY 协议</a>与模块代理联系。<code>direct</code>表示<code>go</code>命令应该与<a href="../VersionControlSystems">一个版本控制系统通信</a>。<code>GOPRIVATE</code>和<code>GONOPROXY</code><a href="../EnvironmentVariables">environment variables（环境变量）</a>也可以用来控制这种行为。</p>
<p>​	对于<code>GOPROXY</code>列表中的每个条目，<code>go</code>命令请求可能提供包（即包路径的每个前缀）的每个模块路径的最新版本。对于每个成功请求的模块路径，<code>go</code>命令将下载最新版本的模块，并检查该模块是否包含请求的包。如果一个或多个模块包含所请求的包，则使用路径最长的模块。如果找到一个或多个模块，但没有一个包含所请求的包，则报告错误。如果没有找到模块，<code>go</code>命令将尝试<code>GOPROXY</code>列表中的下一个条目。如果没有剩余的条目，则报告错误。</p>
<p>​	例如，假设<code>go</code>命令正在寻找一个提供包<code>golang.org/x/net/html</code>的模块，并且<code>GOPROXY</code>被设置为<code>https://corp.example.com,https://proxy.golang.org</code>。<code>go</code>命令可能会发出以下请求：</p>
<ul>
<li>
<p>向  <code>https://corp.example.com/</code> （并行）:</p>
<ul>
<li>请求<code>golang.org/x/net/html</code>的最新版本</li>
<li>请求<code>golang.org/x/net</code>的最新版本</li>
<li>请求<code>golang.org/x</code>的最新版本</li>
<li>请求<code>golang.org</code>的最新版本</li>
</ul>
</li>
<li>
<p>如果向 <code>https://corp.example.com/</code>的所有请求都以 <code>404</code> 或 <code>410</code>失败告终，则向  <code>https://proxy.golang.org/</code> :</p>
<ul>
<li>请求<code>golang.org/x/net/html</code>的最新版本</li>
<li>请求<code>golang.org/x/net</code>的最新版本</li>
<li>请求<code>golang.org/x</code>的最新版本</li>
<li>请求<code>golang.org</code>的最新版本</li>
</ul>
</li>
</ul>
<p>​	在找到合适的模块后，<code>go</code> 命令将使用新模块的路径和版本向主模块的 <a href="../gomodFiles">go.mod 文件</a>添加一个新的<a href="../gomodFiles#require-directive">requirement（需求）</a>。这样可以确保将来加载相同的包时，会使用相同版本的模块。如果解析后的包没有被主模块中的包导入，那么新的需求将会有一个<code>// indirect</code>的注释。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-e5a749e2b095eb21e9034038f8db3e55">3 - go.mod 文件</h1>
    
	<h2 id="gomod-files----gomod-文件">go.mod files  - go.mod 文件</h2>
<blockquote>
<p>原文：<a href="https://go.dev/ref/mod#go-mod-file" target="_blank" rel="noopener">https://go.dev/ref/mod#go-mod-file</a></p>
</blockquote>
<p>​	模块由其根目录下的名为<code>go.mod</code>的UTF-8编码的文本文件来定义。<code>go.mod</code>文件是以行为单位的。每一行都有一个单独指令，由关键字后跟参数组成。例如：</p>
<pre tabindex="0"><code>module example.com/my/thing

go 1.12

require example.com/other/thing v1.0.2
require example.com/new/thing/v2 v2.3.4
exclude example.com/old/thing v1.2.3
replace example.com/bad/thing v1.4.5 =&gt; example.com/good/thing v1.4.5
retract [v1.9.0, v1.9.5]
</code></pre><p>​	可以将前导关键字从相邻的行中分解出来，以创建一个块，就像Go导入中一样。</p>
<pre tabindex="0"><code>require (
    example.com/new/thing/v2 v2.3.4
    example.com/old/thing v1.2.3
)
</code></pre><p>​	<code>go.mod</code>文件被设计成人类可读，机器可写。<code>go</code>命令提供了几个改变<code>go.mod</code>文件的子命令。例如，<a href="../Module-awareCommands#go-get">go get</a>可以升级或降级特定的依赖项。加载模块图的命令会在需要时<a href="#automatic-updates">automatically update（自动更新）</a><code>go.mod</code>。<a href="../Module-awareCommands#go-mod-edit">go mod edit</a>可以执行低级别的编辑。Go程序可以使用<code>golang.org/x/mod/modfile</code>包，以编程方式进行同样的修改。</p>
<p>​	<a href="../Glossary#main-module">main module（主模块）</a>和任何用本地文件路径指定的<a href="#replace-directive">replacement module（替换模块）</a>都需要<code>go.mod</code>文件。然而，缺少显式的<code>go.mod</code>文件的模块仍然可以作为依赖项被<a href="#require-directive">要求</a>，或者作为用模块路径和版本指定的替换模块使用；参见<a href="../CompatibilityWithNon-moduleRepositories">Compatibility with non-module repositories（与非模块存储库的兼容性）</a>。</p>
<h3 id="lexical-elements-词法元素">Lexical elements 词法元素</h3>
<p>​	当<code>go.mod</code>文件被解析时，其内容被分解为一连串的标记。有几种标记：空白（whitespace）、注释（comments）、标点符号（punctuation）、关键字（keywords）、标识符（identifiers）和字符串（strings）。</p>
<p>​	空白（White space）包括空格（U+0020）、制表符（U+0009）、回车符（U+000D）和换行符（U+000A）。除换行符外，其他空白字符没有任何作用，只是将原本合并的标记分开。换行符是重要的标记。</p>
<p>​	注释（Comments）以<code>//</code>开始并运行到行尾。<code>/* */</code> 的注释是不允许的。</p>
<p>​	标点符号（Punctuation）包括<code>(</code>、<code>)</code>和<code>=&gt;</code>。</p>
<p>​	关键字（Keywords）用于区分<code>go.mod</code>文件中不同类型的指令。允许的关键字有<code>module</code>、<code>go</code>、<code>require</code>、<code>replace</code>、<code>exclude</code>和<code>retract</code>。</p>
<p>​	标识符（Identifiers）是由非空白字符组成的序列，例如模块路径或语义版本。</p>
<p>​	字符串（Strings）是有引号的字符序列。有两种字符串：以引号（&quot;，U+0022）开头和结尾的解释字符串（interpreted strings）和以重音符号（`，U+0060）开头和结尾的原始字符串（raw strings）。被解释的字符串可以包含由反斜线（, U+005C）和其他字符组成的转义序列。转义的引号（\&quot;）不会终止解释字符串。解释字符串（interpreted strings）的无引号值是引号之间的字符序列，每个转义序列被反斜线后面的字符取代（例如，\&ldquo;被 &ldquo;取代，\n被n取代）。相比之下，原始字符串的无引号值只是重音符号之间的字符序列；反斜杠在原始字符串中没有特殊意义。</p>
<p>​	在<code>go.mod</code>语法中，标识符和字符串是可以互换的。</p>
<h3 id="module-paths-and-versions-模块路径和版本">Module paths and versions 模块路径和版本</h3>
<p>​	<code>go.mod</code>文件中的大多数标识符和字符串都是模块路径或版本。</p>
<p>​	模块路径必须满足以下要求：</p>
<ul>
<li>路径必须由一个或多个路径元素组成，以斜线（<code>/</code>，U+002F）分隔。路径不能以斜线开始或结束。</li>
<li>每个路径元素是一个非空字符串，由ASCII字母、ASCII数字和有限的ASCII标点符号（<code>-</code>、<code>.</code>、<code>_</code>和<code>~</code>）组成。</li>
<li>路径元素不能以点（<code>.</code>，U+002E）开始或结束。</li>
<li>路径元素前缀到第一个点不能是Windows上的保留文件名，无论大小写（<code>CON</code>、<code>com1</code>、<code>NuL</code>等）。</li>
<li>路径元素前缀到第一个点不能以一个波浪符号后跟一个或多个数字结尾（如<code>EXAMPL~1.COM</code>）。</li>
</ul>
<p>​	如果模块路径出现在<code>require</code>指令中并且没有被替换，或者模块路径出现在<code>replace</code>指令的右侧，<code>go</code>命令可能需要下载该路径的模块，并且必须满足一些额外的要求。</p>
<p>​	（a）按照惯例，域名的前导路径元素(直到第一个斜线)必须只包含小写的 ASCII 字母、 ASCII 数字、点(<code>.</code>，U+002E)和破折号(<code>-</code> ，U+002D) ；它必须包含至少一个点，并且不能以破折号开始。</p>
<p>​	（b）对于形式为<code>/vN</code>的最后路径元素，其中<code>N</code>看起来是数字（ASCII数字和点），<code>N</code>不能以前导零开始，不能是<code>/v1</code>，也不能包含任何点。</p>
<ul>
<li>对于以<code>gopkg.in/</code>开头的路径，这个要求被一个路径必须遵循 <a href="https://gopkg.in/" target="_blank" rel="noopener">gopkg.in</a>服务约定的要求所取代。</li>
</ul>
<p>​	<code>go.mod</code>文件中的版本可以是[经典（canonical）](../Glossary#canonical version)的或非经典的。</p>
<p>​	经典版本以字母<code>v</code>开头，后面是符合<a href="https://semver.org/lang/zh-CN/" target="_blank" rel="noopener">Semantic Versioning 2.0.0（语义化版本2.0.0）</a>规范的语义版本。更多信息请参见 <a href="../ModulesPackagesAndVersions">Versions（版本）</a>。</p>
<p>​	大多数其他标识符和字符串都可以作为非经典版本使用，但是也有一些限制，以避免文件系统、存储库和<a href="../Glossary#module-proxy">module proxies（模块代理）</a>出现问题。非经典版本只允许在主模块的<code>go.mod</code>文件中使用。<code>go</code>命令在<a href="#automatic-updates">自动更新</a><code>go.mod</code>文件时，会尝试用一个等效的经典版本来替换每个非经典版本。</p>
<p>​	在模块路径与版本相关的地方（如<code>require</code>、<code>replace</code>和<code>exclude</code>指令），最后的路径元素必须与版本一致。参见<a href="../ModulesPackagesAndVersions#major-version-suffixes">Major version suffixes（主版本后缀）</a>。</p>
<h3 id="grammar-语法">Grammar 语法</h3>
<p>​	<code>go.mod</code>的语法是使用Extended Backus-Naur Form (EBNF)指定的。关于EBNF语法的详细信息，请参见<a href="../../LanguageSpecification/Notation">Notation section in the Go Language Specification（Go语言规范中的标记法部分）</a>。</p>
<pre tabindex="0"><code>GoMod = { Directive } .
Directive = ModuleDirective |
            GoDirective |
            RequireDirective |
            ExcludeDirective |
            ReplaceDirective |
            RetractDirective .
</code></pre><p>​	换行符、标识符和字符串分别用<code>newline</code>、<code>ident</code>和<code>string</code>表示。</p>
<p>​	模块路径和版本用<code>ModulePath</code>和<code>Version</code>来表示。</p>
<pre tabindex="0"><code>ModulePath = ident | string . /* see restrictions above */
Version = ident | string .    /* see restrictions above */
</code></pre><h3 id="module-directive">module directive</h3>
<p>​	<code>module</code>指令定义了主模块的<a href="../Glossary#path">path（路径）</a>。<code>go.mod</code>文件必须恰好包含一个<code>module</code>指令。</p>
<pre tabindex="0"><code>ModuleDirective = &#34;module&#34; ( ModulePath | &#34;(&#34; newline ModulePath newline &#34;)&#34; ) newline .
</code></pre><p>示例：</p>
<pre tabindex="0"><code>module golang.org/x/net
</code></pre><h4 id="deprecation-废弃">Deprecation 废弃</h4>
<p>​	模块可以在段落开头包含字符串 <code>Deprecated:</code>（区分大小写）的注释块中标记为已弃用。 废弃信息从冒号之后开始，一直到段落的末尾。注释可以出现在<code>module</code>指令的前面，也可以出现在同一行的后面。</p>
<p>示例：</p>
<pre tabindex="0"><code>// Deprecated: use example.com/mod/v2 instead.
module example.com/mod
</code></pre><p>​	从Go 1.17开始，<a href="../Module-awareCommands#go-list-m-u">go list -m -u</a>检查<a href="../Glossary#build-list">build list（构建列表）</a>中所有已废弃模块的信息。<a href="../Module-awareCommands#go-get">go get</a>检查构建命令行上命名的包所需的已废弃模块。</p>
<p>​	当<code>go</code>命令检索一个模块的废弃信息时，它从匹配<code>@latest</code><a href="../Module-awareCommands#version-queries">version query（版本查询）</a>的版本中加载<code>go.mod</code>文件，而不考虑<a href="#retract-directive">retractions（撤回）</a>或<a href="#exclude-directive">exclusions（排除）</a>。<code>go</code>命令从同一个<code>go.mod</code>文件中加载<a href="../Glossary#retracted-version">retracted versions（撤回版本）</a>的列表。</p>
<p>​	为了废弃一个模块，作者可以添加一个<code>// Deprecated:</code>注释并标记一个新版本。作者可以在更高的版本中更改或删除废弃信息。</p>
<p>​	废弃适用于一个模块的所有次版本。高于<code>v2</code>的主版本被认为是独立的模块，因为它们的<a href="../Glossary#major-version-suffix">major version suffixes（主版本后缀）</a>赋予它们不同的模块路径。</p>
<p>Deprecation messages are intended to inform users that the module is no longer supported and to provide migration instructions, for example, to the latest major version. Individual minor and patch versions cannot be deprecated; <a href="https://go.dev/ref/mod#go-mod-file-retract" target="_blank" rel="noopener"><code>retract</code></a> may be more appropriate for that.</p>
<p>​	废弃信息的目的是通知用户，该模块不再被支持，并提供迁移说明，例如，迁移到最新的主版本。<strong>单个次版本和修订版本不能被废弃（=&gt;仍有疑问？？）</strong>；<a href="#retract-directive">retract</a>可能更适合于这种情况。</p>
<h3 id="go-directive">go directive</h3>
<p>​	<code>go</code>指令表明一个模块是以给定的Go版本的语义为基础编写的。版本必须是有效的Go发布版本：一个正整数，后面跟一个点和一个非负整数（例如，<code>1.9</code>，<code>1.14</code>）。</p>
<p>​	<code>go</code>指令最初是为了支持Go语言的向后不兼容的变化（见<a href="https://go.googlesource.com/proposal/&#43;/master/design/28221-go2-transitions.md" target="_blank" rel="noopener">Go 2 过渡</a>）。自从引入模块以来，没有任何不兼容的语言变化，但<code>go</code>指令仍然影响到新语言特性的使用：</p>
<ul>
<li>对于模块中的包，编译器会拒绝使用<code>go</code>指令指定的版本之后引入的语言特性。例如，如果模块的指令是<code>go 1.12</code>，它的包就不能使用<code>1_000_000</code>这样的数字字面量，这是在<code>Go 1.13</code>引入的。</li>
<li>如果较旧的Go版本构建了该模块的一个包并遇到了编译错误，那么错误就会指出该模块是为一个较新的Go版本编写的。例如，假设模块有<code>go 1.13</code>，一个包使用数字字面<code>1_000_000</code>。如果该包是用<code>Go 1.12</code>构建的，编译器就会注意到该代码是为<code>Go 1.13</code>编写的。</li>
</ul>
<p>​	此外，<code>go</code>命令会根据<code>go</code>指令所指定的版本改变其行为。这有以下影响：</p>
<p>（a）在<code>go 1.14</code>或更高版本中，可以启用自动<a href="../Module-awareCommands#vendoring">vendoring</a>。如果文件<code>vendor/modules.txt</code>存在并与<code>go.mod</code>一致，就不需要显式使用<code>-mod=vendor</code>标志。</p>
<p>（b）在 <code>go 1.16</code> 或更高版本中，<code>all</code>包模式只匹配由<a href="../Glossary#main-module">main module（主模块）</a>中由包和测试过渡导入的包。这也是<a href="../Module-awareCommands#go-mod-vendor">go mod vendor</a>自引入模块以来所保留的包的集合。在较低的版本中，<code>all</code>也包括由主模块中的包导入的包的测试、对这些包的测试等等。</p>
<p>（c）在<code>go 1.17</code>或更高版本：</p>
<ul>
<li>
<p><code>go.mod</code>文件包括一个明确的<a href="#require-directive">require指令</a>，该指令提供由主模块中的包或测试过渡地导入的任何包。(在 <code>go 1.16</code> 或更低版本，只有在<a href="../MVS">minimal version selection（最小版本选择）</a>会选择不同版本的情况下，才会包含<a href="../Glossary#direct-dependency">indirect dependency（间接依赖）</a>。) 这个额外的信息使得<a href="../ModuleGraphPruning">module graph pruning（模块图的修剪）</a>和<a href="../ModuleGraphPruning#lazy-module-loading">lazy module loading（延迟模块加载）</a>成为可能。</p>
</li>
<li>
<p>由于<code>// indirect</code>依赖可能比以前的<code>go</code>版本多得多，间接依赖被记录在<code>go.mod</code>文件中的一个独立块中。</p>
</li>
<li>
<p><code>go mod vendor</code>省略了<code>go.mod</code>和<code>go.sum</code>文件中的供应商依赖项。(这允许在<code>vendor</code>的子目录中调用<code>go</code>命令来识别正确的主模块）。</p>
</li>
<li>
<p><code>go mod vendor</code>将 go 版本从每个依赖项的 go.mod 文件中记录下来，并放在<code>vendor/modules.txt</code> 中。</p>
</li>
</ul>
<p>​	<code>go.mod</code>文件最多可以包含一个<code>go</code>指令。如果没有<code>go</code>指令，大多数命令会添加一个当前Go版本的<code>go</code>指令。</p>
<p>​	在Go 1.17发行版中，如果<code>go</code>指令缺失，则假定<code>go 1.16</code>。</p>
<pre tabindex="0"><code>GoDirective = &#34;go&#34; GoVersion newline .
GoVersion = string | ident .  /* valid release version; see above */
</code></pre><p>示例：</p>
<pre tabindex="0"><code>go 1.14
</code></pre><h3 id="require-directive">require directive</h3>
<p>​	<code>require</code>指令声明了给定模块依赖的最低要求版本。对于每个所需的模块版本，<code>go</code>命令加载该版本的<code>go.mod</code>文件，并将该文件中的requirements 纳入其中。一旦所有requirements 被加载完，<code>go</code>命令就会使用<a href="../MVS">minimal version selection（最小版本选择 MVS）</a> 来解析它们，从而产生<a href="../Glossary#build-list">build list（构建列表）</a>。</p>
<p>​	<code>go</code>命令自动为一些requirements 添加<code>// indirect</code>注释。<code>// indirect</code>注释表示所需模块的任何包都没有被<a href="../Glossary#main-module">main module（主模块）</a>中的任何包直接导入。</p>
<p>​	如果<a href="#go-directive">go directive</a>指定了<code>go 1.16</code>或更低的版本，当所选模块的版本高于主模块的其他依赖项已经暗示（过渡地）的版本时，<code>go</code>命令会添加一个间接需求。这可能是由于显式的升级（<code>go get -u ./...</code>），移除之前施加需求的其他依赖项（<code>go mod tidy</code>），或者依赖项导入的包在其自身的<code>go.mod</code>文件中没有相应的 requirement （比如一个完全没有<code>go.mod</code>文件的依赖项）。</p>
<p>​	在<code>go 1.17</code>及以上版本中，<code>go</code>命令为每个模块增加了一个间接需求，提供任何被主模块中的包或测试导入（即使是<a href="../Glossary#indirect-dependency">间接的</a>）或作为参数传递给<code>go get</code>的包。这些更全面的 requirements 可以支持<a href="../ModuleGraphPruning">module graph pruning（模块图的修剪）</a>和<a href="../ModuleGraphPruning#lazy-module-loading">lazy module loading（延迟模块加载）</a>。</p>
<pre tabindex="0"><code>RequireDirective = &#34;require&#34; ( RequireSpec | &#34;(&#34; newline { RequireSpec } &#34;)&#34; newline ) .
RequireSpec = ModulePath Version newline .
</code></pre><p>示例：</p>
<pre tabindex="0"><code>require golang.org/x/net v1.2.3

require (
    golang.org/x/crypto v1.4.5 // indirect
    golang.org/x/text v1.6.7
)
</code></pre><h3 id="exclude-directive">exclude directive</h3>
<p>​	<code>exclude</code>指令可以防止模块版本被<code>go</code>命令加载。</p>
<p>​	从Go 1.16开始，如果任何<code>go.mod</code>文件中的<code>require</code>指令所引用的版本被主模块的<code>go.mod</code>文件中的<code>exclude</code>指令所排除，该requirement 将被忽略。这可能会导致像<a href="../Module-awareCommands#go-get">go get</a>和<a href="../Module-awareCommands#go-mod-tidy">go mod tidy</a>这样的命令在<code>go.mod</code>中添加更高版本的新requirements ，如果合适的话，会加上一个<code>// indirect</code>注释。</p>
<p>​	在Go 1.16之前，如果一个排除的版本被<code>require</code>指令引用，<code>go</code>命令会列出该模块的可用版本（如<a href="../Module-awareCommands#go-list-m">go list -m -versions</a>所示）并加载下一个较高的非排除版本。这可能会导致不确定的版本选择，因为下一个更高版本可能会随着时间的推移而改变。为了这个目的，发布版和预布行版都被考虑了，但伪版本没有被考虑。如果没有更高的版本，<code>go</code>命令会报告一个错误。</p>
<p>​	<code>exclude</code>指令只适用于主模块的<code>go.mod</code>文件，在其他模块中被忽略。详见<a href="../MVS">Minimal version selection（最小版本选择 MVS）</a>。</p>
<pre tabindex="0"><code>ExcludeDirective = &#34;exclude&#34; ( ExcludeSpec | &#34;(&#34; newline { ExcludeSpec } &#34;)&#34; newline ) .
ExcludeSpec = ModulePath Version newline .
</code></pre><p>示例：</p>
<pre tabindex="0"><code>exclude golang.org/x/net v1.2.3

exclude (
    golang.org/x/crypto v1.4.5
    golang.org/x/text v1.6.7
)
</code></pre><h3 id="replace-directive">replace directive</h3>
<p>​	<code>replace</code>指令用其他地方找到的内容替换某个模块的特定版本或某个模块的所有版本。替换可以指定另一个模块路径和版本，或者一个特定平台的文件路径。</p>
<p>​	如果一个版本出现在箭头（<code>=&gt;</code>）的左侧，那么只有该模块的特定版本被替换，其他版本将被正常访问。如果左侧的版本被省略，则模块的所有版本都被替换。</p>
<p>​	如果箭头右侧的路径是一个绝对或相对路径（以<code>./</code>或<code>./</code>开头），它被解释为替换模块根目录的本地文件路径，其中必须包含一个<code>go.mod</code>文件。在这种情况下，替换版本必须被省略。</p>
<p>​	如果右边的路径不是本地路径，它必须是一个有效的模块路径。在这种情况下，需要一个版本号。同一模块的版本不能同时出现在构建列表中。</p>
<p>​	不管替换是用本地路径还是模块路径指定的，如果替换的模块有一个<code>go.mod</code>文件，它的<code>module</code>指令必须与它所替换的模块路径一致。</p>
<p>​	<code>replace</code>指令只适用于主模块的<code>go.mod</code>文件，在其他模块中被忽略。详见<a href="../MVS">Minimal version selection（最小版本选择 MVS）</a>。</p>
<p>​	如果有多个主模块，所有主模块的<code>go.mod</code>文件都适用。不允许主模块间的<code>replace</code>指令发生冲突，必须在<a href="../Workspaces#replace-directive">go.work 文件的替换</a>中删除或重写这些指令。</p>
<p>​	请注意，仅仅是<code>replace</code>指令并不能将一个模块添加到<a href="../Glossary#module-graph">模块图</a>中。在主模块的 <code>go.mod</code> 文件或依赖模块的 <code>go.mod</code> 文件中，还需要一个指向被替换模块版本的 <a href="#require-directive">require 指令</a>。如果不需要左侧的模块版本，<code>replace</code>指令就没有作用。</p>
<pre tabindex="0"><code>ReplaceDirective = &#34;replace&#34; ( ReplaceSpec | &#34;(&#34; newline { ReplaceSpec } &#34;)&#34; newline ) .
ReplaceSpec = ModulePath [ Version ] &#34;=&gt;&#34; FilePath newline
            | ModulePath [ Version ] &#34;=&gt;&#34; ModulePath Version newline .
FilePath = /* platform-specific relative or absolute file path */
</code></pre><p>示例：</p>
<pre tabindex="0"><code>replace golang.org/x/net v1.2.3 =&gt; example.com/fork/net v1.4.5

replace (
    golang.org/x/net v1.2.3 =&gt; example.com/fork/net v1.4.5
    golang.org/x/net =&gt; example.com/fork/net v1.4.5
    golang.org/x/net v1.2.3 =&gt; ./fork/net
    golang.org/x/net =&gt; ./fork/net
)
</code></pre><h3 id="retract-directive">retract directive</h3>
<p>​	<code>retract</code>指令表示由<code>go.mod</code>定义的模块的某个版本或一系列版本不应该被依赖。当版本过早发布或在发布后发现严重问题时，<code>retract</code>指令就很有用。撤回的版本应该在版本控制存储库和<a href="../Glossary#module-proxy">module proxy（模块代理）</a>上保持可用，以确保依赖它们的构建不会被破坏。<code>retract</code>这个词是从学术文献中借来的：被撤回的研究论文仍然可以使用，但它有问题，不应该成为未来工作的基础。</p>
<p>​	当一个模块的版本被撤回时，用户将不会使用<a href="../Module-awareCommands#go-get">go get</a>、<a href="../Module-awareCommands#go-mod-tidy">go mod tidy</a>或其他命令自动升级到该版本。依赖于撤消版本的构建应该继续工作，但是当用户用<a href="../Module-awareCommands#go-list-m">go list -m -u</a>检查更新或用<a href="../Module-awareCommands#go-get">go get</a>更新相关模块时，将会收到撤回的通知。</p>
<p>​	要撤回一个版本，模块作者应该在<code>go.mod</code>中添加一个<code>retract</code>指令，然后发布一个包含该指令的新版本。新版本必须高于其他发布或预发布的版本；也就是说，在考虑撤回之前，<code>@latest</code><a href="../Module-awareCommands#version-query">version query（版本查询）</a>应该解析到新版本。<code>go</code>命令从<code>go list -m -retracted $modpath@latest</code>（其中<code>$modpath</code>是模块路径）显示的版本中加载和应用撤回。</p>
<p>​	除非使用 <code>-retracted</code> 标志，否则撤回的版本会从 <a href="../Module-awareCommands#go-list-m">go list -m -versions</a> 打印的版本列表中隐藏。在解析版本查询（如<code>@&gt;=v1.2.3</code>或<code>@latest</code>）时，撤回的版本将被排除。</p>
<p>​	包含撤回的版本可以自行撤回。如果一个模块的最高发布版本或预发布版本自行撤回了，<code>@latest</code>查询会在排除撤回的版本后解析到一个较低的版本。</p>
<p>As an example, consider a case where the author of module <code>example.com/m</code> publishes version <code>v1.0.0</code> accidentally. To prevent users from upgrading to <code>v1.0.0</code>, the author can add two <code>retract</code> directives to <code>go.mod</code>, then tag <code>v1.0.1</code> with the retractions.</p>
<p>​	举个例子，考虑这样一种情况：模块 <code>example.com/m</code> 的作者意外地发布了 <code>v1.0.0</code> 版本。为了防止用户升级到<code>v1.0.0</code>，作者可以在<code>go.mod</code>中添加两个<code>retract</code>指令，然后用撤回标记<code>v1.0.1</code>。</p>
<pre tabindex="0"><code>retract (
    v1.0.0 // Published accidentally.
    v1.0.1 // Contains retractions only.
)
</code></pre><p>​	当用户运行<code>go get example.com/m@latest</code>时，<code>go</code>命令会读取<code>v1.0.1</code>版本的撤回，这就是现在的最高版本。<code>v1.0.0</code>和<code>v1.0.1</code>都被撤回了，所以<code>go</code>命令会升级（或降级！）到下一个最高版本，也许是<code>v0.9.5</code>。</p>
<p>​	<code>retract</code>指令既可以写成单一版本（如<code>v1.0.0</code>），也可以写成有上下限的封闭的版本区间，用<code>[</code> 和 <code>]</code> 界定（如<code>[v1.1.0, v1.2.0]</code>）。单一版本等同于一个上界和下界相同的区间。和其他指令一样，多个<code>retract</code>指令可以组合在一起，以<code>(</code>为界，放在一行的末尾，以<code>)</code>为界，放在单独的一行。</p>
<p>​	每条<code>retract</code>指令都应该有一个注释，解释撤回的理由，尽管这并不是强制性的。<code>go</code>命令可以在关于撤回版本的警告和<code>go list</code>输出中显示理由注释。理由注释可以紧接着写在<code>retract</code>指令的上方（中间没有空行），也可以写在同一行的后面。如果一条注释出现在一个块的上方，它适用于该块内所有没有自己注释的<code>retract</code>指令。一个理由注释可以跨越多行。</p>
<pre tabindex="0"><code>RetractDirective = &#34;retract&#34; ( RetractSpec | &#34;(&#34; newline { RetractSpec } &#34;)&#34; newline ) .
RetractSpec = ( Version | &#34;[&#34; Version &#34;,&#34; Version &#34;]&#34; ) newline .
</code></pre><p>示例：</p>
<ul>
<li>撤回<code>v1.0.0</code>到<code>v1.9.9</code>之间的所有版本：</li>
</ul>
<pre tabindex="0"><code>retract v1.0.0
retract [v1.0.0, v1.9.9]
retract (
    v1.0.0
    [v1.0.0, v1.9.9]
)
</code></pre><ul>
<li>在提前发布了<code>v1.0.0</code>版本之后，返回到 unversioned：</li>
</ul>
<pre tabindex="0"><code>retract [v0.0.0, v1.0.1] // assuming v1.0.1 contains this retraction.
</code></pre><ul>
<li>抹去包含所有伪版本和标签版本的模块：</li>
</ul>
<pre tabindex="0"><code>retract [v0.0.0-0, v0.15.2]  // assuming v0.15.2 contains this retraction.
</code></pre><p>​	<code>retract</code>指令是在Go 1.16中添加的。如果<a href="../Glossary#main-module">主模块</a>的<code>go.mod</code>文件中写有<code>retract</code>指令，Go 1.15及以下版本将报告错误，并忽略依赖模块的<code>go.mod</code>文件中的<code>retract</code>指令。</p>
<h3 id="automatic-updates-自动更新">Automatic updates 自动更新</h3>
<p>​	如果<code>go.mod</code>缺少信息或不能准确反映现实，大多数命令都会报告错误。<a href="../Module-awareCommands#go-get">go get</a>和<a href="../Module-awareCommands#go-mod-tidy">go mod tidy</a>命令可以用来修复大多数这些问题。此外，<code>-mod=mod</code>标志可用于大多数模块感知命令（<code>go build</code>、<code>go test</code>等），指示<code>go</code>命令自动修复<code>go.mod</code>和<code>go.sum</code>中的问题。</p>
<p>例如，考虑这个<code>go.mod</code>文件：</p>
<pre tabindex="0"><code>module example.com/M

go 1.16

require (
    example.com/A v1
    example.com/B v1.0.0
    example.com/C v1.0.0
    example.com/D v1.2.3
    example.com/E dev
)

exclude example.com/D v1.2.3
</code></pre><p>​	用 <code>-mod=mod</code> 触发的更新将非经典版本标识符重写为<a href="../Glossary#canonical-version">canonical（经典）</a>的 semver 形式，因此 <code>example.com/A</code> 的 <code>v1</code> 变成了 <code>v1.0.0</code>，而 <code>example.com/E</code> 的 <code>dev</code> 变成了 <code>dev</code> 分支上最新提交的伪版本，可能是 <code>v0.0.0-20180523231146-b3f5c0f6e5f1</code>。</p>
<p>​	该更新修改了requirements 以尊重排除项，因此对排除项 <code>example.com/D v1.2.3</code> 的 requirements 被更新为使用 <code>example.com/D</code> 的下一个可用版本，可能是 <code>v1.2.4</code> 或 <code>v1.3.0</code>。</p>
<p>​	该更新移除了多余的或误导性的 requirements。例如，如果 <code>example.com/A v1.0.0</code> 本身需要 <code>example.com/B v1.2.0</code> 和 <code>example.com/C v1.0.0</code>，那么 <code>go.mod</code> 对 <code>example.com/B v1.0.0</code> 的 requirement 是误导性的（被 <code>example.com/A</code> 对 <code>v1.2.0</code> 的 requirement 所取代），而它对 <code>example.com/C v1.0.0</code> 的 requirement 是多余的（被 <code>example.com/A</code> 对相同版本的需求暗示），因此两者都将被移除。如果主模块包含直接从<code>example.com/B</code>或<code>example.com/C</code>导入的包，那么requirement 将被保留，但会更新为实际使用的版本。</p>
<p>​	最后，该更新会将<code>go.mod</code>改成经典格式，这样未来的机械更改将导致最小的差异。如果只需要更改格式，<code>go</code>命令将不更新<code>go.mod</code>。</p>
<p>​	因为模块图定义了 import 语句的含义，任何加载包的命令也会使用<code>go.mod</code>，因此可以对其进行更新的（命令），包括<code>go build</code>、<code>go get</code>、<code>go install</code>、<code>go list</code>、<code>go test</code>、<code>go mod tidy</code>。</p>
<p>​	在Go 1.15及以下版本中，<code>-mod=mod</code>标志是默认启用的，所以更新会自动进行。从Go 1.16开始，<code>go</code>命令的行为就像设置了<code>-mod=readonly</code>一样：如果需要对<code>go.mod</code>进行任何更改，<code>go</code>命令会报告一个错误并建议进行修复。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-a2f3c0a94659ff151eed86d11c371f72">4 - 最小版本选择 (MVS)</h1>
    
	<h2 id="minimal-version-selection-mvs-最小版本选择-mvs">Minimal version selection (MVS) 最小版本选择 (MVS)</h2>
<blockquote>
<p>原文：<a href="https://go.dev/ref/mod#minimal-version-selection" target="_blank" rel="noopener">https://go.dev/ref/mod#minimal-version-selection</a></p>
</blockquote>
<p>​	Go 使用一种叫做最小版本选择（<code>MVS</code>）的算法来选择一组模块的版本，以便在构建包时使用。在Russ Cox的<a href="https://research.swtch.com/vgo-mvs" target="_blank" rel="noopener">Minimal Version Selection（最小版本选择）</a>中详细描述了<code>MVS</code>。</p>
<p>​	从概念上讲，MVS在模块的有向图上操作，用<a href="../gomodFiles">go.mod文件</a>指定。图中的每个顶点代表一个模块版本。每条边代表一个依赖的最小需求版本，用<a href="../gomodFiles#require-directive">require</a>指令指定。该图可以通过主模块的<code>go.mod</code>文件中的<a href="../gomodFiles#exclude-directive">exclude</a>和<a href="../gomodFiles#replace-directive">replace</a>指令以及<code>go.work</code>文件中的<a href="../Workspaces#replace-directive">replace</a>指令来修改。</p>
<p>​	MVS 生成<a href="../Glossary#build-list">build list（构建列表）</a>作为输出，即用于构建的模块版本列表。</p>
<p>​	MVS 从主模块（图中没有版本的特殊顶点）开始，遍历图，跟踪每个模块所需的最高版本。在遍历结束后，所需的最高版本组成了构建列表：它们是满足所有requirements的最小版本。</p>
<p>​	可以用 <a href="../Module-awareCommands#go-list-m">go list -m all</a> 命令来检查构建列表。与其他依赖项管理系统不同，构建列表不保存在一个 &ldquo;lock&quot;文件中。MVS是确定性的，当新版本的依赖项发布时，构建列表不会改变，因此在每个模块感知命令的开头使用MVS进行计算。</p>
<p>​	考虑下图中的示例。主模块要求模块 A 的版本为 1.2 或更高，模块 B 的版本为 1.2 或更高。A 1.2和B 1.2分别需要C 1.3和C 1.4。C 1.3和C 1.4都需要D 1.2。</p>
<p>


<img src="/docs/References/GoModulesReference/MVS_img/buildlist.svg"
     alt="Module version graph with visited versions highlighted"
     
/>




</p>
<p>​		Module version graph with visited versions highlighted</p>
<p>​      模块版本图，访问过的版本突出显示</p>
<p>​	MVS访问并加载用蓝色突出显示的每个模块版本的<code>go.mod</code>文件。在该图遍历结束时，MVS返回一个包含加粗版本的构建列表：A 1.2, B 1.2, C 1.4, 和 D 1.2。注意，B和D的更高版本是可用的，但MVS并没有选择它们，因为没有任何东西需要它们。</p>
<h3 id="replacement-替换">Replacement 替换</h3>
<p>​	模块的内容（包括它的<code>go.mod</code>文件）可以用主模块的<code>go.mod</code>文件或工作区的<code>go.work</code>文件中的<code>replace</code>指令来替换。<code>replace</code>指令可以应用于模块的特定版本或模块的所有版本。</p>
<p>​	替换会改变模块图，因为替换的模块可能与被替换的版本有不同的依赖项。</p>
<p>​	考虑下面的例子，其中 C 1.4被 R 替换。R依赖于D 1.3而不是D 1.2，所以MVS返回一个包含A 1.2、B 1.2、C 1.4（用R替换）和D 1.3的构建列表。</p>
<p>


<img src="/docs/References/GoModulesReference/MVS_img/replace.svg"
     alt="Module version graph with a replacement"
     
/>




</p>
<p>​								Module version graph with a replacement</p>
<p>​									 带替换的模块版本图</p>
<h3 id="exclusion-排除">Exclusion 排除</h3>
<p>​	模块也可以用主模块<code>go.mod</code>文件中的<a href="../gomodFiles#exclude-directive">exclude 指令</a>在特定的版本中被排除。</p>
<p>​	排除也会改变模块图。当一个版本被排除时，它被从模块图中移除，对它的 requirements 被重定向到下一个更高版本。</p>
<p>​	考虑下面的例子。C 1.3 已经被排除。MVS 将表现得好像 A 1.2 需要 C 1.4（下一个更高版本）而不是 C 1.3 。</p>
<p>


<img src="/docs/References/GoModulesReference/MVS_img/exclude.svg"
     alt="Module version graph with an exclusion"
     
/>




</p>
<p>​								Module version graph with an exclusion</p>
<p>​										带排除的模块版本图</p>
<h3 id="upgrades-升级">Upgrades 升级</h3>
<p>​	<a href="../Module-awareCommands#go-get">go get</a> 命令可以用来升级一组模块。为了执行升级，<code>go</code> 命令在运行 MVS 之前更改了模块图，增加了从访问的版本到升级的版本的 edges （边）。</p>
<p>Consider the example below. Module B may be upgraded from 1.2 to 1.3, C may be upgraded from 1.3 to 1.4, and D may be upgraded from 1.2 to 1.3.</p>
<p>​	考虑下面的例子。模块 B 可以从 1.2 升级到 1.3，C 可以从 1.3 升级到 1.4，D 可以从 1.2 升级到 1.3。</p>
<p>


<img src="/docs/References/GoModulesReference/MVS_img/upgrade.svg"
     alt="Module version graph with upgrades"
     
/>




</p>
<p>​						Module version graph with upgrades</p>
<p>​												带有升级的模块版本图</p>
<p>​	升级（和降级）可能会增加或移除间接依赖项。在这种情况下，E 1.1和F 1.1在升级后出现在构建列表中，因为E 1.1是B 1.3所需要的。</p>
<p>​	为了保护升级，<code>go</code>命令更新了<code>go.mod</code>中的 requirements 。它将更改B的 requirement 为1.3版本。它还将添加对C 1.4和D 1.3的 requirements ，并加上<code>// indirect</code>注释，因为这些版本在其他情况下不会被选中。</p>
<h3 id="downgrade-降级">Downgrade 降级</h3>
<p>​	<a href="../Module-awareCommands#go-get">go get</a> 命令也可以用来降级一组模块。为了执行降级，<code>go</code>命令通过移除降级后的版本来更改模块图。它也会移除依赖于被移除版本的其他模块的版本，因为它们可能与降级后的依赖版本不兼容。如果主模块需要一个被降级移除的模块版本，该 requirement 将被更改为未被移除的先前版本。如果没有先前的版本，该 requirement 将被放弃。</p>
<p>​	考虑下面的例子。假设发现 C 1.4 有问题，所以我们降级到 C 1.3。C 1.4被从模块图中移除。B 1.2 也被移除，因为它需要 C 1.4 或更高版本。主模块对B的 requirement 被改为1.1。</p>
<p>


<img src="/docs/References/GoModulesReference/MVS_img/downgrade.svg"
     alt="Module version graph with downgrade"
     
/>




</p>
<p>​				Module version graph with downgrade</p>
<p>​										带有降级的模块版本图</p>
<p>​	<a href="../Module-awareCommands#go-get">go get</a>也可以完全移除依赖项，在参数后使用<code>@none</code>后缀。这与降级的工作原理类似。所有被命名的模块的版本都会从模块图中移除。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-74008b805544fd3d8aab4b9f34b8aac3">5 - 模块图的修剪</h1>
    
	<h2 id="module-graph-pruning-模块图的修剪">Module graph pruning 模块图的修剪</h2>
<blockquote>
<p>原文：<a href="https://go.dev/ref/mod#graph-pruning" target="_blank" rel="noopener">https://go.dev/ref/mod#graph-pruning</a></p>
</blockquote>
<p>​	如果主模块是<code>go 1.17</code>或更高版本，用于<a href="../MVS">minimal version selection（最小化版本选择）</a>的<a href="../Glossary#module-graph">模块图</a>仅包括每个模块依赖项的 immediate（直接）requirements ，这些依赖项在其自己的 <code>go.mod</code> 文件中指定到<code>go 1.17</code>或更高版本，除非该版本的模块也被<code>go 1.16</code>或更低版本的其他依赖（过渡性）所需要。(<code>go 1.17</code>版本的过渡性依赖项会从模块图中删去）。</p>
<p>​	由于 <code>go 1.17</code> 的 <code>go.mod</code> 文件包括构建任何包或测试所需的每个依赖项的 <a href="">require</a> 指令，因此修剪后的模块图包括<code>go build</code>或<code>go test</code><a href="../Glossary#main-module">main module（主模块）</a>明确要求的任何依赖项中的包所需的所有依赖项。不需要构建任何包或测试的模块不能影响其包的运行时行为，因此从模块图中修剪出来的依赖项只会导致其他不相关的模块之间的干扰。</p>
<p>​	那些 requirements 被修剪掉的模块仍然出现在模块图中，并且仍然被<code>go list -m all</code>报告：它们<a href="../Glossary#selected-version">selected versions（所选择的版本）</a>是已知的并且定义良好，并且包可以从这些模块中加载（例如，作为从其他模块加载的测试的过渡性依赖项）。然而，由于<code>go</code>命令不能轻易识别这些模块的哪些依赖项得到了满足，所以<code>go build</code>和<code>go test</code>的参数不能包括那些 requirements 已被修剪掉的模块的包。 <a href="../Module-awareCommands#go-get">go get</a>将包含每个命名包的模块提升为显式的依赖项，允许在该包上调用<code>go build</code>或<code>go test</code>。</p>
<p>​	<strong>因为Go 1.16和更早的版本不支持模块图的修剪</strong>，所以对于每个指定Go 1.16或更低版本的模块来说，完整的依赖项的过渡性闭包 —— 包括过渡性的<code>go 1.17</code>依赖项 —— 仍然被包括在内。(在 <code>go 1.16</code> 及以下版本中，<code>go.mod</code> 文件只包括<a href="../Glossary#direct-dependency">direct dependencies（直接依赖项）</a>，因此必须加载更大的图以确保包括所有间接依赖项）。</p>
<p>​	默认情况下，<a href="../Module-awareCommands#go-mod-tidy">go mod tidy</a>为模块记录的 <a href="../AuthenticatingModules#go.sum-files">go.sum 文件</a> 包括Go 版本在 <a href="../Module-awareCommands#go-directive">go 指令</a>中指定的版本的前一个版本所需的校验和。因此，<code>go 1.17</code> 的模块包括 Go 1.16 所加载的完整模块图所需的校验和，但 <code>go 1.18</code> 的模块将只包括 Go 1.17 所加载的修剪模块图所需的校验和。可以使用<code>-compat</code>标志来覆盖默认版本（例如，在<code>go 1.17</code>模块中更积极地修剪<code>go.sum</code>文件）。</p>
<p>​	更多细节参见<a href="https://go.googlesource.com/proposal/&#43;/master/design/36460-lazy-module-loading.md" target="_blank" rel="noopener">设计文档</a>。</p>
<h3 id="lazy-module-loading-延迟模块加载">Lazy module loading 延迟模块加载</h3>
<p>​	为模块图修剪增加的更全面的 requirements 也使得在模块内工作时可以进行另一种优化。如果主模块是在<code>go 1.17</code>或更高版本，<code>go</code>命令会避免加载完整的模块图，直到（或除非）需要它。相反，它只加载主模块的<code>go.mod</code>文件，然后尝试只使用这些 requirements 来加载要构建的包。如果在这些 requirements中没有找到要导入的包（例如，主模块之外的包的测试依赖项），那么模块图的其余部分将被加载。</p>
<p>​	如果在不加载模块图的情况下能找到所有导入的包，<code>go</code>命令将只加载包含这些包的模块的<code>go.mod</code>文件，并将它们的requirements 与主模块的requirements 进行核对，以确保它们是本地一致的。(不一致可能是由于版本控制的合并，手工编辑，以及使用本地文件系统路径<a href="../Module-awareCommands#replace-directive">替换</a>的模块的更改造成的）。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-cb69927624b9473a082eb855aaa8d583">6 - 工作区</h1>
    
	<h2 id="workspaces-工作区">Workspaces 工作区</h2>
<blockquote>
<p>原文：<a href="https://go.dev/ref/mod#workspaces" target="_blank" rel="noopener">https://go.dev/ref/mod#workspaces</a></p>
</blockquote>
<p>​	工作区是磁盘上模块的集合，在运行<a href="../MVS">minimal version selection (MVS) （最小版本选择（MVS））</a>时这些模块被用作主模块。</p>
<p>​	工作区可以在 <a href="#go-work-file">go.work 文件</a>中声明，该文件指定了工作区中每个模块目录的相对路径。当没有<code>go.work</code>文件存在时，工作区由包含当前目录的单个模块组成。</p>
<p>​	大多数处理模块的<code>go</code>子命令都是在由当前工作区决定的模块集合上操作的。<code>go mod init</code>、<code>go mod why</code>、<code>go mod edit</code>、<code>go mod tidy</code>、<code>go mod vendor</code>和<code>go get</code>总是在一个主模块上操作。</p>
<p>​	命令首先通过检查<code>GOWORK</code>环境变量来确定它是否处于工作区上下文中。如果<code>GOWORK</code>被设置为<code>off</code>，该命令将处于单模块上下文中。如果它是空的或者未提供，命令将在当前工作目录中搜索，然后在连续的父目录中搜索<code>go.work</code>这个文件。如果找到一个（<code>go.work</code>）文件，该命令将在该文件定义的工作区中操作；否则，工作区将只包括包含工作目录的模块。如果<code>GOWORK</code>命名一个以<code>.work</code>结尾的现有文件的路径，工作区模式将被启用。任何其他的值都是一个错误。你可以使用<code>go env GOWORK</code>命令来确定<code>go</code>命令正在使用哪个<code>go.work</code>文件。如果<code>go</code>命令没有进入工作区模式，<code>go env GOWORK</code>将为空。</p>
<h3 id="gowork-files">go.work files</h3>
<p>​	工作区是由一个名为<code>go.work</code>的UTF-8编码文本文件定义的。<code>go.work</code>文件是面向行的。每行包含一个指令，由一个关键字和参数组成。例如：</p>
<pre tabindex="0"><code>go 1.18

use ./my/first/thing
use ./my/second/thing

replace example.com/bad/thing v1.4.5 =&gt; example.com/good/thing v1.4.5
</code></pre><p>​	与<code>go.mod</code>文件一样，前导关键字可以从相邻的行中分解出来，形成一个块。</p>
<pre tabindex="0"><code>use (
    ./my/first/thing
    ./my/second/thing
)
</code></pre><p>​	<code>go</code>命令提供了几个操作<code>go.work</code>文件的子命令。<a href="../Module-awareCommands#go-work-init">go work init</a>创建新的<code>go.work</code>文件。<a href="../Module-awareCommands#go-work-use">go work use</a>向<code>go.work</code>文件添加模块目录。<a href="../Module-awareCommands#go-work-edit">go work edit</a>执行低级别的编辑。Go 程序可以使用 <a href="https://pkg.go.dev/golang.org/x/mod/modfile?tab=doc" target="_blank" rel="noopener">golang.org/x/mod/modfile</a> 包，以编程方式进行相同的更改。</p>
<h3 id="lexical-elements-词汇元素">Lexical elements 词汇元素</h3>
<p>​	<code>go.work</code>文件中的词汇元素的定义方式与<a href="../gomodFiles#lexical-elements">go.mod 文件</a>完全相同。</p>
<h3 id="grammar-语法">Grammar 语法</h3>
<p>​	<code>go.work</code>的语法由下面使用Extended Backus-Naur Form (EBNF)来指定。有关 EBNF 语法的详细信息，请参见 <a href="../../LanguageSpecification/Notation">Go 语言规范中的标记法部分</a>。</p>
<pre tabindex="0"><code>GoWork = { Directive } .
Directive = GoDirective |
            UseDirective |
            ReplaceDirective .
</code></pre><p>​	换行符、标识符和字符串分别用<code>newline</code>、<code>ident</code>和<code>string</code>表示。</p>
<p>​	模块路径和版本用<code>ModulePath</code>和<code>Version</code>来表示。模块路径和版本的指定方式与<a href="../gomodFiles#lexical-elements">go.mod文件</a>的指定方式完全相同。</p>
<pre tabindex="0"><code>ModulePath = ident | string . /* see restrictions above */
Version = ident | string .    /* see restrictions above */
</code></pre><h3 id="go-directive">go directive</h3>
<p>​	在一个有效的<code>go.work</code>文件中需要一个<code>go</code>指令。版本必须是有效的Go发布版本：一个正整数后跟一个点和一个非负整数（例如，<code>1.18</code>，<code>1.19</code>）。</p>
<p>​	<code>go</code>指令表示<code>go.work</code>文件所要使用的go工具链版本。如果<code>go.work</code>文件的格式发生了变化，未来版本的工具链将根据其指示的版本来解释该文件。</p>
<p>​	一个<code>go.work</code>文件最多只能包含一个<code>go</code>指令。</p>
<pre tabindex="0"><code>GoDirective = &#34;go&#34; GoVersion newline .
GoVersion = string | ident .  /* valid release version; see above */
</code></pre><p>示例：</p>
<pre tabindex="0"><code>go 1.18
</code></pre><h3 id="use-directive">use directive</h3>
<p>​	<code>use</code>将磁盘上的一个模块添加到工作区的主模块集合中。它的参数是包含该模块的<code>go.mod</code>文件的目录的相对路径。<code>use</code>指令并不添加包含在其参数目录下的子目录中的模块。这些模块可以由包含其<code>go.mod</code>文件的目录在单独的<code>use</code>指令中添加。=&gt;仍有疑问？？这里应该是“<code>require</code>指令中添加吧”？？</p>
<pre tabindex="0"><code>UseDirective = &#34;use&#34; ( UseSpec | &#34;(&#34; newline { UseSpec } &#34;)&#34; newline ) .
UseSpec = FilePath newline .
FilePath = /* platform-specific relative or absolute file path */
</code></pre><p>示例：</p>
<pre tabindex="0"><code>use ./mymod  // example.com/mymod

use (
    ../othermod
    ./subdir/thirdmod
)
</code></pre><h3 id="replace-directive">replace directive</h3>
<p>​	与<code>go.mod</code>文件中的<code>replace</code>指令类似，<code>go.work</code>文件中的<code>replace</code>指令用其他地方的内容替换一个模块的特定版本，或一个模块的所有版本。<code>go.work</code>中的通配符替换可以覆盖<code>go.mod</code>文件中特定版本的<code>replace</code>。</p>
<p>​	<code>go.work</code>文件中的<code>replace</code>指令会覆盖工作区模块中相同模块或模块版本的任何替换。</p>
<pre tabindex="0"><code>ReplaceDirective = &#34;replace&#34; ( ReplaceSpec | &#34;(&#34; newline { ReplaceSpec } &#34;)&#34; newline ) .
ReplaceSpec = ModulePath [ Version ] &#34;=&gt;&#34; FilePath newline
            | ModulePath [ Version ] &#34;=&gt;&#34; ModulePath Version newline .
FilePath = /* platform-specific relative or absolute file path */
</code></pre><p>示例：</p>
<pre tabindex="0"><code>replace golang.org/x/net v1.2.3 =&gt; example.com/fork/net v1.4.5

replace (
    golang.org/x/net v1.2.3 =&gt; example.com/fork/net v1.4.5
    golang.org/x/net =&gt; example.com/fork/net v1.4.5
    golang.org/x/net v1.2.3 =&gt; ./fork/net
    golang.org/x/net =&gt; ./fork/net
)
</code></pre>
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-f68c752dd537895a2595481a9e6b35e7">7 - 与非模块存储库的兼容性</h1>
    
	<h2 id="compatibility-with-non-module-repositories-与非模块存储库的兼容性">Compatibility with non-module repositories 与非模块存储库的兼容性</h2>
<blockquote>
<p>原文：<a href="https://go.dev/ref/mod#non-module-compat" target="_blank" rel="noopener">https://go.dev/ref/mod#non-module-compat</a></p>
</blockquote>
<p>​	为了确保从<code>GOPATH</code>到模块的平稳过渡，<code>go</code>命令可以通过添加<code>go.mod</code>文件，从尚未迁移到模块的存储库中以模块感知模式下载和构建包。</p>
<p>​	当 <code>go</code> 命令<a href="../VersionControlSystems">直接</a>从存储库中下载一个给定版本的模块时，它会查找模块路径的存储库 URL，将该版本映射到存储库中的一个修订版，然后提取该修订版的存储库存档。如果模块的路径等于存储库的根路径，且存储库的根目录不包含<code>go.mod</code>文件，那么<code>go</code>命令会在模块缓存中合成一个<code>go.mod</code>文件，其中包含一个<a href="../gomodFiles#module-directive">module 指令</a>，而不包含其他内容。由于合成的<code>go.mod</code>文件不包含其依赖项的<a href="../gomodFiles#require-directive"><code>require</code>指令</a>，依赖这些模块的其他模块可能需要额外的<code>require</code>指令（带有<code>// indirect</code>），以确保每个依赖项在每次构建时都以相同的版本被获取。</p>
<p>​	当<code>go</code>命令从<a href="../ModuleProxies#communicating-with-proxies">proxy（代理）</a>下载模块时，它将<code>go.mod</code>文件与其余模块内容分开下载。如果原始模块没有<code>go.mod</code>文件，那么代理将提供一个合成的<code>go.mod</code>文件。</p>
<h3 id="incompatible-versions">+incompatible versions</h3>
<p>​	在主版本2或更高版本发布的模块必须在其模块路径上有一个匹配的<a href="../ModulesPackagesAndVersions#major-version-suffixes">major version suffix（主版本后缀）</a>。例如，如果一个模块是以<code>v2.0.0</code>发布的，其路径必须有<code>/v2</code>的后缀。这允许 <code>go</code> 命令可以将一个项目的多个主版本视为不同的模块，即使它们是在同一个存储库中开发的。</p>
<p>​	主版本后缀的需求是在<code>go</code>命令添加模块支持时引入的，许多存储库在这之前已经将版本标记为主版本2或更高。为了保持与这些存储库的兼容性，<code>go</code>命令在没有<code>go.mod</code>文件的主版本2或更高的版本上添加一个<code>+incompatible</code>后缀。<code>+incompatible</code>表示某个版本与主版本号较低的版本属于同一个模块；因此，<code>go</code>命令可能会自动升级到较高的<code>+incompatible</code>版本，即使它可能会破坏构建。</p>
<p>​	考虑下面的示例需求：</p>
<pre tabindex="0"><code>require example.com/m v4.1.2+incompatible
</code></pre><p>​	版本<code>v4.1.2+incompatible</code>指的是提供<code>example.com/m</code>模块的存储库中的<a href="../Glossary#semantic-version-tag">semantic version tag（语义版本标签）</a><code>v4.1.2</code>。该模块必须在<a href="../Glossary#module-path">repository root path（存储库根目录）</a>中（也就是说，存储库根路径也必须是<code>example.com/m</code>），并且不能有<code>go.mod</code>文件存在。该模块可能有主版本号较低的版本，如<code>v1.5.2</code>，<code>go</code>命令可能会自动升级这些版本到<code>v4.1.2+incompatible</code>（有关升级如何工作的信息，请参见<a href="../MVS">最小版本选择（MVS）</a>）。</p>
<p>​	在版本<code>v2.0.0</code>被标记后迁移到模块的存储库通常应该发布一个新的主版本。在上面的例子中，作者应该创建一个路径为 <code>example.com/m/v5</code> 的模块，并发布 <code>v5.0.0</code> 版本。作者还应该更新模块中包的导入，使用前缀 <code>example.com/m/v5</code> 而不是 <code>example.com/m</code>。更详细的例子请参见<a href="../../../GoBlog/2019/GoModulesV2AndBeyond">Go Modules: v2 and Beyond（Go模块：v2及以后）</a>。</p>
<p>​	注意 <code>+incompatible</code> 后缀不应该出现在存储库的标签上；像 <code>v4.1.2+incompatible</code> 这样的标签会被忽略。这个后缀只出现在 <code>go</code> 命令所使用的版本中。关于版本和标签之间的区别，请参见<a href="../VersionControlSystems#mapping-versions-to-commits">Mapping versions to commits（将版本映射到提交）</a>。</p>
<p>​	还要注意的是，<code>+incompatible</code> 后缀可能会出现在<a href="../Glossary#pseudo-version">pseudo-versions（伪版本）</a>中。例如，<code>v2.0.1-20200722182040-012345abcdef+incompatible</code>可能是一个有效的伪版本。</p>
<h3 id="minimal-module-compatibility-最小的模块兼容性">Minimal module compatibility 最小的模块兼容性</h3>
<p>​	以主版本2或更高版本发布的模块需要在其<a href="../Glossary#module-path">module path（模块路径）</a>上有一个<a href="../Glossary#major-version-suffix">major version suffix（主版本后缀）</a>。该模块可以在其存储库中的<a href="../Glossary#major-version-subdirectory">major version subdirectory（主版本子目录）</a>下开发，也可以不在其中开发。这对于在构建 <code>GOPATH</code> 模式时在模块中导入包的包有一定的影响。</p>
<p>​	通常在 <code>GOPATH</code> 模式下，包被存储在与其<a href="../Glossary#repository-root-path">repository’s root path（存储库的根路径）</a>相匹配的目录中，该根路径与其在存储库中的目录相关联。例如，存储库中根路径 <code>example.com/repo</code>在子目录 <code>sub</code> 的包将被存储在 <code>$GOPATH/src/example.com/repo/sub</code>，并将被导入为 <code>example.com/repo/sub</code>。</p>
<p>​	对于带有主版本后缀的模块，人们可能希望在<code>$GOPATH/src/example.com/repo/v2/sub</code>目录下找到包<code>example.com/repo/v2/sub</code>。这就要求在其存储库的<code>v2</code>子目录中开发该模块。<code>go</code>命令支持这一点，但不需要它（请参见<a href="../VersionControlSystems#mapping-versions-to-commits">Mapping versions to commits（将版本映射到提交）</a>）。</p>
<p>​	如果模块不是在主版本的子目录中开发的，那么它在<code>GOPATH</code>中的目录将不包含主版本后缀，并且它的包可以在没有主版本后缀的情况下被导入。在上面的示例中，可以在目录 <code>$GOPATH/src/example.com/repo/sub</code> 中找到该包，并被导入为 <code>example.com/repo/sub</code>。</p>
<p>​	这给打算在模块模式和 <code>GOPATH</code> 模式下构建的包带来问题：模块模式需要后缀，而 <code>GOPATH</code> 模式不需要。</p>
<p>​	为了解决这个问题，在Go 1.11中加入了最小模块兼容性，并向后移植到Go 1.9.7和1.10.3。当导入路径被解析为 <code>GOPATH</code> 模式下的目录时：</p>
<p>（a）当解析形式为<code>$modpath/$vn/$dir</code>的导入时，其中：</p>
<ul>
<li><code>$modpath</code> 是有效的模块路径。</li>
<li><code>$vn</code>是主版本后缀。</li>
<li><code>$dir</code>可能是一个是空的子目录。</li>
</ul>
<p>（b）如果以下所有情况均为 true：</p>
<ul>
<li>
<p><code>$modpath/$vn/$dir</code>包不存在于任何相关的<code>vendor</code>目录中。</p>
</li>
<li>
<p><code>go.mod</code>文件与导入文件位于同一目录中，或者位于<code>$GOPATH/src</code>根目录以下的任何父目录中。</p>
</li>
<li>
<p>不存在<code>$GOPATH[i]/src/$modpath/$vn/$suffix</code>目录（对于任何根<code>$GOPATH[i]</code>）。</p>
</li>
<li>
<p>文件<code>$GOPATH[d]/src/$modpath/go.mod</code>存在(对于某个根<code>$GOPATH[d]</code>)，并且声明模块路径为<code>$modpath/$vn</code>。</p>
</li>
</ul>
<p>（c）那么将<code>$modpath/$vn/$dir</code>的导入解析到目录<code>$GOPATH[d]/src/$modpath/$dir</code>。</p>
<p>​	这个规则允许已经迁移到模块的包在<code>GOPATH</code>模式下构建时导入其他已经迁移到模块的包，即使没有使用主版本子目录。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-a5aab63856f0e0c52b2e02d67fbdf698">8 - 具有模块感知的命令</h1>
    
	<h2 id="module-aware-commands-具有模块感知的命令">Module-aware commands 具有模块感知的命令</h2>
<blockquote>
<p>原文：<a href="https://go.dev/ref/mod#mod-commands" target="_blank" rel="noopener">https://go.dev/ref/mod#mod-commands</a></p>
</blockquote>
<p>​	大多数 <code>go</code> 命令可以在模块感知模式或 <code>GOPATH</code> 模式下运行。在模块感知模式下，<code>go</code>命令使用<code>go.mod</code>文件来查找版本依赖项，它通常从<a href="../Glossary#module-cache">module cache（模块缓存）</a>中加载包，如果缺少模块则下载模块。在<code>GOPATH</code>模式下，<code>go</code>命令忽略了模块；它在<a href="../Glossary#vendor-directory">vendor 目录</a>和<code>GOPATH</code>中寻找依赖项。</p>
<p>​	从Go 1.16开始，无论<code>go.mod</code>文件是否存在，模块感知模式都是默认启用的。在较低的版本中，当当前目录或任何父目录中存在<code>go.mod</code>文件时，模块感知模式被启用。</p>
<p>​	模块感知模式可以通过<code>GO111MODULE</code>环境变量来控制，该变量可以设置为<code>on</code>、<code>off</code>、或<code>auto</code>。</p>
<ul>
<li>如果<code>GO111MODULE=off</code>，<code>go</code>命令会忽略<code>go.mod</code>文件，并在<code>GOPATH</code>模式下运行。</li>
<li>如果<code>GO111MODULE=on</code>或未设置，则<code>go</code>命令在模块感知模式下运行，即使没有<code>go.mod</code>文件存在。并非所有命令在没有<code>go.mod</code>文件的情况下都能运行：参见<a href="#module-commands-outside-a-module">Module commands outside a module（模块外的模块命令）</a>。</li>
<li>如果<code>GO111MODULE=auto</code>，如果当前目录或任何父目录中存在<code>go.mod</code>文件，<code>go</code>命令将以模块感知模式运行。在Go 1.15及更低版本中，这是默认行为。即使没有<code>go.mod</code>文件，<code>go mod</code>子命令和带<a href="#version-queries">version query（版本查询）</a>的<code>go install</code>也会以模块感知模式运行。</li>
</ul>
<p>​	在模块感知模式下，<code>GOPATH</code> 在构建过程中不再定义导入的含义，但它仍然存储下载的依赖项（在 <code>GOPATH/pkg/mod</code> 中；参见<a href="../ModuleCache">Module cache（模块缓存）</a>）和安装的命令（在 <code>GOPATH/bin</code> 中，除非设置了 <code>GOBIN</code>）。</p>
<h3 id="build-commands-构建命令">Build commands 构建命令</h3>
<p>​	所有加载包信息的命令都是模块感知的。这包括：</p>
<ul>
<li><code>go build</code></li>
<li><code>go fix</code></li>
<li><code>go generate</code></li>
<li><code>go get</code></li>
<li><code>go install</code></li>
<li><code>go list</code></li>
<li><code>go run</code></li>
<li><code>go test</code></li>
<li><code>go vet</code></li>
</ul>
<p>​	在模块感知模式下运行时，这些命令使用<code>go.mod</code>文件来解释命令行中列出的或写在Go源文件中的导入路径。这些命令接受以下所有模块命令通用的标志：</p>
<p>（a）<code>-mod</code>标志控制<code>go.mod</code>是否可以自动更新以及是否使用<code>vendor</code>目录。</p>
<ul>
<li><code>-mod=mod</code>告诉<code>go</code>命令忽略 <code>vendor</code> 目录并<a href="../gomodFiles#automatic-updates">automatically update（自动更新）</a><code>go.mod</code>，例如，当没有任何已知模块提供导入的包时。</li>
<li><code>-mod=readonly</code>告诉<code>go</code>命令忽略<code>vendor</code>目录，并在<code>go.mod</code>需要更新时报告一个错误。</li>
<li><code>-mod=vendor</code>告诉<code>go</code>命令使用<code>vendor</code>目录。在这种模式下，<code>go</code>命令将不使用网络或模块缓存。</li>
<li>默认情况下，如果<code>go.mod</code>中的<a href="../gomodFiles#go-directive">go 版本</a>是<code>1.14</code>或更高，并且有一个<code>vendor</code>目录，<code>go</code>命令就会像使用<code>-mod=vendor</code>一样行事。否则，<code>go</code>命令会像使用了<code>-mod=readonly</code>一样行事。</li>
</ul>
<p>（b）<code>-modcacherw</code>标志指示<code>go</code>命令以读写权限在模块缓存中创建新目录，而不是让它们成为只读。当这个标志被一致地使用时（通常是通过在环境中设置<code>GOFLAGS=-modcacherw</code>或运行<code>go env -w GOFLAGS=-modcacherw</code>），模块缓存可以用<code>rm -r</code>等命令删除，而不必先更改权限。<a href="#go-clean-modcache">go clean -modcache</a>命令可以用来删除模块缓存，无论是否使用了<code>-modcacherw</code>。</p>
<p>（c）<code>-modfile=file.mod</code>标志指示<code>go</code>命令读取（也可能写入）一个替代文件，而不是模块根目录下的<code>go.mod</code>。该文件的名称必须以<code>.mod</code>结尾。一个名为<code>go.mod</code>的文件必须仍然存在，以便确定模块根目录，但它不会被访问。当指定<code>-modfile</code>时，也会使用另一个<code>go.sum</code>文件：它的路径是通过修剪<code>.mod</code>扩展名和附加<code>.sum</code>从<code>-modfile</code>标志中得出的。</p>
<h3 id="vendoring">Vendoring</h3>
<p>​	当使用模块时，<code>go</code>命令通常通过将模块从它们的源下载到模块缓存中，然后从这些下载的副本中加载包来满足依赖项。Vendoring 可以用来允许与旧版本的Go互操作，或者确保所有用于构建的文件都存储在单个文件树中。</p>
<p>​	<a href="#go-mod-vendor">go mod vendor</a>命令在主模块的根目录下构建一个名为<code>vendor</code>的目录，其中包含<a href="../Glossary#main-module">主模块</a>中构建和测试包所需的所有包的副本。那些只被主模块外的包测试所导入的包不包括在内。与<a href="#go-mod-tidy">go mod tidy</a>和其他模块命令一样，在构建<code>vendor</code>目录时，除了<code>ignore</code>之外，不考虑其他的<a href="../Glossary#build-constraint">build constraints（构建约束）</a>。</p>
<p>​	<code>go mod vendor</code>还创建了包含供应商包列表和从中复制包的模块版本的<code>vendor/modules.txt</code>文件。启用 vendoring 时，这个清单被用作模块版本信息的来源，正如 <a href="#go-list-m">go list -m</a> 和 <a href="#go-version-m">go version -m</a> 所报告的那样。当 <code>go</code> 命令读取 <code>vendor/modules.txt</code> 时，它会检查模块的版本是否与 <code>go.mod</code> 一致。如果<code>go.mod</code>在<code>vendor/modules.txt</code>生成后发生了变化，<code>go</code>命令将报告一个错误。应再次运行<code>go mod vendor</code>以更新<code>vendor</code>目录。</p>
<p>​	如果<code>vendor</code>目录存在于主模块的根目录中，如果主模块的<code>go.mod</code>文件中的 go 版本是<code>1.14</code>或更高，它将被自动使用。要显式地启用 vendoring 功能，请在调用<code>go</code>命令时使用<code>-mod=vendor</code>标志。要禁用 vendoring，请使用 <code>-mod=readonly</code> 或 <code>-mod=mod</code>标志。</p>
<p>​	启用vendoring后，像<code>go build</code>和<code>go test</code>这样的<a href="#build-commands">build commands（构建命令）</a>会从<code>vendor</code>目录中加载包，而不是访问网络或本地模块缓存。<a href="#go-list-m">go list -m</a>命令只打印<code>go.mod</code>中列出的模块信息。当启用 vendoring 时，<code>go mod</code>命令（如<a href="#go-mod-download">go mod download</a> 和 <a href="#go-mod-tidy">go mod tidy</a>）的工作方式不会有所不同，它们仍然会下载模块和访问模块缓存。 当启用 vendoring 时，<a href="#go-get">go get</a>也不会有不同工作方式。</p>
<p>​	与<a href="../../../Other/Go1_5VendorExperiment">在<code>GOPATH</code>模式下 vendoring</a> 不同的是，<code>go</code>命令忽略了主模块根目录以外的 <code>vendor</code> 目录。此外，由于不使用其他模块中的 <code>vendor</code> 目录，<code>go</code>命令在构建<a href="../ModuleZipFiles">module zip files（模块压缩文件）</a>时不包括<code>vendor</code> 目录（但请参阅已知 bugs <a href="https://go.dev/issue/31562" target="_blank" rel="noopener">#31562</a>和<a href="https://go.dev/issue/37397" target="_blank" rel="noopener">#37397</a>）。</p>
<h3 id="go-get">go get</h3>
<p>使用方法：</p>
<pre tabindex="0"><code>go get [-d] [-t] [-u] [build flags] [packages]
</code></pre><p>示例：</p>
<pre tabindex="0"><code># Upgrade a specific module. 
# 升级特定模块。
$ go get golang.org/x/net

# Upgrade modules that provide packages imported by packages in the main module.
# 升级被主模块中包所导入的包的模块。
$ go get -u ./...

# Upgrade or downgrade to a specific version of a module.
# 升级或降级到模块的特定版本。
$ go get golang.org/x/text@v0.3.2

# Update to the commit on the module&#39;s master branch.
# 更新到模块的主分支上的提交。
$ go get golang.org/x/text@master

# Remove a dependency on a module and downgrade modules that require it
# to versions that don&#39;t require it.
# 移除模块上的依赖项，并将需要它的模块降级为不需要它的版本。
$ go get golang.org/x/text@none
</code></pre><p>​	<code>go get</code>命令更新<a href="../Glossary#main-module">main module （主模块）</a>的<code>go.mod</code>文件中的模块依赖项，然后构建并安装命令行中列出的包。</p>
<p>​	第一步是确定要更新哪些模块。<code>go get</code>接受包、包模式和模块路径的列表作为参数。如果指定了包参数，<code>go get</code>将更新提供该包的模块。如果指定了包模式（例如，<code>all</code>或带有<code>...</code>通配符的路径），<code>go get</code> 将该模式扩展为一组包，然后更新提供包的模块。如果一个参数命名了一个模块而不是一个包（例如，模块 <code>golang.org/x/net</code> 在其根目录下没有包），<code>go get</code> 将会更新模块，但不会构建包。如果没有指定参数，<code>go get</code>的行为就像指定了<code>.</code>（当前目录下的包）；这可以和<code>-u</code>标志一起使用，以更新提供导入包的模块。</p>
<p>​	每个参数可以包括一个版本查询后缀，表示所需的版本，如<code>go get golang.org/x/text@v0.3.0</code>。版本查询后缀由<code>@</code>符号和<a href="#version-queries">version query（版本查询）</a>组成，后者可以表示一个特定的版本（<code>v0.3.0</code>），一个版本前缀（<code>v0.3</code>），一个分支或标签名称（<code>master</code>），一个修订版（<code>1234abcd</code>），或者一个特殊的查询<code>latest</code>，<code>upgrade</code>，<code>patch</code>，或<code>none</code>。如果没有给出版本，<code>go get</code>使用<code>@upgrade</code>查询。</p>
<p>​	一旦<code>go get</code>将参数解析为特定的模块和版本，<code>go get</code>将在主模块的<code>go.mod</code>文件中添加、更改或移除<a href="../gomodFiles#require-directive">require 指令</a>，以确保这些模块在未来保持所需的版本。注意，<code>go.mod</code>文件中的要求版本是<em><strong>最小版本</strong></em>，可能会随着新的依赖项的加入而自动增加。参见<a href="../MVS">Minimal version selection (MVS)（最小版本选择（MVS））</a>，了解如何通过模块感知命令选择版本和解决冲突的细节。</p>
<p>​	当命令行上命名的模块被添加、升级或降级时，如果命名的模块的新版本需要其他更高版本的模块，其他模块可能被升级。例如，假设模块<code>example.com/a</code>升级到<code>v1.5.0</code>版本，该版本需要<code>v1.2.0</code>版本的模块<code>example.com/b</code>。如果模块<code>example.com/b</code>目前需要<code>v1.1.0</code>版本，<code>go get example.com/a@v1.5.0</code>也会将<code>example.com/b</code>升级到<code>v1.2.0</code>。</p>
<p>


<img src="/docs/References/GoModulesReference/Module-awareCommands_img/get-upgrade.svg"
     alt="go get upgrading a transitive requirement"
     
/>




</p>
<p>​		go get upgrading a transitive requirement</p>
<p>​					go get 升级一个过渡性需求</p>
<p>​	当命令行上命名的模块被降级或移除时，其他模块可能会被降级。继续上面的例子，假设模块 <code>example.com/b</code> 被降级到 <code>v1.1.0</code>。模块 <code>example.com/a</code> 也将被降级为需要<code>v1.1.0</code>的 <code>example.com/b</code>  的版本或更低的版本。</p>
<p>


<img src="/docs/References/GoModulesReference/Module-awareCommands_img/get-downgrade.svg"
     alt="go get downgrading a transitive requirement"
     
/>




</p>
<p>​		go get downgrading a transitive requirement</p>
<p>​				go get 降级一个过渡性需求</p>
<p>​	可以使用版本后缀<code>@none</code> 移除模块需求。这是一种特殊的降级。依赖于被移除模块的模块将被降级或根据需要被移除。模块需求可以被移除，即使它的一个或多个包被主模块的包所导入。在这种情况下，下一个构建命令可能会添加一个新的模块需求。</p>
<p>​	如果需要两个不同的版本的模块（在命令行参数中明确指定或为了满足升级和降级），<code>go get</code>将报告一个错误。</p>
<p>​	在<code>go get</code>选择了一组新的版本后，它会检查任何新选择的模块版本或任何在命令行上命名的提供包的模块是否被<a href="../Glossary#retracted-version">retracted（撤回）</a>或<a href="../Glossary#deprecated-module">deprecated（废弃）</a>。<code>go get</code>为它发现的每个撤回的版本或废弃的模块打印一个警告。<code>go list -m -u all</code>可以用来检查所有依赖项中的撤回和废弃。</p>
<p>After <code>go get</code> updates the <code>go.mod</code> file, it builds the packages named on the command line. Executables will be installed in the directory named by the <code>GOBIN</code> environment variable, which defaults to <code>$GOPATH/bin</code> or <code>$HOME/go/bin</code> if the <code>GOPATH</code> environment variable is not set.</p>
<p>​	在<code>go get</code>更新<code>go.mod</code>文件后，它将构建命令行上指定的包。可执行文件将被安装在由<code>GOBIN</code>环境变量命名的目录中，如果没有设置<code>GOBIN</code>环境变量，则默认为<code>$GOPATH/bin或$HOME/go/bin</code>。=&gt;仍有疑问？？这里应该是：“如果没有设置<code>GOBIN</code>环境变量”。</p>
<p><code>go get</code>支持以下标志：</p>
<ul>
<li><code>-d</code> 标志告诉 <code>go get</code> 不要构建或安装包。当使用 <code>-d</code> 时，<code>go get</code> 将只管理 <code>go.mod</code> 中的依赖项。在没有<code>-d</code>的情况下使用<code>go get</code>来构建和安装包已经被废弃了（从Go 1.17开始）。在 Go 1.18 中，<code>-d</code> 将永远被启用。</li>
<li><code>-u</code> 标志告诉 <code>go get</code> 升级提供直接或间接由命令行上命名的包导入的模块。由 <code>-u</code> 选择的每个模块将被升级到其最新版本，除非它已经被要求在一个更高的（预发布版）版本。</li>
<li><code>-u=patch</code>标志（不是<code>-u patch</code>）也告诉<code>go get</code>升级依赖项，但<code>go get</code>将把每个依赖项升级到最新的修订版本（类似于<code>@patch</code>版本查询）。</li>
<li><code>-t</code> 标志告诉 <code>go get</code> 考虑构建命令行上命名的包的测试所需的模块。当<code>-t</code>和<code>-u</code>一起使用时，<code>go get</code>也会更新测试依赖。</li>
<li>不应再使用 <code>-insecure</code> 标志。它允许<code>go get</code>解析自定义导入路径，并使用不安全的方案（如HTTP）从存储库和模块代理处获取。<code>GOINSECURE</code> <a href="../EnvironmentVariables">environment variable（环境变量）</a>提供了更精细的控制，应该使用它来代替。</li>
</ul>
<p>​	从 Go 1.16 开始，<a href="#go-install">go install</a> 是推荐用于构建和安装程序的命令。当与版本后缀一起使用时（如<code>@latest</code>或<code>@v1.4.6</code>），<code>go install</code>以模块感知模式构建包，忽略当前目录或任何父目录中的<code>go.mod</code>文件（如果有的话）。</p>
<p>​	<code>go get</code> 更加专注于管理 <code>go.mod</code> 中的需求。<code>-d</code> 标志已被弃用，在 Go 1.18 中，它将一直被启用。</p>
<h3 id="go-install">go install</h3>
<p>使用方法：</p>
<pre tabindex="0"><code>go install [build flags] [packages]
</code></pre><p>示例：</p>
<pre tabindex="0"><code># Install the latest version of a program,
# ignoring go.mod in the current directory (if any).
# 安装一个程序的最新版本。忽略当前目录中的 go.mod（如果有的话）。
$ go install golang.org/x/tools/gopls@latest

# Install a specific version of a program.
# 安装一个特定版本的程序。
$ go install golang.org/x/tools/gopls@v0.6.4

# Install a program at the version selected by the module in the current directory.
# 在当前目录下安装一个由模块选择的版本的程序。
$ go install golang.org/x/tools/gopls

# Install all programs in a directory.
# 在一个目录中安装所有程序。
$ go install ./cmd/...
</code></pre><p>The <code>go install</code> command builds and installs the packages named by the paths on the command line. Executables (<code>main</code> packages) are installed to the directory named by the <code>GOBIN</code> environment variable, which defaults to <code>$GOPATH/bin</code> or <code>$HOME/go/bin</code> if the <code>GOPATH</code> environment variable is not set. Executables in <code>$GOROOT</code> are installed in <code>$GOROOT/bin</code> or <code>$GOTOOLDIR</code> instead of <code>$GOBIN</code>. Non-executable packages are built and cached but not installed.</p>
<p>​	<code>go install</code>命令建立并安装由命令行上的路径命名的包。可执行文件（<code>main</code>包）被安装到由<code>GOBIN</code>环境变量命名的目录中，如果没有设置<code>GOPATH</code>环境变量，则默认为<code>$GOPATH/bin</code>或<code>$HOME/go/bin</code>。<code>$GOROOT</code>中的可执行程序会被安装到<code>$GOROOT/bin</code>或<code>$GOTOOLDIR</code>中，而不是<code>$GOBIN</code>。非可执行包会被构建和缓存，但不会安装。=&gt;仍有疑问？？这里应该是：“如果没有设置<code>GOBIN</code>环境变量”？</p>
<p>​	从Go 1.16开始，如果参数有版本后缀（如<code>@latest</code>或<code>@v1.0.0</code>），<code>go install</code>会以模块感知模式构建包，忽略当前目录或任何父目录中的<code>go.mod</code>文件（如果有）。这对于安装可执行文件而不影响主模块的依赖项很有用。</p>
<p>​	为了消除在构建中使用哪些模块版本的歧义，参数必须满足以下限制：</p>
<p>（a）参数必须是包路径或包模式（带有&quot;<code>...</code>&ldquo;通配符）。它们不能是标准包（如<code>fmt</code>）、元模式（<code>std</code>、<code>cmd</code>、<code>all</code>）或相对或绝对文件路径。</p>
<p>（b）所有参数必须具有相同的版本后缀。不允许使用不同的查询，即使它们引用的是同一个版本。</p>
<p>（c）所有参数必须引用同一模块中同一版本的包。</p>
<p>（d）包路径参数必须指的是<code>main</code>包。模式参数将只匹配<code>main</code>包。</p>
<p>（e）没有模块被认为是主模块。</p>
<ul>
<li>如果命令行中包含包的模块有一个 <code>go.mod</code>文件，那么它就不能包含指令（<code>replace</code>和<code>exclude</code>），如果它是主模块，那么这些指令会导致对它的解释不同。</li>
<li>该模块不能要求自己有更高的版本。</li>
<li>在任何模块中都不使用<code>vendor</code>目录。(<code>vendor</code>目录不包括在<a href="../ModuleZipFiles">module zip files（模块压缩文件）</a>中，所以<code>go install</code>不会下载它们）。</li>
</ul>
<p>​	有关支持的版本查询语法，请参见<a href="#version-queries">Version queries（版本查询）</a>。Go 1.15 及以下版本不支持在 <code>go install</code> 中使用版本查询。</p>
<p>​	如果参数没有版本后缀，<code>go install</code> 可能以模块感知模式或 <code>GOPATH</code> 模式运行，这取决于 <code>GO111MODULE</code> 环境变量和 <code>go.mod</code> 文件的存在。详情请参见<a href="#module-aware-commands">模块感知命令</a>。如果启用了模块感知模式，<code>go install</code> 在主模块的上下文中运行，这可能与包含正在安装的包的模块不同。</p>
<h3 id="go-list--m">go list -m</h3>
<p>使用方法：</p>
<pre tabindex="0"><code>go list -m [-u] [-retracted] [-versions] [list flags] [modules]
</code></pre><p>示例：</p>
<pre tabindex="0"><code>$ go list -m all
$ go list -m -versions example.com/m
$ go list -m -json example.com/m@latest
</code></pre><p>​	<code>-m</code>标志使<code>go list</code>列出模块而不是包。在这种模式下，<code>go list</code>的参数可以是模块、模块模式（包含<code>...</code>通配符）、<a href="#version-queries">版本查询</a>，或者特殊模式<code>all</code>（它匹配<a href="../Glossary#build-list">build list（构建列表）</a>中的所有模块）。如果没有指定参数，<a href="../Glossary#main-module">main module（主模块）</a>将被列出。</p>
<p>​	当列出模块时，<code>-f</code>标志仍然指定应用于<code>Go</code> 结构体的格式模板，但现在是一个<code>Module</code>结构体：</p>
<pre tabindex="0"><code>type Module struct {
    Path       string        // module path
    Version    string        // module version
    Versions   []string      // available module versions
    Replace    *Module       // replaced by this module
    Time       *time.Time    // time version was created
    Update     *Module       // available update (with -u)
    Main       bool          // is this the main module?
    Indirect   bool          // module is only indirectly needed by main module
    Dir        string        // directory holding local copy of files, if any
    GoMod      string        // path to go.mod file describing module, if any
    GoVersion  string        // go version used in module
    Retracted  []string      // retraction information, if any (with -retracted or -u)
    Deprecated string        // deprecation message, if any (with -u)
    Error      *ModuleError  // error loading module
}

type ModuleError struct {
    Err string // the error itself
}
</code></pre><p>​	默认输出是打印模块路径，然后是版本和替换信息（如果有）。例如，<code>go list -m all</code>可能会打印：</p>
<pre tabindex="0"><code>example.com/main/module
golang.org/x/net v0.1.0
golang.org/x/text v0.3.0 =&gt; /tmp/text
rsc.io/pdf v0.1.1
</code></pre><p>​	<code>Module</code>结构体有一个<code>String</code>方法用来格式化这一行的输出，因此默认格式相当于<code>-f '{{.String}}'</code>。</p>
<p>​	注意，当一个模块被替换时，它的<code>Replace</code>字段描述了替换的模块，它的<code>Dir</code>字段被设置为替换模块的源代码（如果存在的话）。(也就是说，如果<code>Replace</code>不是nil，那么Dir被设置为<code>Replace.Dir</code>，不能访问被替换的源代码。)</p>
<p>​	<code>-u</code> 标志增加了关于可用升级的信息。当一个给定模块的最新版本比当前版本新时，<code>list -u</code>将模块的<code>Update</code>字段设置为较新模块的信息。<code>list -u</code>还打印当前选择的版本是否<a href="../Glossary#retracted-version">retracted（被撤回）</a>，以及该模块是否<a href="../gomodFiles#deprecation">deprecated（被废弃）</a>。模块的 <code>String</code> 方法通过在当前版本后面的方括号中格式化较新的版本来表示可用的升级。例如，<code>go list -m -u all</code>可能打印：</p>
<pre tabindex="0"><code>example.com/main/module
golang.org/x/old v1.9.9 (deprecated)
golang.org/x/net v0.1.0 (retracted) [v0.2.0]
golang.org/x/text v0.3.0 [v0.4.0] =&gt; /tmp/text
rsc.io/pdf v0.1.1 [v0.1.2]
</code></pre><p>(对于工具来说，<code>go list -m -u -json all</code> 可能更方便解析。)</p>
<p>​	<code>-versions</code> 标志使 <code>list</code> 将模块的 <code>Versions</code> 字段设置为该模块的所有已知版本的列表，按照语义版本划分从低到高排序。该标志还改变了默认的输出格式，以显示模块路径后跟空格分隔的版本列表。除非同时指定了<code>-retracted</code>标志，否则这个列表中会省略掉被撤回的版本。</p>
<p>​	<code>-retracted</code> 标志指示 <code>list</code> 在用 <code>-versions</code> 标志打印的列表中显示撤回的版本，并在解析版本查询时考虑撤回的版本。例如，<code>go list -m -retracted example.com/m@latest</code> 显示了 <code>example.com/m</code> 模块的最高发布或预发布版本，即使该版本已被撤回。<a href="../gomodFiles#retract-directive">retract 指令</a>和<a href="../gomodFiles#deprecation">废弃</a>的内容会以该版本从 <code>go.mod</code> 文件加载。<code>-retracted</code>标志是在Go 1.16中加入的。</p>
<p>​	模板函数<code>module</code>接收单个字符串参数，该参数必须是模块路径或查询，并将指定的模块作为<code>Module</code>结构体返回。如果发生错误，结果将是一个带有非nil<code>Error</code>字段的<code>Module</code>结构体。</p>
<h3 id="go-mod-download">go mod download</h3>
<p>使用方法：</p>
<pre tabindex="0"><code>go mod download [-json] [-x] [modules]
</code></pre><p>示例：</p>
<pre tabindex="0"><code>$ go mod download
$ go mod download golang.org/x/mod@v0.2.0
</code></pre><p>​	<code>go mod download</code>命令将命名的模块下载到<a href="../Glossary#module-cache">module cache（模块缓存）</a>中。参数可以是选择主模块的依赖项的模块路径或模块模式，也可以是<code>path@version</code>形式的<a href="#version-queries">版本查询</a>。如果没有参数，<code>download</code>适用于<a href="../Glossary#main-module">主模块</a>的所有依赖项。</p>
<p><code>go</code>命令会在正常执行过程中根据需要自动下载模块。<code>go mod download</code>命令主要用于预先填充模块缓存或加载由<a href="../Glossary#module-proxy">module proxy（模块代理）</a>提供的数据。</p>
<p>​	默认情况下，<code>download</code>不向标准输出写入任何内容。它将进度信息和错误打印到标准错误中。</p>
<p>​	<code>-json</code>标志使<code>download</code>将一连串的JSON对象打印到标准输出，描述每个下载的模块（或失败），对应于这个Go结构体：</p>
<pre tabindex="0"><code>type Module struct {
    Path     string // module path
    Query    string // version query corresponding to this version
    Version  string // module version
    Error    string // error loading module
    Info     string // absolute path to cached .info file
    GoMod    string // absolute path to cached .mod file
    Zip      string // absolute path to cached .zip file
    Dir      string // absolute path to cached source root directory
    Sum      string // checksum for path, version (as in go.sum)
    GoModSum string // checksum for go.mod (as in go.sum)
    Origin   any    // provenance of module
    Reuse    bool   // reuse of old module info is safe
}
</code></pre><p>​	<code>-x</code> 标志使<code>download</code>将<code>download</code>执行的命令打印到标准错误中。</p>
<h3 id="go-mod-edit">go mod edit</h3>
<p>使用方法：</p>
<pre tabindex="0"><code>go mod edit [editing flags] [-fmt|-print|-json] [go.mod]
</code></pre><p>示例：</p>
<pre tabindex="0"><code># Add a replace directive.
# 添加一个替换指令。
$ go mod edit -replace example.com/a@v1.0.0=./a

# Remove a replace directive.
# 移除一个替换指令。
$ go mod edit -dropreplace example.com/a@v1.0.0

# Set the go version, add a requirement, and print the file
# instead of writing it to disk.
# 设置go 版本，添加一个需求，并打印文件，而不是将其写入磁盘。
$ go mod edit -go=1.14 -require=example.com/m@v1.0.0 -print

# Format the go.mod file.
# 格式化 go.mod 文件
$ go mod edit -fmt

# Format and print a different .mod file.
# 格式化并打印一个不同的.mod文件。
$ go mod edit -print tools.mod

# Print a JSON representation of the go.mod file.
# 打印go.mod文件的JSON表示。
$ go mod edit -json
</code></pre><p>​	<code>go mod edit</code>命令为编辑和格式化<code>go.mod</code>文件提供了一个命令行界面，主要供工具和脚本使用。<code>go mod edit</code>只读取一个<code>go.mod</code>文件；它不查询其他模块的信息。默认情况下，<code>go mod edit</code>读写主模块的<code>go.mod</code>文件，但可以在编辑标志后指定一个不同的目标文件。</p>
<p>​	编辑标志指定了一连串的编辑操作。</p>
<ul>
<li>
<p><code>-module</code>标志更改模块的路径（<code>go.mod</code>文件的模块行）。</p>
</li>
<li>
<p><code>-go=version</code> 标志设置预期的 Go 语言版本。</p>
</li>
<li>
<p><code>-require=path@version</code> 和 <code>-droprequire=path</code> 标志在给定的模块路径和版本上添加和移除一个需求。注意 <code>-require</code> 会覆盖路径上的任何现有需求。这些标志主要用于理解模块图的工具。用户应该更喜欢 <code>go get path@version</code> 或 <code>go get path@none</code>，它们会根据需要进行其他 <code>go.mod</code> 调整，以满足其他模块施加的约束。参见<a href="#go-get">go get</a>。</p>
</li>
<li>
<p><code>-exclude=path@version</code> 和 <code>-dropexclude=path@version</code> 标志为指定的模块路径和版本添加和移除一个排除项。请注意，如果排除已经存在，则<code>-exclude=path@version</code>是一个no-op。</p>
</li>
<li>
<p><code>-replace=old[@v]=new[@v]</code> 标志增加对给定模块路径和版本的替换。如果省略了<code>old@v</code>中的<code>@v</code>，就会添加一个左侧没有版本的替换，它适用于旧模块路径的所有版本。如果<code>new@v</code>中的<code>@v</code>被省略，新路径应该是本地模块根目录，而不是模块路径。注意，<code>-replace</code> 覆盖了<code>old[@v]</code>的所有冗余替换，因此省略<code>@v</code>将移除对特定版本的替换。</p>
</li>
<li>
<p><code>-dropreplace=old[@v]</code> 标志会放弃对给定模块路径和版本的替换。如果提供了<code>@v</code>，就会移除具有给定版本的替换。左侧没有版本的现有替换仍然可以替换该模块。如果省略了<code>@v</code>，没有版本的替换将被移除。</p>
</li>
<li>
<p><code>-retract=version</code>和<code>-dropretract=version</code>标志为给定的版本添加和移除一个撤回，这个版本可以是一个单一的版本（如<code>v1.2.3</code>）或一个间隔（如<code>[v1.1.0,v1.2.0]</code>）。注意，<code>-retract</code>标志不能为<code>retract</code>指令添加理由注释。理由注释是推荐的，可以通过<code>go list -m -u</code>和其他命令显示。</p>
</li>
</ul>
<p>​		编辑标志可以重复使用。更改是按照给出的顺序进行的。</p>
<p>​		<code>go mod edit</code>有额外的标志来控制其输出。</p>
<ul>
<li><code>-fmt</code>标志对<code>go.mod</code>文件进行重新格式化，而不做其他修改。使用或重写 <code>go.mod</code> 文件的任何其他修改也暗示了这种重新格式化。只有在没有指定其他标志的情况下才需要这个标志，如<code>go mod edit -fmt</code>。</li>
<li><code>-print</code>标志以文本格式打印最终的<code>go.mod</code>，而不是将其写回磁盘。</li>
<li><code>-json</code>标志以JSON格式打印最终的<code>go.mod</code>，而不是以文本格式写回磁盘。JSON输出对应的是这些Go类型：</li>
</ul>
<pre tabindex="0"><code>type Module struct {
    Path    string
    Version string
}

type GoMod struct {
    Module  ModPath
    Go      string
    Require []Require
    Exclude []Module
    Replace []Replace
    Retract []Retract
}

type ModPath struct {
    Path       string
    Deprecated string
}

type Require struct {
    Path     string
    Version  string
    Indirect bool
}

type Replace struct {
    Old Module
    New Module
}

type Retract struct {
    Low       string
    High      string
    Rationale string
}
</code></pre><p>​	注意，这只是描述<code>go.mod</code>文件本身，而不是间接引用的其他模块。要想知道构建中可用的全部模块，请使用<code>go list -m -json all</code>。参见<a href="#go-list-m">go list -m</a>。</p>
<p>​	例如，一个工具可以通过解析<code>go mod edit -json</code>的输出来获得作为数据结构的<code>go.mod</code>文件，然后可以通过调用<code>go mod edit</code>的<code>-require</code>、<code>-exclude</code>等来进行更改。</p>
<p>​	工具也可以使用<a href="https://pkg.go.dev/golang.org/x/mod/modfile?tab=doc" target="_blank" rel="noopener">golang.org/x/mod/modfile</a>包来解析、编辑和格式化<code>go.mod</code>文件。</p>
<h3 id="go-mod-graph">go mod graph</h3>
<p>使用方法：</p>
<pre tabindex="0"><code>go mod graph [-go=version]
</code></pre><p>​	<code>go mod graph</code>命令以文本形式打印<a href="../Glossary#module-graph">module requirement graph（模块需求图）</a>（已应用替换）。例如：</p>
<pre tabindex="0"><code>example.com/main example.com/a@v1.1.0
example.com/main example.com/b@v1.2.0
example.com/a@v1.1.0 example.com/b@v1.1.1
example.com/a@v1.1.0 example.com/c@v1.3.0
example.com/b@v1.1.0 example.com/c@v1.1.0
example.com/b@v1.2.0 example.com/c@v1.2.0
</code></pre><p>​	模块图中的每个顶点代表一个模块的特定版本。图中的每条边代表对一个最小版本的依赖项的需求。</p>
<p>​	<code>go mod graph</code> 打印图中的边，每行一个。每行有两个空格分隔的字段：一个模块版本及其一个依赖项。每个模块版本是以<code>path@version</code>的形式标识的。主模块没有<code>@version</code>后缀，因为它没有版本。</p>
<p>​	<code>-go</code> 标志使 <code>go mod graph</code> 报告由给定 Go 版本加载的模块图，而不是 <code>go.mod</code> 文件中 <a href="../gomodFiles#go-directive">go 指令</a>指示的版本。</p>
<p>​	参见<a href="../MVS">Minimal version selection (MVS)（最小版本选择（MVS））</a>以了解更多关于如何选择版本的信息。参见 <a href="#go-list-m">go list -m</a> 以打印选定的版本，以及 <a href="#go-mod-why">go mod why</a> 以了解为什么需要某个模块。</p>
<h3 id="go-mod-init">go mod init</h3>
<p>使用方法：</p>
<pre tabindex="0"><code>go mod init [module-path]
</code></pre><p>示例：</p>
<pre tabindex="0"><code>go mod init
go mod init example.com/m
</code></pre><p>​	<code>go mod init</code>命令在当前目录下初始化并写入一个新的<code>go.mod</code>文件，实际上是在当前目录下创建一个新模块。这个<code>go.mod</code>文件必须事先不存在。</p>
<p>​	<code>init</code>接受一个可选参数，即新模块的<a href="../Glossary#module-path">module path（模块路径）</a>。关于选择模块路径的说明，见<a href="../ModulesPackagesAndVersions#module-paths">Module paths（模块路径）</a>。如果省略了模块路径参数，<code>init</code>将尝试使用<code>.go</code>文件中的导入注释、vendoring 工具配置文件和当前目录（如果在<code>GOPATH</code>）来推断模块路径。</p>
<p>​	如果 vendoring 工具的配置文件存在，<code>init</code>将尝试从其中导入模块需求。<code>init</code> 支持以下配置文件：</p>
<ul>
<li><code>GLOCKFILE</code> (Glock)</li>
<li><code>Godeps/Godeps.json</code> (Godeps)</li>
<li><code>Gopkg.lock</code> (dep)</li>
<li><code>dependencies.tsv</code> (godeps)</li>
<li><code>glide.lock</code> (glide)</li>
<li><code>vendor.conf</code> (trash)</li>
<li><code>vendor.yml</code> (govend)</li>
<li><code>vendor/manifest</code> (gvt)</li>
<li><code>vendor/vendor.json</code> (govendor)</li>
</ul>
<p>​	vendoring 工具的配置文件不可能总是以完美的保真度进行翻译。例如，如果同一存储库中的多个包以不同的版本被导入，而存储库只包含一个模块，那么导入的<code>go.mod</code>只能要求该模块的一个版本。你可能希望运行 <a href="#go-list-m">go list -m all</a> 来检查构建列表中的所有版本，并运行 <a href="#go-mod-tidy">go mod tidy</a> 来添加缺失的需求和移除未使用的需求。</p>
<h3 id="go-mod-tidy">go mod tidy</h3>
<p>使用方法：</p>
<pre tabindex="0"><code>go mod tidy [-e] [-v] [-go=version] [-compat=version]
</code></pre><p>​	<code>go mod tidy</code>确保<code>go.mod</code>文件与模块的源代码匹配。它添加任何缺失的模块需求，以构建当前模块的包和依赖项，并移除不提供任何相关包的模块的需求。它还会在<code>go.sum</code>中添加任何缺失的条目，并移除不必要的条目。</p>
<p>​	<code>-e</code> 标志（在 Go 1.16 中加入）使 <code>go mod tidy</code> 在加载包时遇到错误的情况下仍然尝试继续。</p>
<p>​	<code>-v</code>标志使<code>go mod tidy</code>将移除模块的信息打印到标准错误中。</p>
<p>​	<code>go mod tidy</code>的工作方式是以递归方式加载<a href="../Glossary#main-module">main module（主模块）</a>中的所有包和它们导入的所有包。这包括由测试导入的包（包括其他模块中的测试）。<code>go mod tidy</code>的行为就像所有的构建标签都是启用的，所以它会考虑特定平台的源文件和需要自定义构建标签的文件，即使这些源文件通常不会被构建。有一个例外：<code>ignore</code>构建标签没有被启用，所以具有<code>//+build ignore</code>构建约束的文件将不会被考虑。注意，<code>go mod tidy</code>不会考虑主模块中名为<code>testdata</code>的目录或名称以<code>.</code>或<code>_</code>开头的包，除非这些包被其他包明确导入。</p>
<p>​	一旦<code>go mod tidy</code>加载了这组包，它将确保每个提供一个或多个包的模块在主模块的<code>go.mod</code>文件中都有<code>require</code>指令，或者 —— 如果主模块在<code>go 1.16</code>或以下 —— 被另一个<code>require</code>模块所需要。<code>go mod tidy</code>将在每个缺失的模块的最新版本上添加<code>require</code>（最新版本的定义参见<a href="#version-queries">版本查询</a>）。</p>
<p>​	<code>go mod tidy</code> 也可以在 <code>require</code> 指令上添加或移除<code>// indirect</code>注释。一个<code>// indirect</code>注释表示一个模块没有提供被主模块中的包导入的包。(关于何时添加<code>// indirect</code>依赖项和注释的更多细节，请参见 <a href="../gomodFiles#require-directive">require 指令)</a>。</p>
<p>​	如果设置了 <code>-go</code> 标志，<code>go mod tidy</code> 将更新 <a href="../gomodFiles#go-directive">go 指令</a>到指定的版本，根据该版本启用或禁用<a href="../ModuleGraphPruning">module graph pruning（模块图修剪）</a>和<a href="../ModuleGraphPruning#lazy-module-loading">lazy module loading（延迟模块加载）</a>（并根据需要添加或移除间接需求）。</p>
<p>​	默认情况下，当模块图被<code>go</code>指令中指定的版本之前的Go版本加载时，<code>go mod tidy</code>将检查所选模块的版本是否没有发生变化。兼容性检查的版本也可以通过<code>-compat</code>标志显式指定。</p>
<h3 id="go-mod-vendor">go mod vendor</h3>
<p>使用方法：</p>
<pre tabindex="0"><code>go mod vendor [-e] [-v] [-o]
</code></pre><p>​	<code>go mod vendor</code> 命令在主模块的根目录下构建一个名为 <code>vendor</code> 的目录，其中包含所有支持主模块中的包的构建和测试所需的包的副本。那些只被主模块外的包测试所导入的包不包括在内。与<a href="#go-mod-tidy">go mod tidy</a>和其他模块命令一样，在构建<code>vendor</code>目录时，不考虑其他的<a href="../Glossary#build-constraint">build constraints（构建约束）</a>（<code>ignore</code>除外）。</p>
<p>​	当vendoring被启用时，<code>go</code>命令将从<code>vendor</code>目录中加载包，而不是将模块从它们的源下载到模块缓存中并使用那些下载的包。更多信息请参见<a href="#vendoring">Vendoring</a>。</p>
<p>​	<code>go mod vendor</code>还创建<code>vendor/modules.txt</code>文件，该文件中包含供应商包列表和从中复制包的模块版本。启用vendoring时，这个清单被用作模块版本信息的来源，正如<a href="#go-list-m">go list -m</a>和<a href="#go-version-m">go version -m</a>所报告的。当 <code>go</code> 命令读取 <code>vendor/modules.txt</code> 时，它会检查模块的版本是否与 <code>go.mod</code> 一致。如果<code>go.mod</code>在<code>vendor/modules.txt</code>生成后发生了变化，那么应该再次运行<code>go mod vendor</code>。</p>
<p>​	注意，如果<code>vendor</code>目录存在，<code>go mod vendor</code>会在重新构造之前移除它。 不应该对vendored包进行本地修改。<code>go</code>命令并不检查<code>vendor</code>目录下的包是否被修改过，但可以通过运行<code>go mod vendor</code>并检查是否有修改来验证<code>vendor</code>目录的完整性。</p>
<p>​	<code>-e</code>标志（在Go 1.16中加入）使<code>go mod vendor</code>在加载包时遇到错误的情况下仍然尝试继续进行。</p>
<p>​	<code>-v</code> 标志使 <code>go mod vendor</code> 打印出 vendored 的模块和包的名称到标准错误。</p>
<p>​	<code>-o</code>标志（在Go 1.18中加入）使<code>go mod vendor</code>输出指定目录下的vendor树，而不是<code>vendor</code>。参数可以是绝对路径或相对于模块根的路径。</p>
<h3 id="go-mod-verify">go mod verify</h3>
<p>使用方法：</p>
<pre tabindex="0"><code>go mod verify
</code></pre><p>​	<code>go mod verify</code>检查存储在<a href="../Glossary#module-cache">module cache（模块缓存）</a>中的<a href="../Glossary#main-module">main module（主模块）</a>的依赖项在下载后有没有被修改。为了进行这项检查，<code>go mod verify</code>对每个下载的模块<a href="../ModuleZipFiles">.zip文件</a>和提取的目录进行散列，然后将这些散列与模块首次下载时记录的散列进行比较。<code>go mod verify</code>检查构建列表中的每个模块（可以用<a href="#go-list-m">go list -m all</a>打印）。</p>
<p>​	如果所有的模块都没有被修改，<code>go mod verify</code>会打印出 &ldquo;all modules verified&rdquo;。否则，它会报告哪些模块被更改了，并以非零状态退出。</p>
<p>​	注意，所有的模块感知命令都会验证主模块的<code>go.sum</code>文件中的哈希值是否与下载到模块缓存中的模块的哈希值一致。如果<code>go.sum</code>文件中缺少哈希值（例如，因为模块是第一次使用），<code>go</code>命令会使用<a href="../AuthenticatingModules#checksum-database">校验数据库</a>验证其哈希值（除非模块路径与<code>GOPRIVATE</code>或<code>GONOSUMDB</code>匹配）。详见<a href="../AuthenticatingModules">Authenticating modules（验证模块）</a>。</p>
<p>​	相比之下，<code>go mod verify</code>会检查模块<code>.zip</code>文件及其提取的目录的哈希值是否与首次下载时模块缓存中记录的哈希值一致。这对检测模块下载和验证后模块缓存中文件的变化非常有用。<code>go mod verify</code>不下载缓存中没有的模块内容，也不使用<code>go.sum</code>文件来验证模块内容。然而，<code>go mod verify</code>可能会下载<code>go.mod</code>文件，以进行<a href="../MVS">minimal version selection（最小的版本选择）</a>。它将使用<code>go.sum</code>来验证这些文件，并可能为缺少的哈希值添加<code>go.sum</code>条目。</p>
<h3 id="go-mod-why">go mod why</h3>
<p>使用方法：</p>
<pre tabindex="0"><code>go mod why [-m] [-vendor] packages...
</code></pre><p>​	<code>go mod why</code>在导入图中显示了从主模块到每个列出的包的最短路径。</p>
<p>​	输出是一个节序列，命令行上命名的每个包或模块对应一个节，用空行分隔。每个节都以<code>#</code>开头的注释行开始，给出目标包或模块。随后的行给出了通过导入图的路径，每行一个包。如果该包或模块没有被主模块引用，节将显示一个带圆括号的注释来说明这一事实。</p>
<p>示例：</p>
<pre tabindex="0"><code>$ go mod why golang.org/x/text/language golang.org/x/text/encoding
# golang.org/x/text/language
rsc.io/quote
rsc.io/sampler
golang.org/x/text/language

# golang.org/x/text/encoding
(main module does not need package golang.org/x/text/encoding)
</code></pre><p>​	<code>-m</code>标志使<code>go mod why</code>将其参数视为模块列表。<code>go mod why</code>将打印每个模块中任何包的路径。注意，即使使用了<code>-m</code>，<code>go mod why</code>也会查询包图，而不是<a href="#go-mod-graph">go mod graph</a>打印的模块图。</p>
<p>​	<code>-vendor</code>标志使<code>go mod why</code>忽略在主模块之外的包的测试中的导入（就像<a href="#go-mod-vendor">go mod vendor</a> 所做的那样）。默认情况下，<code>go mod why</code>考虑由<code>all</code>模式匹配的包图。在声明<code>go 1.16</code>或更高版本(使用<code>go.mod</code>中的<a href="../gomodFiles#go-directive">go 指令</a>)的模块中，该标志在Go 1.16之后不再生效，因为<code>all</code>的含义更改为与<code>go mod vendor</code>匹配的包集合相匹配。</p>
<h3 id="go-version--m">go version -m</h3>
<p>使用方法：</p>
<pre tabindex="0"><code>go version [-m] [-v] [file ...]
</code></pre><p>示例：</p>
<pre tabindex="0"><code># Print Go version used to build go.
# 打印用于构建go的Go版本。
$ go version

# Print Go version used to build a specific executable.
# 打印用于构建特定可执行文件的Go版本。
$ go version ~/go/bin/gopls

# Print Go version and module versions used to build a specific executable.
# 打印用于构建特定可执行文件的Go版本和模块版本。
$ go version -m ~/go/bin/gopls

# Print Go version and module versions used to build executables in a directory.
# 打印用于在目录中构建可执行文件的Go版本和模块版本。
$ go version -m ~/go/bin/
</code></pre><p>​	<code>go version</code>报告用于构建命令行上命名的每个可执行文件的Go版本。</p>
<p>​	如果命令行上没有指定任何文件，<code>go version</code>将打印它自己的版本信息。</p>
<p>​	如果指定了一个目录，<code>go version</code>会递归地遍历该目录，查找已识别的Go二进制文件并报告它们的版本。默认情况下，<code>go version</code>不报告在目录扫描期间发现的无法识别的文件。<code>-v</code> 标志使它报告无法识别的文件。</p>
<p>​	<code>-m</code> 标志使 <code>go version</code> 在可用时打印每个可执行文件的嵌入式模块版本信息。对于每个可执行文件，<code>go version -m</code>会打印一个表格，表格中的列以制表符分隔，如下图所示。</p>
<pre tabindex="0"><code>$ go version -m ~/go/bin/goimports
/home/jrgopher/go/bin/goimports: go1.14.3
        path    golang.org/x/tools/cmd/goimports
        mod     golang.org/x/tools      v0.0.0-20200518203908-8018eb2c26ba      h1:0Lcy64USfQQL6GAJma8BdHCgeofcchQj+Z7j0SXYAzU=
        dep     golang.org/x/mod        v0.2.0          h1:KU7oHjnv3XNWfa5COkzUifxZmxp1TyI7ImMXqFxLwvQ=
        dep     golang.org/x/xerrors    v0.0.0-20191204190536-9bdfabe68543      h1:E7g+9GITq07hpfrRu66IVDexMakfv52eLZ2CXBWiKr4=
</code></pre><p>​	该表的格式在未来可能会改变。同样的信息可以从<a href="https://pkg.go.dev/runtime/debug?tab=doc#ReadBuildInfo" target="_blank" rel="noopener">runtime/debug.ReadBuildInfo</a>获得。</p>
<p>​	表中每一行的含义是由第一列中的字决定的。</p>
<ul>
<li><strong><code>path</code></strong>：用于构建可执行文件的<code>main</code>包的路径。</li>
<li><strong><code>mod</code></strong>：包含<code>main</code>包的模块。这些列分别是模块路径、版本和 sum。主模块有版本（<code>devel</code>），没有 sum。</li>
<li><strong><code>dep</code></strong>：提供一个或多个链接到可执行文件的包的模块。格式与<code>mod</code>相同。</li>
<li><strong><code>=&gt;</code></strong>：<a href="../gomodFiles#replace-directive">替换</a>上一行中的模块。如果替换的是本地目录，则只列出目录路径(没有版本或 sum)。如果替换的是模块版本，则会列出路径、版本和 sum，就像<code>mod</code>和<code>dep</code>一样。被替换的模块没有sum。</li>
</ul>
<h3 id="go-clean--modcache">go clean -modcache</h3>
<p>使用方法：</p>
<pre tabindex="0"><code>go clean [-modcache]
</code></pre><p>​	<code>-modcache</code>标志使<a href="../../CommandDocumentation/go#remove-object-files-and-cached-files">go clean</a>移除整个<a href="../Glossary#module-cache">module cache（模块缓存）</a>，包括版本化依赖项的未打包的源代码。</p>
<p>​	这通常是移除模块缓存的最佳方式。默认情况下，模块缓存中的大多数文件和目录都是只读的，以防止测试和编辑者在通过<a href="../AuthenticatingModules">authenticated（认证）</a>后无意中改更改文件。不幸的是，这导致像<code>rm -r</code>这样的命令失败，因为如果不首先使其父目录可写，就无法移除文件。</p>
<p>​	<code>-modcacherw</code>标志（被<a href="../../CommandDocumentation/go#compile-packages-and-dependencies">go build</a>和其他模块感知命令接受）使模块缓存中的新目录可以被写入。要将<code>-modcacherw</code>传递给所有的模块感知命令，请将其加入到<code>GOFLAGS</code>变量。<code>GOFLAGS</code>可以在环境中设置，也可以用<a href="../../CommandDocumentation/go#print-go-environment-information">go env -w</a>设置。例如，下面的命令会永久地设置它：</p>
<pre tabindex="0"><code>go env -w GOFLAGS=-modcacherw
</code></pre><p>​	<code>-modcacherw</code>应该谨慎使用；开发者应该注意不要对模块缓存中的文件进行更改。 <a href="#go-mod-verify">go mod verify</a>可以用来检查缓存中的文件是否与主模块的<code>go.sum</code>文件中的哈希值匹配。</p>
<h3 id="version-queries">Version queries</h3>
<p>​	有一些命令允许你使用版本查询来指定模块的版本，版本查询出现在命令行中模块或包路径后面的<code>@</code>字符之后。</p>
<p>示例：</p>
<pre tabindex="0"><code>go get example.com/m@latest
go mod download example.com/m@master
go list -m -json example.com/m@e3702bed2
</code></pre><p>​	版本查询可以是以下的一种：</p>
<ul>
<li>完全指定的语义版本，例如<code>v1.2.3</code>，它选择一个特定的版本。语法参见 <a href="../ModulesPackagesAndVersions#versions">Versions（版本）</a>。</li>
<li>语义版本前缀，例如<code>v1</code>或<code>v1.2</code>，它选择带有该前缀的最高可用版本。</li>
<li>语义上的版本比较，例如<code>&lt;v1.2.3</code>或<code>&gt;=v1.5.6</code>，它选择与比较目标最接近的可用版本（对于<code>&gt;</code>和<code>&gt;=</code>来说是最低版本，而对于<code>&lt;</code>和<code>&lt;=</code>来说是最高版本）。</li>
<li>底层源码库的修订标识符，例如提交哈希前缀、修订标签或分支名称。如果修订版被标记为语义版本，则该查询将选择该版本。否则，这个查询会选择底层提交的一个<a href="../Glossary#pseudo-version">伪版本</a>。请注意，不能以这种方式选择名称与其他版本查询匹配的分支和标签。例如，<code>v2</code>查询选择的是以<code>v2</code>开头的最新版本，而不是名为<code>v2</code>的分支。</li>
<li>字符串 <code>latest</code>，它选择可用的最高发布版本。如果没有发布版本，<code>latest</code>选择的是最高的预发布版本。如果没有标签版本，<code>latest</code> 会选择存储库默认分支顶端的提交的伪版本。</li>
<li>字符串 <code>upgrade</code>，与 <code>latest</code> 类似，但如果模块当前需要的版本高于 <code>latest</code> 选择的版本（例如，预发布版本），<code>upgrade</code> 将选择当前版本。</li>
<li>字符串 <code>patch</code>，它选择与当前所需版本相同的主版本号和次版本号的最新可用版本。如果当前没有需要的版本，<code>patch</code>相当于<code>latest</code>。从Go 1.16开始，<a href="#go-get">go get</a>在使用<code>patch</code>时要求有当前版本（但<code>-u=patch</code>标志没有这个要求）。</li>
</ul>
<p>​	除了对特定命名的版本或修订版的查询外，所有的查询都考虑由<code>go list -m -versions</code>（见<a href="#go-list-m">go list -m</a>）报告的可用版本。这个列表只包含带标签的版本，不包含伪版本。不考虑主模块的 <code>go.mod</code> 文件中的<a href="../gomodFiles#exclude-directive">exclude 指令</a>所禁止的模块版本 。除了在<code>go list -m</code>中使用<code>-retracted</code>标志以及在加载<code>retract</code>指令时，<code>go.mod</code>文件中的<code>retract</code>指令所涵盖的版本也会被忽略。同一模块的<code>latest</code>版本的<code>go.mod</code>文件中的<a href="../gomodFiles#retract-directive">retract 指令</a>覆盖的版本也会被忽略，除非<code>-retract</code>标志与<code>go list -m </code>一起使用，以及加载<code>retract</code>指令时除外。</p>
<p>​	<a href="../Glossary#release-version">发布版本</a>优先于预发布版本。例如，如果有<code>v1.2.2</code>和<code>v1.2.3-pre</code>两个版本，<code>latest</code>的查询会选择<code>v1.2.2</code>，尽管<code>v1.2.3-pre</code>的版本更高。<code>&lt;v1.2.4</code>的查询也会选择<code>v1.2.2</code>，即使<code>v1.2.3-pre</code>更接近<code>v1.2.4</code>。如果没有发行版或预发行版，<code>latest</code>、<code>upgrade</code>和<code>patch</code>查询将选择存储库默认分支顶端的提交的伪版本。其他查询将报告错误。</p>
<h3 id="module-commands-outside-a-module-模块外的模块命令">Module commands outside a module 模块外的模块命令</h3>
<p>​	模块感知的 <code>go</code> 命令通常在工作目录或父目录下的 <code>go.mod</code> 文件所定义的<a href="../Glossary#main-module">main module（主模块）</a>上下文中运行。有些命令可以在没有<code>go.mod</code>文件的情况下以模块感知模式运行，但大多数命令工作方式不同，或者在没有 <code>go.mod</code> 文件时报告错误。</p>
<p>​	关于启用和禁用模块感知模式的信息，请参见<a href="#module-aware-commands">模块感知命令</a>。</p>
<p><code>go build</code> 、<code>go doc</code> 、<code>go fix</code>、 <code>go fmt</code> 、<code>go generate</code>、 <code>go install</code>、 <code>go list</code> 、<code>go run</code>、 <code>go test</code> 、<code>go vet</code>：只有标准库中的包和在命令行上指定为<code>.go</code>文件的包才能被加载、导入和构建。来自其他模块的包不能被构建，因为没有地方可以记录模块需求并确保确定性的构建。</p>
<p><code>go get</code>：包和可执行文件可以像往常一样被构建和安装。注意，当<code>go get</code>在没有<code>go.mod</code>文件的情况下运行时，没有主模块，所以<code>replace</code>和<code>exclude</code>指令不被应用。</p>
<p><code>go list -m</code>：大多数参数都需要显式的<a href="#version-queries">版本查询</a>，除非使用 <code>-versions</code> 标志。</p>
<p><code>go mod download</code>：大多数参数都需要显式的<a href="#version-queries">版本查询</a>。</p>
<p><code>go mod edit</code>：需要一个显式的文件参数。</p>
<p><code>go mod graph</code> 、<code>go mod tidy</code>、 <code>go mod vendor</code> 、<code>go mod verify</code> 、<code>go mod why</code>：这些命令需要一个<code>go.mod</code>文件，如果没有这个文件，将报告错误。</p>
<h3 id="go-work-init">go work init</h3>
<p>使用方法：</p>
<pre tabindex="0"><code>go work init [moddirs]
</code></pre><p>​	<code>init</code>在当前目录下初始化并写入一个新的<code>go.work</code>文件，实际上是在当前目录下创建一个新的工作区。</p>
<p>​	<code>go work init</code>可以选择接受工作区模块的路径作为参数。如果省略该参数，将创建一个没有模块的空工作区。</p>
<p>​	每个参数路径都被添加到<code>go.work</code>文件中的<code>use</code> 指令中。当前的<code>go</code>版本也将在<code>go.work</code>文件中列出。</p>
<h3 id="go-work-edit">go work edit</h3>
<p>使用方法：</p>
<pre tabindex="0"><code>go work edit [editing flags] [go.work]
</code></pre><p>​	<code>go work edit</code> 命令为编辑 <code>go.work</code> 提供了一个命令行界面，主要供工具或脚本使用。它只读取<code>go.work</code>，并不查询相关模块的信息。如果没有指定文件，<code>edit</code> 会在当前目录及其父目录中寻找一个<code>go.work</code>文件。</p>
<p>​	编辑标志指定了一系列的编辑操作。</p>
<ul>
<li><code>-fmt</code>标志对<code>go.work</code>文件进行重新格式化，而不做其他修改。使用或重写 <code>go.work</code> 文件的任何其他修改也暗示了这种重新格式化。只有在没有指定其他标志的情况下才需要这个标志，如 &ldquo;<code>go work edit -fmt</code>&quot;。</li>
<li><code>-use=path</code> 和 <code>-dropuse=path</code> 标志从 <code>go.work</code> 文件的模块目录组中添加和移除<code>use</code>指令。</li>
<li><code>-replace=old[@v]=new[@v]</code> 标志添加对给定模块路径和版本的替换。如果省略<code>old@v</code>中的<code>@v</code>，就会添加一个左侧没有版本的替换，这适用于旧模块路径的所有版本。如果<code>new@v</code>中的<code>@v</code>被省略，新路径应该是本地模块根目录，而不是模块路径。注意，<code>-replace</code> 会覆盖<code>old[@v]</code>的任何冗余替，因此省略<code>@v</code>将移除特定版本的现有替换。</li>
<li><code>-dropreplace=old[@v]</code>标志会移除对给定模块路径和版本的替换。如果省略<code>@v</code>，左侧没有版本的替换会被移除。</li>
<li><code>-go=version</code> 标志设置预期的 Go 语言版本。</li>
</ul>
<p>​	编辑标志可以重复使用。更改会按照给定的顺序应用。</p>
<p>​	<code>go work edit</code>有额外的标志来控制其输出：</p>
<ul>
<li><code>-print</code>标志以文本格式打印最终的<code>go.work</code>，而不是将其写回<code>go.mod</code>。</li>
<li><code>-json</code>标志以JSON格式打印最终的<code>go.work</code>文件，而不是将其写回<code>go.mod</code>。JSON输出对应的是这些Go类型：</li>
</ul>
<pre tabindex="0"><code>type Module struct {
    Path    string
    Version string
}

type GoWork struct {
    Go        string
    Directory []Directory
    Replace   []Replace
}

type Use struct {
    Path       string
    ModulePath string
}

type Replace struct {
    Old Module
    New Module
}
</code></pre><h3 id="go-work-use">go work use</h3>
<p>使用方法：</p>
<pre tabindex="0"><code>go work use [-r] [moddirs]
</code></pre><p>​	<code>go work use</code>命令提供了一个向 <code>go.work</code> 文件添加目录(可选择递归)的命令行界面。</p>
<p>​	对于命令行<code>go.work</code>文件中列出的每个参数目录，如果其在磁盘上存在，将在<code>go.work</code>文件中添加一个<a href="../Workspaces#use-directive">use 指令</a>；如果其在磁盘上不存在，则从<code>go.work</code>文件中移除。</p>
<p>​	<code>-r</code>标志递归搜索参数目录中的模块，<code>use</code>命令的操作就像每个目录都被指定为参数一样：即，对于存在的目录将添加<code>use</code>指令，对于不存在的目录将移除<code>use</code>指令。</p>
<h3 id="go-work-sync">go work sync</h3>
<p>使用方法：</p>
<pre tabindex="0"><code>go work sync
</code></pre><p>​	<code>go work sync</code>命令将工作区的构建列表同步回工作区的模块。</p>
<p>​	工作区的构建列表是用于在工作区进行构建的所有（过渡性的）依赖模块的版本集合。<code>go work sync</code>使用<a href="../Glossary#minimal-version-selection">最小版本选择（MVS）</a>算法生成该构建列表，然后将这些版本同步到工作区指定的每个模块中（使用<code>use</code>指令）。</p>
<p>​	一旦计算出工作区的构建列表，工作区中每个模块的<code>go.mod</code>文件就会被重写，与该模块相关的依赖项被升级，以匹配工作区的构建列表。请注意，<a href="../Glossary#minimal-version-selection">最小版本选择（MVS）</a>保证构建列表中的每个模块的版本总是与工作区模块中的版本相同或更高。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-e75c5c33eb8f2925135889dd2765fa8d">9 - 模块代理</h1>
    
	<h2 id="module-proxies-模块代理">Module proxies 模块代理</h2>
<blockquote>
<p>原文：<a href="https://go.dev/ref/mod#module-proxy" target="_blank" rel="noopener">https://go.dev/ref/mod#module-proxy</a></p>
</blockquote>
<h3 id="goproxy-protocol">GOPROXY protocol</h3>
<p>​	模块代理是一个HTTP服务器，可以响应下面指定路径的<code>GET</code>请求。这些请求没有查询参数，也不需要特定的头，因此即使是一个从固定文件系统（包括<code>file://</code> URL）提供服务的网站也可以成为一个模块代理。</p>
<p>​	成功的HTTP响应必须有状态代码200 (OK)。遵循重定向(3xx)。状态码为4xx和5xx的响应被视为错误。错误码 404 (Not Found) 和410 (Gone)表示请求的模块或版本在代理上不可用，但可能在其他地方找到。错误响应的内容类型应该是<code>text/plain</code>，<code>charset</code>是<code>utf-8</code>或<code>us-ascii</code>。</p>
<p>​	<code>go</code>命令可以配置为使用<code>GOPROXY</code>环境变量联系代理或源码管理服务器，该环境变量接受一个代理URL列表。列表中可以包括关键词<code>direct</code>或<code>off</code>（详见<a href="">Environment variables（环境变量）</a>）。列表中的元素可以用逗号（<code>,</code>）或管道符（<code>|</code>）分隔，这决定了错误回退行为。当URL后跟一个逗号时，<code>go</code>命令只有在出现404 (Not Found)或410 (Gone) 响应后才会回退到后面的源。当URL后跟一个管道符时，<code>go</code>命令在任何错误（包括超时等非HTTP错误）发生后都会回退到后面的源。这种错误处理行为让代理充当未知模块的守门员。例如，对于不在批准列表上的模块，代理可以响应403 (Forbidden)错误（请参见 <a href="../PrivateModules#private-proxy-serving-private-modules">Private proxy serving private modules（为私有模块提供服务的私有代理）</a>）。</p>
<p>​	下表列出了模块代理必须响应的查询。对于每个路径，<code>$base</code>是代理URL的路径部分，<code>$module</code>是模块路径，<code>$version</code>是版本。例如，如果代理的URL是<code>https://example.com/mod</code>，并且客户端正在为 <code>v0.3.2</code>版本的模块 <code>golang.org/x/text</code> 请求 <code>go.mod</code> 文件，那么客户端将为<code>https://example.com/mod/golang.org/x/text/@v/v0.3.2.mod</code>发送一个<code>GET</code>请求。</p>
<p>​	为了避免从不区分大小写的文件系统中提供服务时出现歧义，<code>$module</code>和<code>$version</code>元素采用大小写编码，将每个大写字母替换为感叹号后跟相应的小写字母。这允许模块 <code>example.com/M</code> 和 <code>example.com/m</code> 同时存储在磁盘上，因为前者被编码为 <code>example.com/!m</code>。</p>
<table>
<thead>
<tr>
<th>Path 路径</th>
<th>Description 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="basemodulevlist"><code>$base/$module/@v/list</code></h4>
<p>​	以纯文本形式返回给定模块的已知版本列表，每行一个。该列表不应包括伪版本。</p>
<h4 id="basemodulevversioninfo"><code>$base/$module/@v/$version.info</code></h4>
<p>​	返回有关模块的特定版本的JSON格式的元数据。响应必须是与下面的GO数据结构体相对应的JSON对象：</p>
<div class="highlight"><div style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#55595f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#55595f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#55595f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#55595f">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#c678dd">type</span> <span style="color:#e06c75">Info</span> <span style="color:#c678dd">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e06c75">Version</span> <span style="color:#e5c07b">string</span>    <span style="color:#7f848e">// version string
</span></span></span><span style="display:flex;"><span><span style="color:#7f848e"></span>    <span style="color:#e06c75">Time</span>    <span style="color:#e06c75">time</span>.<span style="color:#e06c75">Time</span> <span style="color:#7f848e">// commit time
</span></span></span><span style="display:flex;"><span><span style="color:#7f848e"></span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>​	<code>Version</code>字段是必须的，并且必须包含一个有效的、<a href="../Glossary#canonical-version">canonical version（经典的版本）</a>（请参见<a href="../ModulesPackagesAndVersions#versions">Versions（版本）</a>）。请求路径中的<code>$version</code>不需要是相同的版本，甚至不需要是有效的版本；此端点可以用来查找分支名称或修订标识符的版本。但是，如果<code>$version</code>是一个经典的版本，其主版本与<code>$module</code>兼容，那么成功响应中的 <code>Version</code> 字段必须是相同的。</p>
<p>​	<code>Time</code>字段是可选的。如果存在，它必须是一个RFC 3339格式的字符串。它表示版本创建的时间。未来可能会增加更多的字段，因此保留其他的名字。</p>
<h4 id="basemodulevversionmod"><code>$base/$module/@v/$version.mod</code></h4>
<p>​	返回模块的特定版本的<code>go.mod</code>文件。如果该模块在请求的版本中没有<code>go.mod</code>文件，则必须返回一个仅包含请求模块路径的<code>module</code>语句的文件。否则，必须返回原始的、未经修改的<code>go.mod</code>文件。</p>
<h4 id="basemodulevversionzip"><code>$base/$module/@v/$version.zip</code></h4>
<p>​	返回包含模块特定版本内容的zip文件。有关此zip文件必须如何格式化的详细信息，请参阅<a href="../ModuleZipFiles">Module zip files（模块zip文件）</a>。</p>
<h4 id="basemodulelatest"><code>$base/$module/@latest</code></h4>
<p>​	以与<code>$base/$module/@v/$version.info</code>相同格式返回有关模块的最新已知版本的JSON格式元数据。如果<code>$base/$module/@v/list</code>为空或者列出的版本不合适，则最新版本应该是<code>go</code>命令应该使用的模块版本。此端点是可选的，模块代理不需要实现它。</p>
<p>​	在解析模块的最新版本时，<code>go</code>命令将请求<code>$base/$module/@v/list</code>，如果没有找到合适的版本，则请求<code>$base/$module/@latest</code>。<code>go</code>命令按顺序优先选择：语义上最高的发布版本，语义上最高的预发布版本，以及时间上最新的伪版本。在Go 1.12和更早的版本中，<code>go</code>命令认为<code>$base/$module/@v/list</code>中的伪版本是预发布版本，但从Go 1.13开始不再是这样了。</p>
<p>​	模块代理必须始终为<code>$base/$module/$version.mod</code>和<code>$base/$module/$version.zip</code>查询的成功响应提供相同的内容。该内容使用<code>go.sum</code> 文件进行<a href="../AuthenticatingModules">cryptographically authenticated（加密身份验证）</a>，默认情况下使用<a href="../AuthenticatingModules#checksum-database">checksum database（校验和数据库）</a>。</p>
<p>​	<code>go</code>命令将它从模块代理下载的大部分内容缓存在<code>$GOPATH/pkg/mod/cache/download</code>的模块缓存中。即使是直接从版本控制系统中下载，<code>go</code>命令也会合成显式的<code>info</code>、<code>mod</code>和<code>zip</code>文件，并将它们存储在此目录中，就像它直接从代理那里下载一样。缓存的布局与代理的URL空间相同，因此将<code>$GOPATH/pkg/mod/cache/download</code>服务于（或复制到）<code>https://example.com/proxy</code>，将可以让用户通过设置<code>GOPROXY</code>为<code>https://example.com/proxy</code>，来访问缓存的模块版本。</p>
<h3 id="communicating-with-proxies-与代理通信">Communicating with proxies 与代理通信</h3>
<p>​	<code>go</code>命令可以从<a href="../Glossary#module-proxy">module proxy（模块代理）</a>处下载模块的源代码和元数据。<code>GOPROXY</code>环境变量可以用来配置<code>go</code>命令可以连接哪些代理，以及它是否可以直接与<a href="../VersionControlSystems">version control systems（版本控制系统）</a>通信。下载的模块数据被保存在<a href="../Glossary#module-cache">module cache（模块缓存）</a>中。<code>go</code>命令只有在需要缓存中没有的信息时才会联系代理。</p>
<p>​	<a href="#goproxy-protocol">GOPROXY 协议</a>部分描述了可能被发送到<code>GOPROXY</code>服务器的请求。不过，了解<code>go</code>命令何时发出这些请求也很有帮助。例如，<code>go build</code>遵循以下步骤：</p>
<ul>
<li>通过读取<code>go.mod</code>文件并执行<a href="../MVS">最小版本选择（MVS）</a>来计算<a href="../Glossary#build-list">build list（构建列表）</a>。</li>
<li>读取命令行上命名的包和及其导入的包。</li>
<li>如果构建列表中的任何模块都没有提供某个包，则寻找提供该包的模块。将最新版本的模块需求添加到<code>go.mod</code>，然后重新开始（这些步骤）。</li>
<li>在加载完所有内容之后构建包。</li>
</ul>
<p>When the <code>go</code> command computes the build list, it loads the <code>go.mod</code> file for each module in the <a href="https://go.dev/ref/mod#glos-module-graph" target="_blank" rel="noopener">module graph</a>. If a <code>go.mod</code> file is not in the cache, the <code>go</code> command will download it from the proxy using a <code>$module/@v/$version.mod</code> request (where <code>$module</code> is the module path and <code>$version</code> is the version). These requests can be tested with a tool like <code>curl</code>. For example, the command below downloads the <code>go.mod</code> file for <code>golang.org/x/mod</code> at version <code>v0.2.0</code>:</p>
<p>​	当 <code>go</code> 命令计算构建列表时，它为<a href="../Glossary#module-graph">module graph（模块图）</a>中的每个模块加载 <code>go.mod</code> 文件。如果<code>go.mod</code>文件不在缓存中，<code>go</code>命令将使用<code>$module/@v/$version.mod</code>请求（其中<code>$module</code>是模块路径，<code>$version</code>是版本）从代理中下载它。这些请求可以用<code>curl</code>这样的工具来测试。例如，下面的命令下载版本为<code>v0.2.0</code>的<code>golang.org/x/mod</code>的<code>go.mod</code>文件。</p>
<div class="highlight"><div style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#55595f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#55595f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#55595f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#55595f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#55595f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#55595f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#55595f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#55595f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#55595f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#55595f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#55595f">11
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ curl https://proxy.golang.org/golang.org/x/mod/@v/v0.2.0.mod
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>module golang.org/x/mod
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>go 1.12
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>require <span style="color:#56b6c2">(</span>
</span></span><span style="display:flex;"><span>    golang.org/x/crypto v0.0.0-20191011191535-87dc89f01550
</span></span><span style="display:flex;"><span>    golang.org/x/tools v0.0.0-20191119224855-298f0cb1881e
</span></span><span style="display:flex;"><span>    golang.org/x/xerrors v0.0.0-20191011141410-1b5146add898
</span></span><span style="display:flex;"><span><span style="color:#56b6c2">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>​	为了加载包，<code>go</code>命令需要提供该包的模块的源代码。模块源代码以<code>.zip</code>文件的形式发布，这些文件被解压缩到模块缓存中。如果模块<code>.zip</code>不在缓存中，<code>go</code>命令将使用<code>$module/@v/$version.zip</code>请求下载它。</p>
<div class="highlight"><div style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#55595f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#55595f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#55595f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#55595f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#55595f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#55595f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#55595f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#55595f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#55595f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#55595f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#55595f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#55595f">12
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ curl -O https://proxy.golang.org/golang.org/x/mod/@v/v0.2.0.zip
</span></span><span style="display:flex;"><span>$ unzip -l v0.2.0.zip | head
</span></span><span style="display:flex;"><span>Archive:  v0.2.0.zip
</span></span><span style="display:flex;"><span>  Length      Date    Time    Name
</span></span><span style="display:flex;"><span>---------  ---------- -----   ----
</span></span><span style="display:flex;"><span>     <span style="color:#d19a66">1479</span>  00-00-1980 00:00   golang.org/x/mod@v0.2.0/LICENSE
</span></span><span style="display:flex;"><span>     <span style="color:#d19a66">1303</span>  00-00-1980 00:00   golang.org/x/mod@v0.2.0/PATENTS
</span></span><span style="display:flex;"><span>      <span style="color:#d19a66">559</span>  00-00-1980 00:00   golang.org/x/mod@v0.2.0/README
</span></span><span style="display:flex;"><span>       <span style="color:#d19a66">21</span>  00-00-1980 00:00   golang.org/x/mod@v0.2.0/codereview.cfg
</span></span><span style="display:flex;"><span>      <span style="color:#d19a66">214</span>  00-00-1980 00:00   golang.org/x/mod@v0.2.0/go.mod
</span></span><span style="display:flex;"><span>     <span style="color:#d19a66">1476</span>  00-00-1980 00:00   golang.org/x/mod@v0.2.0/go.sum
</span></span><span style="display:flex;"><span>     <span style="color:#d19a66">5224</span>  00-00-1980 00:00   golang.org/x/mod@v0.2.0/gosumcheck/main.go
</span></span></code></pre></td></tr></table>
</div>
</div><p>注意，<code>.mod</code>和<code>.zip</code>的请求是分开的，尽管<code>go.mod</code>文件通常包含在<code>.zip</code>文件中。<code>go</code>命令可能需要为许多不同的模块下载<code>go.mod</code>文件，而<code>.mod</code>文件要比<code>.zip</code>文件小得多。此外，如果一个Go项目没有<code>go.mod</code>文件，代理将提供一个仅包含<a href="../gomodFiles#module-directive">module 指令</a>的合成<code>go.mod</code>文件。合成的<code>go.mod</code>文件是由<code>go</code>命令从<a href="../VersionControlSystems">version control system（版本控制系统）</a>下载时生成的。</p>
<p>​	如果<code>go</code>命令需要加载一个构建列表中任何模块都没有提供的包，它将尝试查找一个提供该包的新模块。<a href="../ModulesPackagesAndVersions#resolving-a-package-to-a-module">Resolving a package to a module（将包解析为模块）</a>一节描述了这个过程。总之，<code>go</code>命令会请求每个可能包含该包的模块路径的最新版本信息。例如，对于包<code>golang.org/x/net/html</code>，<code>go</code>命令会试图查找<code>golang.org/x/net/html</code>、<code>golang.org/x/net</code>、<code>golang.org/x/</code>和<code>golang.org</code>等模块的最新版本。只有<code>golang.org/x/net</code>实际存在并提供该包，因此<code>go</code>命令使用该模块的最新版本。如果有多个模块提供该包，<code>go</code>命令将使用路径最长的模块。</p>
<p>​	当<code>go</code>命令请求某个模块的最新版本时，它首先发送一个<code>$module/@v/list</code>的请求。如果列表是空的或者没有一个返回的版本可以使用，它将发送对<code>$module/@latest</code>的请求。一旦选择了一个版本，<code>go</code>命令就会发送对<code>$module/@v/$version.info</code>的元数据请求。然后它可能会发送<code>$module/@v/$version.mod</code>和<code>$module/@v/$version.zip</code>请求来加载<code>go.mod</code>文件和源代码。</p>
<div class="highlight"><div style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#55595f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#55595f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#55595f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#55595f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#55595f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#55595f">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ curl https://proxy.golang.org/golang.org/x/mod/@v/list
</span></span><span style="display:flex;"><span>v0.1.0
</span></span><span style="display:flex;"><span>v0.2.0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ curl https://proxy.golang.org/golang.org/x/mod/@v/v0.2.0.info
</span></span><span style="display:flex;"><span><span style="color:#56b6c2">{</span><span style="color:#98c379">&#34;Version&#34;</span>:<span style="color:#98c379">&#34;v0.2.0&#34;</span>,<span style="color:#98c379">&#34;Time&#34;</span>:<span style="color:#98c379">&#34;2020-01-02T17:33:45Z&#34;</span><span style="color:#56b6c2">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>​	在下载一个<code>.mod</code>或<code>.zip</code>文件后，<code>go</code>命令会计算一个加密哈希值，并检查它是否与主模块的<code>go.sum</code>文件中的哈希值相匹配。如果哈希值不在<code>go.sum</code>中，默认情况下，<code>go</code>命令会从<a href="../AuthenticatingModules#checksum-database">checksum database（校验数据库）</a>中检索它。如果计算出的哈希值不匹配，<code>go</code>命令会报告一个安全错误，并且不会将该文件安装到模块缓存中。<code>GOPRIVATE</code>和<code>GONOSUMDB</code><a href="../EnvironmentVariables">环境变量</a>可以用来禁止对特定模块的校验数据库的请求。<code>GOSUMDB</code>环境变量也可以被设置为<code>off</code>，以完全禁止对校验数据库的请求。更多信息请参见<a href="../AuthenticatingModules">Authenticating modules（验证模块）</a>。请注意，为<code>.info</code>请求返回的版本列表和版本元数据不经过身份验证，并且可能会随着时间的推移而改变。</p>
<h3 id="serving-modules-directly-from-a-proxy-直接从代理向模块提供服务">Serving modules directly from a proxy 直接从代理向模块提供服务</h3>
<p>​	大多数模块都是从版本控制存储库中开发和提供的。在<a href="../Glossary#direct-mode">direct mode（直接模式）</a>下，<code>go</code>命令用版本控制工具下载这样的模块（见<a href="../VersionControlSystems">Version control systems（版本控制系统）</a>）。还可以直接从模块代理提供模块。这对那些希望在不暴露其版本控制服务器的情况下提供模块服务的组织以及使用<code>go</code>命令不支持的版本控制工具的组织来说非常有用。</p>
<p>​	当<code>go</code>命令以直接模式下载模块时，它首先根据模块路径用HTTP GET请求查找模块服务器的URL。它在HTML响应中查找一个名为<code>go-import</code>的<code>&lt;meta&gt;</code>标签。该标签的内容必须包含<a href="../Glossary#repository-root-path">repository root path（存储库根路径）</a>、版本控制系统和 URL，并以空格隔开。详见<a href="../VersionControlSystems#finding-a-repository-for-a-module-path">Finding a repository for a module path（查找模块路径的存储库）</a>。</p>
<p>​	如果版本控制系统是<code>mod</code>，<code>go</code>命令使用<a href="#goproxy-protocol">GOPROXY 协议</a>从给定的URL下载模块。</p>
<p>​	例如，假设<code>go</code>命令试图下载版本为<code>v1.0.0</code>的模块<code>example.com/gopher</code>。它向<code>https://example.com/gopher?go-get=1</code>发送请求。服务器使用包含以下标签的HTML文档进行响应：</p>
<div class="highlight"><div style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#55595f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-html" data-lang="html"><span style="display:flex;"><span>&lt;<span style="color:#e06c75">meta</span> <span style="color:#e06c75">name</span><span style="color:#56b6c2">=</span><span style="color:#98c379">&#34;go-import&#34;</span> <span style="color:#e06c75">content</span><span style="color:#56b6c2">=</span><span style="color:#98c379">&#34;example.com/gopher mod https://modproxy.example.com&#34;</span>&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><p>​	根据这个响应，<code>go</code>命令通过发送<code>https://modproxy.example.com/example.com/gopher/@v/v1.0.0.info</code>、<code>v1.0.0.mod</code>和<code>v1.0.0.zip</code>的请求来下载该模块。</p>
<p>!!! warining &ldquo;请注意&rdquo;</p>
<pre><code>注意，在`GOPATH`模式下，不能用`go get`下载从代理处直接提供的模块。</code></pre>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-5b15e9e426fb8d044d2c0cbf6caefb23">10 - 版本控制系统</h1>
    
	<h2 id="version-control-systems-版本控制系统">Version control systems 版本控制系统</h2>
<blockquote>
<p>原文：<a href="https://go.dev/ref/mod#vcs" target="_blank" rel="noopener">https://go.dev/ref/mod#vcs</a></p>
</blockquote>
<p>​	<code>go</code>命令可以直接从版本控制储存库中下载模块的源代码和元数据。从<a href="../ModuleProxies#communicating-with-proxies">proxy（代理）</a>下载模块通常更快，但如果代理不可用，或者代理无法访问模块的存储库（对于私有存储库经常如此），则需要直接连接到存储库。支持<code>Git</code>、<code>Subversion</code>、<code>Mercurial</code>、<code>Bazaar</code>和<code>Fossil</code>。版本控制工具必须安装在<code>PATH</code>的一个目录中，以便<code>go</code>命令使用它。</p>
<p>​	要从源码库而不是代理下载特定的模块，可以设置<code>GOPRIVATE</code>或<code>GONOPROXY</code>环境变量。要配置<code>go</code>命令直接从源码库下载所有模块，请将<code>GOPROXY</code>设置为<code>direct</code>。更多信息请参见<a href="../EnvironmentVariables">Environment variables（环境变量）</a>。</p>
<h3 id="finding-a-repository-for-a-module-path-查找模块路径的存储库">Finding a repository for a module path 查找模块路径的存储库</h3>
<p>​	当<code>go</code>命令以<code>direct</code>模式下载模块时，它首先要定位包含该模块的存储库。</p>
<p>​	如果模块路径的末尾有一个<code>VCS</code>限定词（<code>.bzr</code>， <code>.fossil</code>， <code>.git</code>， <code>.hg</code>， <code>.svn</code>中的一个），<code>go</code>命令将使用该路径限定词之前的所有内容作为存储库的URL。例如，对于模块<code>example.com/foo.git/bar</code>，<code>go</code>命令使用<code>git</code>下载<code>example.com/foo.git</code>的存储库，期望在<code>bar</code>子目录下找到该模块。<code>go</code>命令将根据版本控制工具支持的协议来猜测要使用的协议。</p>
<p>​	如果模块路径没有限定词，<code>go</code>命令会向模块路径派生的URL发送带有<code>?go-get=1</code>查询字符串的HTTP <code>GET</code>请求。例如，对于模块<code>golang.org/x/mod</code>，<code>go</code>命令可能发送以下请求：</p>
<pre tabindex="0"><code>https://golang.org/x/mod?go-get=1 (preferred)
http://golang.org/x/mod?go-get=1  (fallback, only with GOINSECURE)
</code></pre><p>​	<code>go</code>命令跟随重定向，但会忽略响应状态码，因此服务器可能会以404或任何其他错误状态来响应。<code>GOINSECURE</code>环境变量可以被设置为允许回退并重定向到特定模块的未加密的HTTP。</p>
<p>​	服务器必须使用一个HTML文档来响应，该文档的<code>&lt;head&gt;</code>中包含一个<code>&lt;meta&gt;</code>标签。<code>&lt;meta&gt;</code>标签应该出现在文档的早期，以避免混淆<code>go</code>命令的受限解析器。特别是，它应该出现在任何原始JavaScript或CSS之前。<code>&lt;meta&gt;</code>标签必须具有以下形式：</p>
<pre tabindex="0"><code>&lt;meta name=&#34;go-import&#34; content=&#34;root-path vcs repo-url&#34;&gt;
</code></pre><p>​	<code>root-path</code> 是存储库的根路径，即模块路径中与存储库根目录相对应的部分。它必须是一个前缀或与请求的模块路径完全匹配。如果不是完全匹配，则会对前缀进行另一次请求，以验证<code>&lt;meta&gt;</code>标签是否匹配。</p>
<p>​	<code>vcs</code>是版本控制系统。它必须是下表中所列的工具之一，或者是关键字<code>mod</code>，它指示<code>go</code>命令使用<a href="#goproxy-protocol">GOPROXY 协议</a>从给定的URL下载模块。有关详细信息，请参阅 <a href="#serving-modules-directly-from-a-proxy">直接从代理向模块提供服务</a>。</p>
<p>​	<code>repo-url</code>是存储库的URL。如果URL不包含方案（要么是因为模块路径有一个<code>VCS</code>限定符，要么是因为<code>&lt;meta&gt;</code>标签缺少一个方案），<code>go</code>命令将尝试版本控制系统支持的每一个协议。例如，对于 <code>Git</code>，<code>go</code> 命令将尝试 <code>https://</code> 然后是 <code>git+ssh://</code>。不安全的协议（如 <code>http://</code> 和 <code>git://</code>）只有在模块路径被 <code>GOINSECURE</code> 环境变量匹配的情况下才能使用。</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Command</th>
<th>GOVCS default</th>
<th>Secure schemes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bazaar</td>
<td><code>bzr</code></td>
<td>Private only</td>
<td><code>https</code>， <code>bzr+ssh</code></td>
</tr>
<tr>
<td>Fossil</td>
<td><code>fossil</code></td>
<td>Private only</td>
<td><code>https</code></td>
</tr>
<tr>
<td>Git</td>
<td><code>git</code></td>
<td>Public and private</td>
<td><code>https</code>， <code>git+ssh</code>， <code>ssh</code></td>
</tr>
<tr>
<td>Mercurial</td>
<td><code>hg</code></td>
<td>Public and private</td>
<td><code>https</code>， <code>ssh</code></td>
</tr>
<tr>
<td>Subversion</td>
<td><code>svn</code></td>
<td>Private only</td>
<td><code>https</code>， <code>svn+ssh</code></td>
</tr>
</tbody>
</table>
<p>​	作为一个例子，再次考虑<code>golang.org/x/mod</code>。<code>go</code>命令向<code>https://golang.org/x/mod?go-get=1</code> 发送一个请求。服务器响应的是一个包含标签的HTML文档：</p>
<pre tabindex="0"><code>&lt;meta name=&#34;go-import&#34; content=&#34;golang.org/x/mod git https://go.googlesource.com/mod&#34;&gt;
</code></pre><p>​	从这个响应来看，<code>go</code> 命令将使用远程 URL <code>https://go.googlesource.com/mod</code> 的 <code>Git</code> 存储库。</p>
<p>​	<code>GitHub</code> 和其他流行的托管服务会响应所有存储库的 <code>?go-get=1</code> 查询，所以通常在这些站点托管的模块不需要进行服务器配置。</p>
<p>​	找到存储库的URL后，<code>go</code>命令会将存储库克隆到模块缓存中。一般来说，<code>go</code>命令尝试避免从存储库中获取不需要的数据。但是，实际使用的命令因版本控制系统而异，并可能随时间而改变。对于 <code>Git</code> 来说，<code>go</code> 命令可以在不下载提交的情况下列出大多数可用的版本。它通常会在不下载祖先提交的情况下获取提交，但这样做有时是必要的。</p>
<h3 id="mapping-versions-to-commits-将版本映射到提交">Mapping versions to commits 将版本映射到提交</h3>
<p><code>go</code> 命令可以检出存储库中特定<a href="../Glossary#canonical-version">canonical version（经典版本）</a>的模块，比如 <code>v1.2.3</code>, <code>v2.4.0-beta</code>, 或者 <code>v3.0.0+incompatible</code>。每个模块版本在存储库中都应该有一个语义上的版本标签，表明哪个版本应该被检出。</p>
<p>​	如果在存储库根目录或根目录的主版本子目录中定义了模块，则每个版本标签名都等于相应的版本。例如，模块 <code>golang.org/x/text</code> 被定义在其存储库的根目录中，因此版本 <code>v0.3.2</code> 在该存储库中的标签为 <code>v0.3.2</code>。这对大多数模块来说都是如此。</p>
<p>​	如果模块被定义在存储库的子目录中，也就是说，模块路径中的<a href="../Glossary#module-subdirectory">module subdirectory（模块子目录）</a>部分不是空的，那么每个标签名必须以模块子目录为前缀，后跟斜线。例如，模块<code>golang.org/x/tools/gopls</code>被定义在根路径为<code>golang.org/x/tools</code>的存储库的<code>gopls</code>子目录中。该模块的<code>v0.4.0</code>版本必须在该存储库中具有名为<code>gopls/v0.4.0</code>的标签。</p>
<p>​	语义版本标签的主版本号必须与模块路径的主版本后缀（如果有的话）一致。例如，标签<code>v1.0.0</code>可能属于模块<code>example.com/mod</code>，但不属于<code>example.com/mod/v2</code>，后者会有<code>v2.0.0</code>这样的标签。</p>
<p>​	如果没有<code>go.mod</code>文件，并且模块在存储库根目录中，那么主版本为<code>v2</code>或更高的标签可能属于没有主版本后缀的模块。这种版本用后缀<code>+incompatible</code>来表示。版本标签本身不能有这个后缀。参见<a href="../CompatibilityWithNon-moduleRepositories">Compatibility with non-module repositories（与非模块存储库的兼容性）</a>。</p>
<p>​	一旦标签被创建，它就不应该被删除或改变为不同的版本。版本经过<a href="../AuthenticatingModules">身份验证</a>，以确保安全、可重复的构建。如果标签被修改，客户端在下载时可能会看到安全错误。即使标签被删除，其内容仍可在<a href="../Glossary#module-proxy">module proxies（模块代理）</a>上使用。</p>
<h3 id="mapping-pseudo-versions-to-commits-将伪版本映射到提交">Mapping pseudo-versions to commits 将伪版本映射到提交</h3>
<p>​	<code>go</code>命令可以在存储库中检出特定修订版的模块，该修订版编码为<a href="../Glossary#pseudo-version">pseudo-version（伪版本）</a>，如<code>v1.3.2-0.20191109021931-daa7c04131f5</code>。</p>
<p>​	伪版本的最后12个字符（上例中的<code>daa7c04131f5</code>）表示要检出存储库中的一个修订版。它的含义取决于版本控制系统。对于<code>Git</code>和<code>Mercurial</code>，这是一个提交哈希值的前缀。对于<code>Subversion</code>，这是一个以零填充的修订号。</p>
<p>​	在检出一个提交之前，<code>go</code> 命令会验证时间戳（上面的 <code>20191109021931</code>）是否与提交日期相符。它还会验证基本版本（<code>v1.3.1</code>，即上例中<code>v1.3.2</code>之前的版本）是否与提交的祖先的语义版本标签相对应。这些检查确保模块作者能够完全控制伪版本与其他发布版本的比较。</p>
<p>​	更多信息请参见<a href="../ModulesPackagesAndVersions#pseudo-versions">Pseudo-versions（伪版本）</a>。</p>
<h3 id="mapping-branches-and-commits-to-versions-将分支和提交映射到版本">Mapping branches and commits to versions 将分支和提交映射到版本</h3>
<p>​	可以使用<a href="../Module-awareCommands#version-queries">version query（版本查询）</a>在特定分支、标签或修订版检出模块。</p>
<div class="highlight"><div style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#55595f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>go get example.com/mod@master
</span></span></code></pre></td></tr></table>
</div>
</div><p>​	<code>go</code> 命令将这些名称转换为可用于<a href="../MVS">最小版本选择（MVS）</a>的<a href="../Glossary#canonical-version">canonical versions（经典版本）</a>。MVS 依赖于对版本进行明确排序的能力。分支名称和修订版不能随着时间的推移可靠地进行比较，因为它们依赖于可能会更改的存储库结构。</p>
<p>​	如果一个修订版被标记了一个或多个语义版本标签，如<code>v1.2.3</code>，那么将使用最高有效版本的标签。<code>go</code>命令只考虑可能属于目标模块的语义版本标签；例如，对于<code>example.com/mod/v2</code>来说，<code>v1.5.2</code>标签不会被考虑，因为其主版本与模块路径的后缀不匹配。</p>
<p>​	如果一个修订版没有被贴上有效的语义版本标签，<code>go</code>命令将生成一个伪版本。如果修订版具有具有有效语义版本标签的祖先版本，那么最高的祖先版本将被用作伪版本基础。请参阅<a href="../ModulesPackagesAndVersions#pseudo-versions">Pseudo-versions（伪版本）</a>。</p>
<h3 id="module-directories-within-a-repository-存储库中的模块目录">Module directories within a repository 存储库中的模块目录</h3>
<p>​	一旦模块的存储库在特定的修订版中被检出，<code>go</code>命令必须找到包含该模块的<code>go.mod</code>文件的目录（模块的根目录）。</p>
<p>​	回顾一下，<a href="../ModulesPackagesAndVersions#module-paths">module path（模块路径）</a>由三部分组成：存储库根路径（对应于存储库根目录）、模块子目录和主版本后缀（仅适用于以<code>v2</code>或更高版本发布的模块）。</p>
<p>​	对于大多数模块，模块路径等于存储库根路径，因此模块的根目录就是存储库的根目录。</p>
<p>​	模块有时会被定义在存储库的子目录下。这通常适用于具有多个组件的大型存储库，这些组件需要独立发布和版本化。这样的模块有望在子目录中找到，该目录与存储库根目录之后的模块路径部分相匹配。例如，假设模块 <code>example.com/monorepo/foo/bar</code> 位于根路径为 <code>example.com/monorepo</code>的存储库的中。它的<code>go.mod</code>文件必须位于<code>foo/bar</code>子目录中。</p>
<p>​	如果模块在主版本<code>v2</code>或更高版本发布，则其路径必须有一个<a href="../ModulesPackagesAndVersions#major-version-suffixes">major version suffix（主版本后缀）</a>。带有主版本后缀的模块可以定义在两个子目录中的一个：一个带有后缀，另一个没有。例如，假设上面模块的一个新版本以<code>example.com/monorepo/foo/bar/v2</code>的路径发布。其<code>go.mod</code>文件可能位于<code>foo/bar</code>或<code>foo/bar/v2</code>中。</p>
<p>​	带有主版本后缀的子目录是主版本的子目录。它们可用于在单个分支上开发模块的多个主版本。当在不同的分支上进行多个主要版本的开发时，这可能是不必要的。然而，主版本的子目录有一个重要的特性：在<code>GOPATH</code>模式下，包的导入路径与<code>GOPATH/src</code>下的目录完全匹配。<code>go</code>命令在<code>GOPATH</code>模式下提供了最低限度的模块兼容性（参见<a href="../CompatibilityWithNon-moduleRepositories">Compatibility with non-module repositories（与非模块存储库的兼容性）</a>），因此主版本子目录对于与<code>GOPATH</code>模式下构建的项目的兼容性来说并不总是必要的。不过不支持最低限度的模块兼容性的旧工具可能会有问题。</p>
<p>​	一旦<code>go</code>命令找到了模块根目录，它就会创建该目录内容的<code>.zip</code>文件，然后将该<code>.zip</code>文件解压缩到模块缓存中。关于<code>.zip</code>文件中可以包含哪些文件的细节，请参见<a href="../ModuleZipFiles#file-path-and-size-constraints">File path and size constraints（文件路径和大小限制）</a>。<code>.zip</code>文件的内容在提取到模块缓存之前是经过<a href="../AuthenticatingModules">验证</a>的，就像从代理下载<code>.zip</code>文件一样。</p>
<p>​	模块压缩文件不包括<code>vendor</code>目录的内容或任何嵌套模块（包含<code>go.mod</code>文件的子目录）。这意味着模块必须注意不要引用其目录外或其他模块中的文件。例如，<a href="https://pkg.go.dev/embed#hdr-Directives" target="_blank" rel="noopener">//go:embed</a>模式不能匹配嵌套模块中的文件。在文件不应包含在模块中的情况下，这种行为可以作为一种有用的变通方法。例如，如果存储库有大文件被检入<code>testdata</code>目录中，模块作者可以在<code>testdata</code>中添加一个空的<code>go.mod</code>文件，这样他们的用户就不需要下载这些文件。当然，这可能会减少用户测试其依赖项的覆盖率。</p>
<h3 id="special-case-for-license-files---许可证文件的特殊情况">Special case for LICENSE files - 许可证文件的特殊情况</h3>
<p>​	当<code>go</code>命令为不在存储库根目录下的模块创建<code>.zip</code>文件时，如果该模块的根目录（与<code>go.mod</code>并列）中没有名为<code>LICENSE</code>的文件，那么<code>go</code>命令将从存储库根目录下复制名为<code>LICENSE</code>的文件（如果该文件存在于同一修订版中）。</p>
<p>​	这种特殊情况允许相同的 <code>LICENSE</code> 文件应用于存储库中的所有模块。这仅适用于专门命名为 <code>LICENSE</code> 的文件，而没有像 <code>.txt</code> 这样的扩展名。遗憾的是，在不破坏现有模块的加密和的情况下，无法对其进行扩展；请参见<a href="../AuthenticatingModules">Authenticating modules（认证模块）</a>。其他工具和网站如 <code>pkg.go.dev</code> 可能会识别其他名称的文件。</p>
<p>​	还请注意，在创建模块<code>.zip</code>文件时，<code>go</code>命令不包括符号链接；请参见<a href="../ModuleZipFiles#file-path-and-size-constraints">File path and size constraints（文件路径和大小限制）</a>。因此，如果存储库的根目录中没有<code>LICENSE</code>文件，作者可以在子目录中定义的模块中创建许可证文件的副本，以确保这些文件包含在模块<code>.zip</code>文件中。</p>
<h3 id="controlling-version-control-tools-with-govcs---使用govcs控制版本控制工具">Controlling version control tools with GOVCS - 使用GOVCS控制版本控制工具</h3>
<p>​	<code>go</code>命令能够使用<code>git</code>等版本控制命令下载模块，这对于去中心化的包生态系统至关重要，在这个系统中，代码可以从任何服务器导入。如果恶意服务器找到方法使调用的版本控制命令运行非预期的代码，这也是一个潜在的安全问题。</p>
<p>​	为了平衡功能和安全问题，<code>go</code>命令默认只使用<code>git</code>和<code>hg</code>从公共服务器下载代码。它将使用任何<a href="#finding-a-repository-for-a-module-path">已知的版本控制系统</a>从私有服务器下载代码，私有服务器定义为那些托管与<code>GOPRIVATE</code><a href="../EnvironmentVariables">环境变量</a>匹配的包的服务器。之所以只允许使用<code>Git</code>和<code>Mercurial</code>，是因为这两个系统最关注作为不可信服务器的客户端运行的问题。相比之下，<code>Bazaar</code>、<code>Fossil</code>和<code>Subversion</code>主要用于可信的、经过验证的环境中，并没有被作为攻击面那样受到仔细检查。</p>
<p>​	版本控制命令的限制仅适用于使用直接版本控制访问下载代码的情况。当从代理下载模块时，<code>go</code>命令改用<a href="../ModuleProxies#goproxy-protocol">GOPROXY 协议</a>，这是始终允许的。默认情况下，<code>go</code>命令使用Go模块镜像（<code>proxy.golang.org</code>）来下载公共模块，只有在私有模块或镜像拒绝为公共包提供服务（通常是出于法律原因）才会回退到版本控制。因此，客户端仍然可以默认访问从<code>Bazaar</code>、<code>Fossil</code>或<code>Subversion</code>存储库提供的公共代码，因为这些下载使用Go模块镜像，它承担了使用自定义沙箱运行版本控制命令的安全风险。</p>
<p>​	<code>GOVCS</code>变量可以用来更改特定模块所允许的版本控制系统。<code>GOVCS</code>变量适用于在模块感知模式和<code>GOPATH</code>模式下构建包。当使用模块时，模式与模块路径匹配。当使用 <code>GOPATH</code> 时，模式与版本控制库根目录对应的导入路径相匹配。</p>
<p>​	<code>GOVCS</code>变量的一般形式是一个用逗号分隔的<code>pattern:vcslist</code>规则的列表。<code>pattern</code> 是一个<a href="https://go.dev/pkg/path#Match" target="_blank" rel="noopener">glob pattern</a>，必须与模块或导入路径的一个或多个前导元素相匹配。<code>vcslist</code>是一个管道分隔的允许使用的版本控制命令的列表，或<code>all</code>允许使用任何已知的命令，或<code>off</code>不允许使用。请注意，如果模块与<code>vcslist</code> <code>off</code>时的模式相匹配，如果原服务器使用<code>mod</code>方案，该模块仍然可以被下载，该方案指示<code>go</code>命令使用<a href="../ModuleProxies#goproxy-protocol">GOPROXY 协议</a>下载该模块。 应用列表中最早的匹配模式，即使后面的模式也可能匹配。</p>
<p>​	例如，请考虑：</p>
<pre tabindex="0"><code>GOVCS=github.com:git,evil.com:off,*:git|hg
</code></pre><p>​	在此设置下，模块或导入路径以<code>github.com/</code>开头的代码只能使用<code>git</code>；<code>evil.com</code>上的路径不能使用任何版本控制命令，而所有其他路径（<code>*</code>匹配所有）只能使用<code>git</code>或<code>hg</code>。</p>
<p>​	特殊模式<code>public</code>和<code>private</code>匹配公共和私人模块或导入路径。如果路径与<code>GOPRIVATE</code>变量相匹配，那么它就是私有路径；否则就是公共路径。</p>
<p>​	如果<code>GOVCS</code>变量中没有规则与某个特定的模块或导入路径相匹配，<code>go</code>命令会应用其默认规则，该规则现在可以用<code>GOVCS</code>标记法概括为<code>public:git|hg</code>，<code>private:all</code>。</p>
<p>​	要允许对任何包不受限制地使用任何版本控制系统，请使用：</p>
<pre tabindex="0"><code>GOVCS=*:all
</code></pre><p>​	要禁用所有版本控制的使用，使用：</p>
<pre tabindex="0"><code>GOVCS=*:off
</code></pre><p>​	<a href="../../CommandDocumentation/go#print-go-environment-information">go env -w 命令</a>可以用来设置 <code>GOVCS</code> 变量，以便今后调用 <code>go</code> 命令。</p>
<p>​	<code>GOVCS</code> 是在 Go 1.16 中引入的。早期版本的Go可以对任何模块使用任何已知的版本控制工具。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-ce178d2d9de1acb9e30aaf12fe74171a">11 - 模块zip文件</h1>
    
	<h2 id="module-zip-files-模块zip文件">Module zip files 模块zip文件</h2>
<blockquote>
<p>原文：<a href="https://go.dev/ref/mod#zip-files" target="_blank" rel="noopener">https://go.dev/ref/mod#zip-files</a></p>
</blockquote>
<p>​	模块版本是以<code>.zip</code>文件的形式发布的。很少有必要直接与这些文件互动，因为<code>go</code>命令会自动从<a href="../Glossary#module-proxy">module proxies（模块代理）</a>和版本控制库中创建、下载和提取这些文件。但是，了解这些文件对了解跨平台的兼容性约束或在实现模块代理时仍然很有用。</p>
<p>​	<a href="../gomodFiles#go-mod-download">go mod download</a>命令下载一个或多个模块的zip文件，然后将这些文件提取到模块缓存中。根据<code>GOPROXY</code>和其他<a href="../EnvironmentVariables">环境变量</a>，<code>go</code>命令可以从代理下载zip文件，或者克隆源码管理存储库并从中创建zip文件。<code>-json</code>标志可以用来查找下载的 zip文件及其在模块缓存中提取的内容的位置。</p>
<p>​	<a href="https://pkg.go.dev/golang.org/x/mod/zip?tab=doc" target="_blank" rel="noopener">golang.org/x/mod/zip</a>包可以用来以编程方式创建、提取或检查压缩文件的内容。</p>
<h3 id="file-path-and-size-constraints-文件路径和大小约束">File path and size constraints 文件路径和大小约束</h3>
<p>​	对模块zip文件的内容有一些限制。这些限制确保zip文件可以在各种平台上安全和一致地被提取。</p>
<ul>
<li>
<p>模块 zip文件最多可以有500 MiB的大小。<code>go.mod</code>文件被限制在16 MB以内。<code>LICENSE</code>文件也被限制在16 MB以内。这些限制的存在是为了减轻对用户、代理和模块生态系统的其他部分的拒绝服务攻击。在模块目录树中包含超过500 MiB的文件的存储库应该在提交时标记模块版本，只包括构建模块包所需的文件；视频、模型和其他大型资产通常不需要构建。</p>
</li>
<li>
<p>模块zip文件中的每个文件必须以前缀<code>$module@$version/</code>开始，其中<code>$module</code>是模块路径，<code>$version</code>是版本，例如<code>golang.org/x/mod@v0.3.0/</code>。模块路径必须是有效的，版本必须是有效的和经典的，并且版本必须与模块路径的主版本后缀匹配。具体定义和限制，请参见<a href="../gomodFiles#module-paths-and-versions">Module paths and versions（模块路径和版本）</a>。</p>
</li>
<li>
<p>文件模式、时间戳和其他元数据被忽略。</p>
</li>
<li>
<p>空目录（路径以斜线结尾的条目）可能包含在模块zip文件中，但不会被提取。<code>go</code>命令在它创建的压缩文件中不包括空目录。</p>
</li>
<li>
<p>符号链接和其他不规则的文件在创建zip文件时被忽略，因为它们在不同的操作系统和文件系统中是不可移植的，也没有可移植的方法在zip文件格式中表示它们。</p>
</li>
<li>
<p>在创建zip文件时，名为<code>vendor</code>的目录内的文件被忽略，因为主模块外的<code>vendor</code>目录从不被使用。</p>
</li>
<li>
<p>在创建zip文件时，包含<code>go.mod</code>文件的目录中的文件(模块根目录除外)将被忽略，因为它们不是模块的一部分。<code>go</code>命令在提取文件时忽略了包含<code>go.mod</code>文件的子目录。</p>
</li>
<li>
<p>在Unicode大小写折叠下，zip文件中的任何两个文件的路径都不可能相等（见<a href="https://pkg.go.dev/strings?tab=doc#EqualFold" target="_blank" rel="noopener">strings.EqualFold</a>）。这保证了在不区分大小写的文件系统中提取文件时不会出现冲突。</p>
</li>
<li>
<p><code>go.mod</code>文件可能出现在顶层目录（<code>$module@$version/go.mod</code>）中，也可能不出现。如果出现，它的名字必须是<code>go.mod</code>（全小写）。名为<code>go.mod</code>的文件不允许出现在任何其他目录中。</p>
</li>
<li>
<p>模块中的文件和目录名可以由Unicode字母、ASCII数字、ASCII空格字符（U+0020）和ASCII标点字符<code>!#$%&amp;()+,-.=@[]^_{}~</code>组成。注意，包的路径可能不包含所有这些字符。参见<a href="https://pkg.go.dev/golang.org/x/mod/module?tab=doc#CheckFilePath" target="_blank" rel="noopener">module.CheckFilePath</a>和<a href="https://pkg.go.dev/golang.org/x/mod/module?tab=doc#CheckImportPath" target="_blank" rel="noopener">module.CheckImportPath</a>的区别。</p>
</li>
<li>
<p>在Windows上，第一个点之前的文件或目录名不能是保留文件名，无论大小写(<code>CON</code>、<code>com1</code>、<code>NuL</code>等)。</p>
</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-0506cdbac677dc7d8ce10022df8bac37">12 - 私有模块</h1>
    
	<h2 id="private-modules-私有模块">Private modules 私有模块</h2>
<blockquote>
<p>原文：<a href="https://go.dev/ref/mod#private-modules" target="_blank" rel="noopener">https://go.dev/ref/mod#private-modules</a></p>
</blockquote>
<p>​	Go模块经常是在版本控制服务器和模块代理上开发和发布的，这些模块在公共互联网上是不可用的。<code>go</code> 命令可以从私有资源中下载和构建模块，不过通常需要一些配置。</p>
<p>​	下面的环境变量可以用来配置对私有模块的访问。详情请参见<a href="../EnvironmentVariables">Environment variables（环境变量）</a>。有关控制发送到公共服务器的信息的信息，也请参见<a href="#privacy">Privacy（隐私）</a>。</p>
<ul>
<li><code>GOPROXY</code> —— 模块代理URL的列表。<code>go</code> 命令将尝试按顺序从每个服务器下载模块。关键字 <code>direct</code> 指示 <code>go</code> 命令从其开发的版本控制存储库中下载模块，而不是使用代理。</li>
<li><code>GOPRIVATE</code> —— 应该被视为私有的模块路径前缀的 glob 模式列表。作为 <code>GONOPROXY</code> 和 <code>GONOSUMDB</code> 的默认值。</li>
<li><code>GONOPROXY</code> —— 不应从代理下载的模块路径前缀的 glob 模式列表。<code>go</code> 命令将从开发模块的版本控制存储库中下载匹配的模块，而不考虑 <code>GOPROXY</code>。</li>
<li><code>GONOSUMDB</code> —— 不应使用公共校验和数据库 <a href="https://sum.golang.org/" target="_blank" rel="noopener">sum.golang.org</a> 进行检查的模块路径前缀的 glob 模式列表。</li>
<li><code>GOINSECURE</code> —— 可以通过HTTP和其他不安全协议检索的模块路径前缀的 glob 模式列表。</li>
</ul>
<p>​	这些变量可以在开发环境中设置（例如，在 <code>.profile</code> 文件中），也可以用 <a href="../../CommandDocumentation/go#print-go-environment-information">go env -w</a> 永久设置。</p>
<p>​	本节的其余部分描述了提供访问私有模块代理和版本控制存储库的常见模式。</p>
<h3 id="private-proxy-serving-all-modules-为所有模块提供服务的私有代理">Private proxy serving all modules 为所有模块提供服务的私有代理</h3>
<p>​	为所有模块（公共和私有）提供服务的中央私有代理服务器为管理员提供了最大程度的控制，并且对单个开发人员来说需要的配置最少。</p>
<p>​	要配置<code>go</code>命令以使用这样的服务器，请设置以下环境变量，将<code>https://proxy.corp.example.com</code>替换为你的代理URL，将<code>corp.example.com</code>替换为你的模块前缀。</p>
<pre tabindex="0"><code>GOPROXY=https://proxy.corp.example.com
GONOSUMDB=corp.example.com
</code></pre><p>​	<code>GOPROXY</code> 设置指示 <code>go</code> 命令仅从 <code>https://proxy.corp.example.com</code> 下载模块；<code>go</code> 命令不会连接到其他代理或版本控制存储库。</p>
<p>​	<code>GONOSUMDB</code> 设置指示 <code>go</code> 命令不使用公共校验和数据库来验证路径以 <code>corp.example.com</code> 开头的模块。</p>
<p>​	以这种配置运行的代理可能需要对私有版本控制服务器进行读取访问。它还需要访问公共互联网来下载公共模块的新版本。</p>
<p>​	有几种现有的<code>GOPROXY</code>服务器实现可以以这种方式使用。最小的实现将从<a href="../Glossary#module-cache">module cache（模块缓存）</a>目录中提供文件，并使用<a href="../gomodFiles#go-mod-download">go mod download</a>（带有适当的配置）来检索丢失的模块。</p>
<h3 id="private-proxy-serving-private-modules-为私有模块提供服务的私有代理">Private proxy serving private modules 为私有模块提供服务的私有代理</h3>
<p>​	私人代理服务器可以为私人模块提供服务，而不需要为公开的模块提供服务。<code>go</code>命令可以被配置为在私人服务器上无法使用的模块时回退到公共源。</p>
<p>​	要配置<code>go</code>命令以这种方式工作，请设置以下环境变量，将<code>https://proxy.corp.example.com</code>替换为代理URL，将<code>corp.example.com</code>替换为模块前缀：</p>
<pre tabindex="0"><code>GOPROXY=https://proxy.corp.example.com,https://proxy.golang.org,direct
GONOSUMDB=corp.example.com
</code></pre><p>​	<code>GOPROXY</code> 设置指示 <code>go</code> 命令首先尝试从 <code>https://proxy.corp.example.com</code> 下载模块。如果该服务器的回应是404 (Not Found)或410 (Gone)，<code>go</code>命令将回退到<code>https://proxy.golang.org</code>，在之后才是直接连接到存储库。</p>
<p>​	<code>GONOSUMDB</code> 设置指示 <code>go</code> 命令不使用公共校验和数据库来验证路径以 <code>corp.example.com</code> 开头的模块。</p>
<p>​	请注意，在这种配置下使用的代理仍然可以控制对公共模块的访问，即使它不为公共模块提供服务。如果代理以404或410以外的错误状态响应请求，<code>go</code>命令将不会回退到<code>GOPROXY</code>列表的后面条目。例如，代理可能会对具有不合适许可证或具有已知安全漏洞的模块响应403 (Forbidden) 。</p>
<h3 id="direct-access-to-private-modules-直接访问私有模块">Direct access to private modules 直接访问私有模块</h3>
<p>​	<code>go</code>命令可以被配置为绕过公共代理，并直接从版本控制服务器下载私有模块。当无法运行私有代理服务器时，这非常有用。</p>
<p>​	要配置 <code>go</code> 命令以这种方式工作，请设置 <code>GOPRIVATE</code>，将私有模块前缀替换为 <code>corp.example.com</code> ：</p>
<pre tabindex="0"><code>GOPRIVATE=corp.example.com
</code></pre><p>​	在这种情况下，不需要更改<code>GOPROXY</code>变量。它的默认值是<code>https://proxy.golang.org,direct</code>，它指示<code>go</code> 命令首先尝试从<code>https://proxy.golang.org</code>，然后在代理响应404 (Not Found)或410 (Gone)时回退到直接连接。</p>
<p>​	<code>GOPRIVATE</code>设置指示<code>go</code> 命令不要连接到代理或以<code>corp.example.com</code>开头的模块的校验和数据库。</p>
<p>​	可能仍需要内部HTTP服务器来将模块路径解析为存储库URL。例如，当 <code>go</code> 命令下载模块 <code>corp.example.com/mod</code> 时，它将向 <code>https://corp.example.com/mod?go-get=1</code>发送一个 GET 请求，并在响应中查找存储库的 URL。要避免这种需求，请确保每个私有模块路径都有一个<code>VCS</code>后缀（如<code>.git</code>）来标记存储库根的前缀。例如，当 <code>go</code> 命令下载模块 <code>corp.example.com/repo.git/mod</code> 时，它将在 <code>https://corp.example.com/repo.git</code> 或 <code>ssh://corp.example.com/repo.git</code>中克隆 Git 存储库，而不需要发出额外的请求。</p>
<p>​	开发人员将需要对包含私有模块的存储库具有读取权限。这可以在全局<code>VCS</code>配置文件中配置，如<code>.gitconfig</code>。好将<code>VCS</code>工具配置为不需要交互式身份验证提示。默认情况下，在调用Git时，<code>go</code> 命令通过设置<code>GIT_TERMINAL_PROMPT=0</code>来禁用交互式提示，但它会遵守显式设置。</p>
<h3 id="passing-credentials-to-private-proxies-将凭据传递给私有代理">Passing credentials to private proxies 将凭据传递给私有代理</h3>
<p>​	<code>go</code> 命令在与代理服务器通信时支持 HTTP<a href="https://en.wikipedia.org/wiki/Basic_access_authentication" target="_blank" rel="noopener">basic authentication（基本身份验证）</a>。</p>
<p>​	凭证可以在<a href="https://www.gnu.org/software/inetutils/manual/html_node/The-_002enetrc-file.html" target="_blank" rel="noopener">.netrc 文件</a>中指定。例如，包含以下几行的<code>.netrc</code>文件将配置<code>go</code> 命令用给定的用户名和密码连接到<code>proxy.corp.example.com</code>机器上。</p>
<pre tabindex="0"><code>machine proxy.corp.example.com
login jrgopher
password hunter2
</code></pre><p>​	文件的位置可以通过<code>NETRC</code>环境变量来设置。如果没有设置<code>NETRC</code>，<code>go</code> 命令将读取<code>$HOME/.netrc</code>(在类UNIX平台上)，或读取<code>%USERPROFILE%\_netrc</code>(在Windows上)。</p>
<p>​	<code>.netrc</code>中的字段用空格、制表符和换行符分隔。遗憾的是，这些字符不能用于用户名或密码。还要注意的是，计算机名不能是一个完整的URL，因此不能为同一台机器上的不同路径指定不同的用户名和密码。</p>
<p>​	另外，凭证可以直接在<code>GOPROXY</code>的URL中指定。例如：</p>
<pre tabindex="0"><code>GOPROXY=https://jrgopher:hunter2@proxy.corp.example.com
</code></pre><p>​	采取这种方法时要小心：环境变量可能会出现在shell历史记录和日志中。</p>
<h3 id="passing-credentials-to-private-repositories-将凭证传递给私有存储库">Passing credentials to private repositories 将凭证传递给私有存储库</h3>
<p><code>go</code> 命令可以直接从版本控制储存库中下载模块。如果没有使用私有代理，这对私有模块是必要的。参见<a href="#direct-access-to-private-modules">Direct access to private modules（直接访问私有模块）</a>的配置。</p>
<p>​	<code>go</code> 命令在直接下载模块时运行<code>git</code>等版本控制工具。这些工具执行它们自己的身份验证，所以你可能需要在工具特定的配置文件（如<code>.gitconfig</code>）中配置凭证。</p>
<p>​	为了确保这项工作顺利进行，请确保<code>go</code> 命令使用正确的存储库URL，并且版本控制工具不需要交互式输入密码。<code>go</code> 命令优先使用 <code>https://</code> URL，而不是<code>ssh://</code>等其他方案，除非在<a href="../VersionControlSystems#finding-a-repository-for-a-module-path">查找存储库 URL</a> 时指定了方案。特别是对于 GitHub 存储库，<code>go</code> 命令假定为 <code>https://</code>。</p>
<p>​	对于大多数服务器，你可以将客户端配置为通过HTTP进行身份验证。例如，GitHub 支持使用 <a href="https://docs.github.com/en/free-pro-team@latest/github/extending-github/git-automation-with-oauth-tokens" target="_blank" rel="noopener">OAuth 个人访问令牌作为 HTTP 密码</a>。你可以将HTTP密码存储在<code>.netrc</code>文件中，就像<a href="#passing-credentials-to-private-proxies">将凭证传递给私有代理</a>时一样。</p>
<p>​	另外，你也可以将<code>https://</code> URL重写成另一种方案。例如，在<code>.gitconfig</code>中：</p>
<pre tabindex="0"><code>[url &#34;git@github.com:&#34;]
    insteadOf = https://github.com/
</code></pre><p>​	更多信息，请参见<a href="../../../FAQ_En_Zh#why-does-go-get-use-https-when-cloning-a-repository-go-get-https">为什么 &ldquo;go get &ldquo;在克隆存储库时使用HTTPS？</a></p>
<h3 id="privacy-隐私">Privacy 隐私</h3>
<p>​	<code>go</code> 命令可以从模块代理服务器和版本控制系统下载模块和元数据。环境变量<code>GOPROXY</code>控制使用哪些服务器。环境变量<code>GOPRIVATE</code>和<code>GONOPROXY</code>控制从代理服务器获取哪些模块。</p>
<p>​	<code>GOPROXY</code>的默认值是：</p>
<pre tabindex="0"><code>https://proxy.golang.org,direct
</code></pre><p>​	在此设置下，当<code>go</code> 命令下载模块或模块元数据时，它将首先向<code>proxy.golang.org</code>发送请求，这是一个由谷歌（<a href="https://proxy.golang.org/privacy" target="_blank" rel="noopener">privacy policy（隐私策略）</a>）运营的公共模块代理。有关在每个请求中发送哪些信息的详细信息，请参见<a href="../ModuleProxies#goproxy-protocol">GOPROXY 协议</a>。<code>go</code> 命令不会传输个人身份信息，但它会传输所请求的完整模块路径。如果代理以404 (Not Found)或410 (Gone) 状态响应，<code>go</code> 命令将尝试直接连接到提供该模块的版本控制系统。详见<a href="../VersionControlSystems">Version control systems（版本控制系统）</a>。</p>
<p>​	<code>GOPRIVATE</code> 或 <code>GONOPROXY</code> 环境变量可以被设置为与模块前缀匹配的 glob 模式列表，这些模块前缀是私有的，不应该从任何代理请求。例如：</p>
<pre tabindex="0"><code>GOPRIVATE=*.corp.example.com,*.research.example.com
</code></pre><p>​	<code>GOPRIVATE</code>只是作为<code>GONOPROXY</code>和<code>GONOSUMDB</code>的默认值，因此没有必要设置<code>GONOPROXY</code>，除非<code>GONOSUMDB</code>应该有一个不同的值。当模块路径与<code>GONOPROXY</code>匹配时，<code>go</code> 命令将忽略该模块的<code>GOPROXY</code>，并直接从其版本控制存储库中获取它。当没有代理为私有模块提供服务时，这很有用。参见<a href="#direct-access-to-private-modules">Direct access to private modules（直接访问私有模块）</a>。</p>
<p>​	如果有一个<a href="#private-proxy-serving-all-modules">受信任的代理为所有模块提供服务</a>，那么<code>GONOPROXY</code>就不应该被设置。例如，如果 <code>GOPROXY</code> 被设置为一个源，那么<code>go</code> 命令将不会从其他源下载模块。在这种情况下仍应设置<code>GONOSUMDB</code>。</p>
<pre tabindex="0"><code>GOPROXY=https://proxy.corp.example.com
GONOSUMDB=*.corp.example.com,*.research.example.com
</code></pre><p>​	如果有一个<a href="#private-proxy-serving-private-modules">受信任的代理仅为私有模块提供服务</a>，那么不应该设置<code>GONOPROXY</code>，但必须注意确保该代理以正确的状态码进行响应。例如，请考虑以下配置：</p>
<pre tabindex="0"><code>GOPROXY=https://proxy.corp.example.com,https://proxy.golang.org
GONOSUMDB=*.corp.example.com,*.research.example.com
</code></pre><p>​	假设由于输入错误，开发人员试图下载一个不存在的模块。</p>
<pre tabindex="0"><code>go mod download corp.example.com/secret-product/typo@latest
</code></pre><p>​	<code>go</code> 命令首先从<code>proxy.corp.example.com</code>请求此模块。如果该代理响应404 (Not Found)或410 (Gone)，那么<code>go</code> 命令将回退到<code>proxy.golang.org</code>，在请求URL中传输<code>secret-product</code>路径。如果私人代理响应任何其他错误码，那么<code>go</code> 命令将打印错误，并且不会回退到其他源。</p>
<p>​	除了代理之外，<code>go</code> 命令还可以连接到校验和数据库，以验证<code>go.sum</code>中没有列出的模块的加密散列。<code>GOSUMDB</code>环境变量设置校验和数据库的名称、URL和公钥。<code>GOSUMDB</code> 的默认值是 <code>sum.golang.org</code>，它是由 Google （<a href="https://sum.golang.org/privacy" target="_blank" rel="noopener">privacy policy（隐私策略）</a>）运营的公共校验和数据库。关于每次请求所传送的内容，请参见<a href="../AuthenticatingModules#checksum-database">Checksum database（校验和数据库）</a>。与代理一样，<code>go</code> 命令不会传输个人身份信息，但它会传输所请求的完整模块路径，而且校验和数据库无法计算非公共模块的校验和。</p>
<p>​	可以将<code>GONOSUMDB</code>环境变量设置为指示哪些模块是私有的并且不应从校验和数据库请求的模式。 <code>GOPRIVATE</code>作为<code>GONOSUMDB</code>和<code>GONOPROXY</code>的默认值，因此没有必要设置<code>GONOSUMDB</code>，除非<code>GONOPROXY</code>应该有不同的值。</p>
<p>​	代理可以<a href="https://go.googlesource.com/proposal/&#43;/master/design/25530-sumdb.md#proxying-a-checksum-database" target="_blank" rel="noopener">mirror the checksum database（镜像校验和数据库）</a>。如果<code>GOPROXY</code>中的代理执行此操作，<code>go</code> 命令将不会直接连接到校验和数据库。</p>
<p>​	<code>GOSUMDB</code>可以被设置为<code>off</code>，以完全禁止使用校验和数据库。使用此设置时，<code>go</code> 命令将不会对下载的模块进行身份验证，除非它们已经在<code>go.sum</code>中。请参阅<a href="../AuthenticatingModules">Authenticating modules（验证模块）</a>。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-83706bb3f8d11c662bef82051b50593b">13 - 模块缓存</h1>
    
	<h2 id="module-cache-模块缓存">Module cache 模块缓存</h2>
<blockquote>
<p>原文：<a href="https://go.dev/ref/mod#module-cache" target="_blank" rel="noopener">https://go.dev/ref/mod#module-cache</a></p>
</blockquote>
<p>​	模块缓存是<code>go</code>命令存储下载模块文件的目录。模块缓存与构建缓存不同，构建缓存包含已编译的包和其他构建构件。</p>
<p>​	模块缓存的默认位置是 <code>$GOPATH/pkg/mod</code>。要使用其他位置，请设置<code>GOMODCACHE</code><a href="../EnvironmentVariables">environment variable（环境变量）</a>。</p>
<p>​	模块缓存没有最大大小，<code>go</code>命令不会自动删除其内容。</p>
<p>​	缓存可以由同一台机器上开发的多个 Go 项目共享。无论主模块的位置如何，<code>go</code>命令都会使用相同的缓存。<code>go</code>命令的多个实例可以同时安全地访问同一个模块缓存。</p>
<p>​	<code>go</code>命令在缓存中创建具有只读权限的模块源文件和目录，以防止模块下载后被意外更改。这有一个不幸的副作用，就是难以用<code>rm -rf</code>等命令删除缓存。取而代之的是，缓存可以用<a href="../gomodFiles#go-clean-modcache">go clean -modcache</a>来删除。另外，当使用<code>-modcacherw</code>标志时，<code>go</code>命令将创建具有读写权限的新目录。这增加了编辑、测试和其他程序修改模块缓存中文件的风险。<a href="">go mod verify</a> 命令可以用来检测对主模块的依赖项的修改。它扫描每个模块依赖项的提取内容，并确认它们与<code>go.sum</code>中预期的散列匹配。</p>
<p>​	下表解释了模块缓存中大多数文件的用途。省略了一些临时文件(锁定文件、临时目录)。对于每个路径，<code>$module</code>是一个模块路径，<code>$version</code>是一个版本。以斜线（<code>/</code>）结尾的路径是目录。模块路径和版本中的大写字母用感叹号转义（<code>Azure</code>被转义为<code>!azure</code>）以避免在不区分大小写的文件系统上发生冲突。</p>
<table>
<thead>
<tr>
<th>Path</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="moduleversion"><code>$module@$version/</code></h3>
<p>​	包含模块<code>.zip</code>文件的提取内容的目录。它用作已下载模块的模块根目录。如果原始模块没有<code>go.mod</code>文件，那么它将不包含<code>go.mod</code>文件。</p>
<h3 id="cachedownload"><code>cache/download/</code></h3>
<p>​	包含从模块代理下载的文件和从<a href="../VersionControlSystems">版本控制系统</a>获得的文件的目录。这个目录的布局遵循<a href="../ModuleProxies#goproxy-protocol">GOPROXY 协议</a>，因此当由HTTP文件服务器提供服务或用<code>file://</code>URL引用此目录时，此目录可以作为一个代理使用。</p>
<h3 id="cachedownloadmodulevlist"><code>cache/download/$module/@v/list</code></h3>
<p>​	已知版本的列表（见<a href="../ModuleProxies#goproxy-protocol">GOPROXY 协议</a>）。这可能会随着时间的推移而改变，因此<code>go</code>命令通常会获取新的副本，而不是重新使用这个文件。</p>
<h3 id="cachedownloadmodulevversioninfo"><code>cache/download/$module/@v/$version.info</code></h3>
<p>​	有关版本的JSON元数据。(见<a href="../ModuleProxies#goproxy-protocol">GOPROXY 协议</a>)。这可能会随着时间的推移而改变，因此<code>go</code>命令通常会获取新的副本，而不是重复使用这个文件。</p>
<h3 id="cachedownloadmodulevversionmod"><code>cache/download/$module/@v/$version.mod</code></h3>
<p>​	这个版本的<code>go.mod</code>文件（见<a href="../ModuleProxies#goproxy-protocol">GOPROXY 协议</a>）。如果原来的模块没有<code>go.mod</code>文件，则这就是一个没有需求的合成文件。</p>
<h3 id="cachedownloadmodulevversionzip"><code>cache/download/$module/@v/$version.zip</code></h3>
<p>​	模块的压缩内容（见<a href="../ModuleProxies#goproxy-protocol">GOPROXY 协议</a>和<a href="../ModuleZipFiles">模块压缩文件</a>）。</p>
<h3 id="cachedownloadmodulevversionziphash"><code>cache/download/$module/@v/$version.ziphash</code></h3>
<p>​	<code>.zip</code>文件中的文件的加密哈希值。请注意<code>.zip</code>文件本身没有被哈希化，因此文件的顺序、压缩、对齐和元数据不会影响哈希值。当使用一个模块时，<code>go</code>命令会验证这个哈希值是否与<code>go.sum</code>中的对应行匹配。<a href="../gomodFiles#go-mod-verify">go mod verify</a>命令检查模块<code>.zip</code>文件和提取的目录的哈希值是否与这些文件相符。</p>
<h3 id="cachedownloadsumdb"><code>cache/download/sumdb/</code></h3>
<p>​	包含从<a href="../AuthenticatingModules#checksum-database">checksum database（校验和数据库）</a>（通常是<code>sum.golang.org</code>）下载的文件的目录。</p>
<h3 id="cachevcs"><code>cache/vcs/</code></h3>
<p>​	包含直接从源获取的模块的克隆的版本控制存储库。目录名称是由存储库类型和 URL 衍生出来的十六进制编码的哈希值。存储库在磁盘上的大小是经过优化的。例如，克隆的Git存储库在可能的情况下是裸露和浅层的。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-cba8b7700bd065b7d7d571cf0b19c65a">14 - 验证模块</h1>
    
	<h2 id="authenticating-modules-验证模块">Authenticating modules 验证模块</h2>
<blockquote>
<p>原文：<a href="https://go.dev/ref/mod#authenticating" target="_blank" rel="noopener">https://go.dev/ref/mod#authenticating</a></p>
</blockquote>
<p>​	当<code>go</code>命令下载模块<a href="../ModuleZipFiles">zip 文件</a>或<code>go.mod</code>文件到<a href="../ModuleCache">module cache（模块缓存）</a>时，它会计算加密散列并将其与已知值进行比较，以验证该文件自首次下载以来没有更改。如果下载的文件没有正确的散列值，<code>go</code>命令会报告安全错误。</p>
<p>​	对于<code>go.mod</code>文件，<code>go</code>命令从文件内容中计算出散列值。对于模块zip文件，<code>go</code>命令以确定的顺序从归档文件中的文件名称和内容计算散列值。散列值不受文件顺序、压缩、对齐和其他元数据的影响。有关散列值的实现细节，请参见 <a href="https://pkg.go.dev/golang.org/x/mod/sumdb/dirhash?tab=doc" target="_blank" rel="noopener">golang.org/x/mod/sumdb/dirhash</a>。</p>
<p>​	<code>go</code>命令将每个散列值与主模块的<code>go.sum</code>文件中的对应行进行比较。如果散列值与<code>go.sum</code>中的散列值不同，<code>go</code>命令将报告安全错误，并删除下载的文件而不将其加入模块缓存。</p>
<p>​	如果<code>go.sum</code>文件不存在，或者它不包含下载文件的散列值，则<code>go</code>命令可以使用校验和数据库（公共可用模块的全局散列源）验证散列值。散列值被验证之后，<code>go</code>命令会将其加入<code>go.sum</code>，并将下载的文件加入模块缓存中。如果模块是私有的（被<code>GOPRIVATE</code>或<code>GONOSUMDB</code>环境变量匹配），或者如果校验和数据库被禁用（通过设置<code>GOSUMDB=off</code>），则<code>go</code>命令接受散列值并将文件添加到模块缓存中，而不进行验证。</p>
<p>​	模块缓存通常由系统中的所有Go项目共享，每个模块可能有自己的<code>go.sum</code>文件，其散列值可能不同。为了避免信任其他模块，<code>go</code>命令在访问模块缓存中的文件时，使用主模块的<code>go.sum</code>来验证散列值。zip文件的散列值计算成本很高，所以<code>go</code>命令检查与zip文件一起存储的预先计算的散列值，而不是重新散列文件。<a href="../gomodFiles#go-mod-verify">go mod verify</a>命令可以用来检查zip文件和提取的目录自从被添加到模块缓存后是否被修改过。</p>
<h3 id="gosum-files">go.sum files</h3>
<p>​	模块的根目录中可能有一个名为<code>go.sum</code>的文本文件，以及跟随它的<code>go.mod</code>文件。<code>go.sum</code>文件包含模块的直接和间接依赖的加密散列值。当<code>go</code>命令将模块<code>.mod</code>或<code>.zip</code>文件下载到<a href="../ModuleCache">module cache（模块缓存）</a>中时，它会计算散列并检查该散列是否与主模块的<code>go.sum</code>文件中的相应散列匹配。如果模块没有依赖项，或者如果使用<a href="../gomodFiles#replace-directive">replace 指令</a>将所有依赖项替换为本地目录，那么<code>go.sum</code>可能为空或不存在。</p>
<p>​	<code>go.sum</code>中的每一行都有三个用空格隔开的字段：模块路径，版本（可能以<code>/go.mod</code>结尾），以及散列值。</p>
<ul>
<li>
<p>模块路径是散列值所属模块的名称。</p>
</li>
<li>
<p>版本是散列值所属的模块的版本。如果版本以<code>/go.mod</code>结尾，则散列值仅适用于该模块的<code>go.mod</code>文件；否则，散列值适用于该模块的<code>.zip</code>文件中的文件。</p>
</li>
<li>
<p>散列值由算法名称（如<code>h1</code>）和一个base64编码的加密散列组成，用冒号（<code>:</code>）分开。目前，SHA-256（<code>h1</code>）是唯一支持的散列算法。如果将来发现了SHA-256的漏洞，将增加对另一种算法（命名为<code>h2</code>，以此类推）的支持。</p>
</li>
</ul>
<p>​	<code>go.sum</code>文件可能包含一个模块的多个版本的散列值。<code>go</code>命令可能需要从依赖项的多个版本加载<code>go.mod</code>文件，以进行<a href="../MVS">最小的版本选择</a>。<code>go.sum</code>也可能包含不再需要的模块版本的散列值（例如，在升级之后）。<a href="../gomodFiles#go-mod-tidy">go mod tidy</a>将添加缺失的散列值，并从<code>go.sum</code>中删除不必要的散列值。</p>
<h3 id="checksum-database-校验和数据库">Checksum database 校验和数据库</h3>
<p>​	校验和数据库是<code>go.sum</code>行的全局源。<code>go</code>命令可以在许多情况下使用它来检测代理或源服务器的错误行为。</p>
<p>​	校验和数据库允许所有公开可用的模块版本的全局一致性和可靠性。它使不被信任的代理成为可能，因为它们无法在不被发现的情况下提供错误的代码。它还确保与特定版本相关的bit位不会从一天到另一天发生变化，即使模块的作者后来更改了其存储库中的标签。</p>
<p>​	校验和数据库由Google运营的<a href="https://sum.golang.org/" target="_blank" rel="noopener">sum.golang.org</a>提供服务。它是由<a href="https://github.com/google/trillian" target="_blank" rel="noopener">Trillian</a>支持的<code>go.sum</code>行散列的透明日志(或“<code>Merkle 树</code>”)。  <code>Merkle 树</code>的主要优点是，独立的审计人员可以验证它没有被篡改，因此它比简单的数据库更值得信赖。</p>
<p>​	<code>go</code>命令使用最初在<a href="https://go.googlesource.com/proposal/&#43;/master/design/25530-sumdb.md#checksum-database" target="_blank" rel="noopener">Proposal: Secure the Public Go Module Ecosystem</a>中概述的协议与校验和数据库进行交互。</p>
<p>​	下表列出了校验和数据库必须响应的查询。对于每个路径，<code>$base</code>是校验和数据库URL的路径部分，<code>$module</code>是模块路径，而<code>$version</code>是版本。例如，如果校验和数据库的URL是<code>https://sum.golang.org</code>，而客户端请求的是<code>golang.org/x/text</code>模块的记录，版本为<code>v0.3.2</code>，那么客户端将发送<code>https://sum.golang.org/lookup/golang.org/x/text@v0.3.2</code>的<code>GET</code>请求。</p>
<p>​	为了避免在从不区分大小写的文件系统中提供服务时出现歧义，<code>$module</code>和<code>$version</code>元素被进行了<a href="https://pkg.go.dev/golang.org/x/mod/module#EscapePath" target="_blank" rel="noopener">case-encoded（大小写编码）</a>，将每个大写字母替换为感叹号，后跟相应的小写字母。这允许模块<code>example.com/M</code>和<code>example.com/m</code>同时被存储在磁盘上，因为前者被编码为<code>example.com/!m</code>。</p>
<p>​	路径中由方括号包围的部分，如<code>[.p/$W]</code>表示可选的值。</p>
<table>
<thead>
<tr>
<th>Path</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="baselatest"><code>$base/latest</code></h4>
<p>​	返回最新日志的有符号编码的树描述。这个签名的描述是以<a href="https://pkg.go.dev/golang.org/x/mod/sumdb/note" target="_blank" rel="noopener">note（注释）</a>的形式出现的，它是由一个或多个服务器密钥签名的文本，可以用服务器的公钥进行验证。树描述提供了树的大小和该大小的树头的散列值。这中编码在<code>golang.org/x/mod/sumdb/tlog#FormatTree</code>中有描述。</p>
<h4 id="baselookupmoduleversion"><code>$base/lookup/$module@$version</code></h4>
<p>​	返回<code>$version</code>中关于<code>$module</code>的条目的日志记录编号，后跟记录的数据（即<code>$version</code>中的<code>$module</code>的<code>go.sum</code>行）和包含该记录的有符号编码的树描述。</p>
<h4 id="basetilehlkpw"><code>$base/tile/$H/$L/$K[.p/$W]</code></h4>
<p>​	返回一个<a href="https://research.swtch.com/tlog#serving_tiles" target="_blank" rel="noopener">log tile</a>，它是组成日志的一部分的一组散列。每个tile定义在tile级别<code>$L</code>，左起<code>$K</code>的二维坐标中，tile高度为<code>$H</code>。可选的<code>.p/$W</code>后缀表示只有<code>$W</code>散列的部分日志块。如果没有找到部分tile，客户必须回退到获取完整的tile。</p>
<h4 id="basetilehdatakpw"><code>$base/tile/$H/data/$K[.p/$W]</code></h4>
<p>​	返回<code>/tile/$H/0/$K[.p/$W]</code>中的叶子散列的记录数据（带有字面<code>data</code>路径元素）。</p>
<hr>
<p>​	如果<code>go</code>命令查询校验和数据库，那么第一步就是通过<code>/lookup</code>端点检索记录数据。如果日志中尚未记录模块版本，校验和数据库将尝试在回复前从原服务器上获取它。这个<code>/lookup</code>数据提供了这个模块版本的sum（和）以及它在日志中的位置，这就通知了客户端应该取哪些tile来执行证明。在向主模块的<code>go.sum</code>文件添加新的<code>go.sum</code>行之前，<code>go</code>命令执行 &ldquo;inclusion（包含性）&ldquo;证明（即日志中存在特定记录）和 &ldquo;consistency（一致性）&ldquo;证明（即树没有被篡改）。重要的是，如果没有首先根据签名的树散列值对其进行身份认证，以及根据客户的签名树散列值时间线对签名树散列值进行认证，就不应该使用来自<code>/lookup</code>的数据。</p>
<p>​	已签名的树状散列值和由校验数据库提供的新瓦片都存储在模块缓存中，所以<code>go</code>命令只需要获取缺少的瓦片。</p>
<p><code>go</code>命令不需要直接连接到校验和数据库。它可以通过镜像<a href="https://go.googlesource.com/proposal/&#43;/master/design/25530-sumdb.md#proxying-a-checksum-database" target="_blank" rel="noopener">mirrors the checksum database（校验和数据库）</a>并支持上述协议的模块代理来请求模块和。这对于阻止组织外部请求的私有企业代理特别有帮助。</p>
<p>​	<code>GOSUMDB</code>环境变量标识要使用的校验和数据库的名称，还可以选择其公钥和URL，如：</p>
<pre tabindex="0"><code>GOSUMDB=&#34;sum.golang.org&#34;
GOSUMDB=&#34;sum.golang.org+&lt;publickey&gt;&#34;
GOSUMDB=&#34;sum.golang.org+&lt;publickey&gt; https://sum.golang.org&#34;
</code></pre><p>​	<code>go</code>命令知道<code>sum.golang.org</code>的公钥，也知道<code>sum.golang.google.cn</code>这个名字（在中国大陆可用）连接到<code>sum.golang.org</code>的校验和数据库；使用其他数据库需要显式给出公钥。URL默认为<code>https://</code>，后跟数据库名称。</p>
<p>​	<code>GOSUMDB</code>默认为<code>sum.golang.org</code>，这是由Google运营的Go校验和数据库。有关该服务的隐私政策，请参见 <a href="https://sum.golang.org/privacy" target="_blank" rel="noopener">https://sum.golang.org/privacy</a>。</p>
<p>​	如果 <code>GOSUMDB</code> 被设置为<code>off</code>，或者在调用 <code>go get</code> 时使用了 <code>-insecure</code> 标志，则不会查询校验和数据库，并接受所有未识别的模块，代价是放弃了对所有模块的可重复下载的安全保证。一个更好的方法是使用<code>GOPRIVATE</code>或<code>GONOSUMDB</code>环境变量来绕过特定模块的校验和数据库。详见<a href="../PrivateModules">Private Modules（私有模块）</a>。</p>
<p>​	<code>go env -w</code>命令可用于为将来的<code>go</code>命令调用<a href="../../CommandDocumentation/go#print-go-environment-information">设置这些变量</a>。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-cf1289104d703cf5e4a8add67477c590">15 - 环境变量</h1>
    
	<h2 id="environment-variables-环境变量">Environment variables 环境变量</h2>
<blockquote>
<p>原文：<a href="https://go.dev/ref/mod#environment-variables" target="_blank" rel="noopener">https://go.dev/ref/mod#environment-variables</a></p>
</blockquote>
<p>​	<code>go</code>命令中的模块行为可以使用下面列出的环境变量进行配置。这个列表只包括与模块相关的环境变量。有关<code>go</code>命令识别的所有环境变量的列表，请参阅<a href="../../CommandDocumentation/go#environment-variables">go help environment</a>。</p>
<h3 id="go111module">GO111MODULE</h3>
<p>​	控制<code>go</code>命令是在模块感知模式还是<code>GOPATH</code>模式下运行。有三个值可以识别：</p>
<ul>
<li>
<p><code>off</code>：<code>go</code>命令忽略<code>go.mod</code>文件，并在<code>GOPATH</code>模式下运行。</p>
</li>
<li>
<p><code>on</code> (或unset): <code>go</code>命令在模块感知模式下运行，即使不存在<code>go.mod</code>文件。</p>
</li>
<li>
<p><code>auto</code>：如果当前目录或任何父目录中存在<code>go.mod</code>文件，<code>go</code>命令将以模块感知模式运行。在Go 1.15及以下版本中，这是默认的。</p>
</li>
</ul>
<p>​	更多信息请参见<a href="../Module-awareCommands">模块感知命令</a>。</p>
<h3 id="gomodcache">GOMODCACHE</h3>
<p>​	<code>go</code>命令将存储下载的模块和相关文件的目录。关于此目录结构的详细信息，请参见<a href="../ModuleCache">模块缓存</a>。如果未设置<code>GOMODCACHE</code>，它默认为<code>$GOPATH/pkg/mod</code>。</p>
<h3 id="goinsecure">GOINSECURE</h3>
<p>​	以逗号分隔的模块路径前缀 glob 模式列表（采用 Go的 <a href="https://go.dev/pkg/path/#Match" target="_blank" rel="noopener">path.Match</a> 的语法），可能总是以不安全的方式获取。仅适用于被直接获取的依赖项。与<code>go get</code>上的<code>-insecure</code>标志不同，<code>GOINSECURE</code>不会禁用模块校验和数据库验证（module checksum database validation）。可以用<code>GOPRIVATE</code>或<code>GONOSUMDB</code>来实现这一点。</p>
<h3 id="gonoproxy">GONOPROXY</h3>
<p>​	以逗号分隔的模块路径前缀 glob 模式列表（采用Go的<a href="https://go.dev/pkg/path/#Match" target="_blank" rel="noopener">path.Match</a>语法），应该总是直接从版本控制存储库获取，而不是从模块代理获取。如果没有设置<code>GONOPROXY</code>，它默认为<code>GOPRIVATE</code>。参见<a href="../PrivateModules#privacy">Privacy（隐私）</a>。</p>
<h3 id="gonosumdb">GONOSUMDB</h3>
<p>​	以逗号分隔的模块路径前缀 glob 模式列表（采用Go的<a href="https://go.dev/pkg/path/#Match" target="_blank" rel="noopener">path.Match</a>语法），<code>go</code> 不应使用校验数据库来验证校验。如果未设置 <code>GONOSUMDB</code>，它默认为 <code>GOPRIVATE</code>。参见<a href="../PrivateModules#privacy">Privacy（隐私）</a>。</p>
<h3 id="gopath">GOPATH</h3>
<p>​	在 <code>GOPATH</code> 模式中，<code>GOPATH</code> 变量是一个可能包含 Go 代码的目录列表。在模块感知模式下，<a href="../Glossary#module-cache">module cache（模块缓存）</a>存储在第一个 <code>GOPATH</code> 目录的 <code>pkg/mod</code> 子目录中。缓存之外的模块源代码可以存储在任何目录中。如果未设置<code>GOPATH</code>，它默认为用户的主目录（home directory）的<code>go</code>子目录。</p>
<h3 id="goprivate">GOPRIVATE</h3>
<p>​	以逗号分隔的模块路径前缀的 glob 模式列表（采用Go的<a href="https://go.dev/pkg/path/#Match" target="_blank" rel="noopener">path.Match</a>语法），应被视认为是私有的。<code>GOPRIVATE</code>是<code>GONOPROXY</code>和<code>GONOSUMDB</code>的默认值。参见<a href="../PrivateModules#privacy">Privacy（隐私）</a>。<code>GOPRIVATE</code> 也决定了一个模块是否被视为 <code>GOVCS</code> 的私有模块。</p>
<h3 id="goproxy">GOPROXY</h3>
<p>​	模块代理URL的列表，用逗号（<code>,</code>）或管道符 <code>|</code>分隔。当<code>go</code>命令查询有关模块的信息时，它会依次联系列表中的每个代理，直到收到成功的响应或终端错误。代理可能会响应404（Not Found）或410（Gone）状态，表示该模块在该服务器上不可用。</p>
<p>​	<code>go</code>命令的错误回退行为（error fallback behavior）是由URL之间的分隔符决定的。如果代理URL后面是逗号，<code>go</code>命令在404或410错误后会回退到下一个URL；所有其他错误都被视为终端错误。如果代理URL后面跟着管道，则<code>go</code>命令在出现任何错误(包括超时等非HTTP错误)后回退到下一个源。<code>GOPROXY</code> URLs可以有<code>https</code>、<code>http</code>或<code>file</code>等协议。如果一个URL没有协议，则假定为<code>https</code>。模块缓存可以直接作为文件代理使用：</p>
<p><code>GOPROXY=file://$(go env GOMODCACHE)/cache/download</code></p>
<p>有两个关键词可以用来代替代理URL：</p>
<ul>
<li>
<p><code>off</code>：不允许从任何源下载模块。</p>
</li>
<li>
<p><code>direct</code>： 直接从版本控制存储库下载，而不是使用模块代理。</p>
</li>
</ul>
<p>​	<code>GOPROXY</code>默认为<code>https://proxy.golang.org,direct</code>。在该配置下，<code>go</code>命令首先联系Google运行的Go模块镜像，如果该镜像没有模块，则回退到直接连接。请参见<a href="https://proxy.golang.org/privacy" target="_blank" rel="noopener">https://proxy.golang.org/privacy</a>了解镜像的隐私政策。可以设置 <code>GOPRIVATE</code> 和 <code>GONOPROXY</code> 环境变量，以防止使用代理下载特定模块。关于隐私代理配置的信息，请参见<a href="../PrivateModules#privacy">Privacy（隐私）</a>。</p>
<p>​	有关如何使用代理的更多信息，请参见<a href="../ModuleProxies">Module proxies（模块代理）</a>和<a href="../ModulesPackagesAndVersions#resolving-a-package-to-a-module">Resolving a package to a module（将包解析为模块）</a>。</p>
<h3 id="gosumdb">GOSUMDB</h3>
<p>​	标识要使用的校验和数据库的名称以及可选的公钥和 URL。例如：</p>
<pre tabindex="0"><code>GOSUMDB=&#34;sum.golang.org&#34;
GOSUMDB=&#34;sum.golang.org+&lt;publickey&gt;&#34;
GOSUMDB=&#34;sum.golang.org+&lt;publickey&gt; https://sum.golang.org&#34;
</code></pre><p>​	<code>go</code>命令知道<code>sum.golang.org</code>的公钥，也知道名称为<code>sum.golang.google.cn</code>（在中国大陆可用）连接到<code>sum.golang.org</code>数据库；使用任何其他数据库都需要显式地给出公钥。URL默认为<code>https://</code>后跟数据库名。</p>
<p>​	<code>GOSUMDB</code>默认为<code>sum.golang.org</code>，由Google运行的Go校验和数据库（checksum database）。有关该服务的隐私政策，请参见 <a href="https://sum.golang.org/privacy" target="_blank" rel="noopener">https://sum.golang.org/privacy</a>。</p>
<p>​	如果 <code>GOSUMDB</code> 被设置为<code>off</code>，或者在调用 <code>go get</code> 时使用了 <code>-insecure</code> 标志，则不会查询校验和数据库，所有未识别的模块都会被接受，代价是放弃对所有模块进行验证的可重复下载的安全保证。绕过特定模块的校验和数据库的更好方法是使用<code>GOPRIVATE</code>或<code>GONOSUMDB</code>环境变量。</p>
<p>​	更多信息请参见<a href="../AuthenticatingModules">Authenticating modules（验证模块）</a>和<a href="../PrivateModules#privacy">Privacy（隐私）</a>。</p>
<h3 id="govcs">GOVCS</h3>
<p>​	控制<code>go</code>命令在下载公共和私有模块（由其路径是否匹配<code>GOPRIVATE</code>中的模式来定义）或其他与glob模式相匹配的模块时可以使用的版本控制工具集。如果没有设置<code>GOVCS</code>，或者某个模块不符合<code>GOVCS</code>中的任何模式，<code>go</code>命令可以对公共模块使用<code>git</code>和<code>hg</code>，对私有模块使用任何已知的版本控制工具。具体来说，<code>go</code>命令的行为就像<code>GOVCS</code>被设置为<code>public:git|hg,private:all</code>，完整的解释请参见 <a href="../VersionControlSystems#controlling-version-control-tools-with-govcs">用<code>GOVCS</code>控制版本控制工具</a>。</p>
<h3 id="gowork">GOWORK</h3>
<p>​	<code>GOWORK</code>环境变量指示<code>go</code>命令使用提供的<a href="#go-work-file"><code>go.work</code>文件</a>进入工作区模式。如果<code>GOWORK</code>被设置为<code>off</code>，工作区模式将被禁用。这可以用来在单模块模式下运行<code>go</code>命令：例如，<code>GOWORK=off go build .</code>在单模块模式下构建<code>.</code>包。如果<code>GOWORK</code>为空，<code>go</code>命令将搜索<code>go.work</code>文件，如<a href="#workspaces">工作区</a>部分所述。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-f8defab094078f5ecc58e86abcfcf2ad">16 - 词汇表</h1>
    
	<h2 id="glossary词汇表">Glossary词汇表</h2>
<blockquote>
<p>原文：<a href="https://go.dev/ref/mod#glossary" target="_blank" rel="noopener">https://go.dev/ref/mod#glossary</a></p>
</blockquote>
<h3 id="build-constraint">build constraint</h3>
<p>A condition that determines whether a Go source file is used when compiling a package. Build constraints may be expressed with file name suffixes (for example, <code>foo_linux_amd64.go</code>) or with build constraint comments (for example, <code>// +build linux,amd64</code>). See <a href="https://go.dev/pkg/go/build/#hdr-Build_Constraints" target="_blank" rel="noopener">Build Constraints</a>.</p>
<p><strong>build constraint</strong> （构建约束）：决定在编译包时是否使用Go源文件的条件。构建约束可以用文件名后缀来表示（例如，<code>foo_linux_amd64.go</code>），也可以用构建约束的注释来表达（例如，<code>// +build linux,amd64</code>）。参见<a href="https://pkg.go.dev/go/build#hdr-Build_Constraints" target="_blank" rel="noopener">构建约束</a>。</p>
<h3 id="build-list">build list</h3>
<p>The list of module versions that will be used for a build command such as <code>go build</code>, <code>go list</code>, or <code>go test</code>. The build list is determined from the <a href="https://go.dev/ref/mod#glos-main-module" target="_blank" rel="noopener">main module’s</a> <a href="https://go.dev/ref/mod#glos-go-mod-file" target="_blank" rel="noopener"><code>go.mod</code> file</a> and <code>go.mod</code> files in transitively required modules using <a href="https://go.dev/ref/mod#glos-minimal-version-selection" target="_blank" rel="noopener">minimal version selection</a>. The build list contains versions for all modules in the <a href="https://go.dev/ref/mod#glos-module-graph" target="_blank" rel="noopener">module graph</a>, not just those relevant to a specific command.</p>
<p>build list: 将用于构建命令的模块版本列表，如go build、go list或go test。构建列表是由主模块的go.mod文件和中转所需模块的go.mod文件决定的，使用最小版本选择。构建列表包含了模块图中所有模块的版本，而不仅仅是与特定命令相关的模块。</p>
<h3 id="canonical-version">canonical version</h3>
<p>A correctly formatted <a href="https://go.dev/ref/mod#glos-version" target="_blank" rel="noopener">version</a> without a build metadata suffix other than <code>+incompatible</code>. For example, <code>v1.2.3</code> is a canonical version, but <code>v1.2.3+meta</code> is not.</p>
<p>典型版本。一个格式正确的版本，除了+incompatible之外，没有构建元数据的后缀。例如，v1.2.3是一个典型的版本，但v1.2.3+meta不是。</p>
<h3 id="current-module">current module</h3>
<p>Synonym for <a href="https://go.dev/ref/mod#glos-main-module" target="_blank" rel="noopener">main module</a>.</p>
<p>当前模块。主模块的同义词。</p>
<h3 id="deprecated-module">deprecated module</h3>
<p>A module that is no longer supported by its authors (though major versions are considered distinct modules for this purpose). A deprecated module is marked with a <a href="https://go.dev/ref/mod#go-mod-file-module-deprecation" target="_blank" rel="noopener">deprecation comment</a> in the latest version of its <a href="https://go.dev/ref/mod#glos-go-mod-file" target="_blank" rel="noopener"><code>go.mod</code> file</a>.</p>
<p>deprecated module（废弃的模块）。一个不再被其作者支持的模块（尽管主要版本在此被视为独立的模块）。被废弃的模块在其go.mod文件的最新版本中被标记为废弃注释。</p>
<h3 id="direct-dependency">direct dependency</h3>
<p>A package whose path appears in an <a href="https://go.dev/ref/spec#import_declarations" target="_blank" rel="noopener"><code>import</code> declaration</a> in a <code>.go</code> source file for a package or test in the <a href="https://go.dev/ref/mod#glos-main-module" target="_blank" rel="noopener">main module</a>, or the module containing such a package. (Compare <a href="https://go.dev/ref/mod#glos-indirect-dependency" target="_blank" rel="noopener">indirect dependency</a>.)</p>
<p>直接依赖关系。一个软件包，其路径出现在主模块中的包或测试的.go源文件的导入声明中，或者包含这样一个包的模块。(比较间接依赖)。</p>
<h3 id="direct-mode">direct mode</h3>
<p>A setting of <a href="https://go.dev/ref/mod#environment-variables" target="_blank" rel="noopener">environment variables</a> that causes the <code>go</code> command to download a module directly from a <a href="https://go.dev/ref/mod#vcs" target="_blank" rel="noopener">version control system</a>, as opposed to a <a href="https://go.dev/ref/mod#glos-module-proxy" target="_blank" rel="noopener">module proxy</a>. <code>GOPROXY=direct</code> does this for all modules. <code>GOPRIVATE</code> and <code>GONOPROXY</code> do this for modules matching a list of patterns.</p>
<p>直接模式。一种环境变量的设置，使go命令直接从版本控制系统中下载模块，而不是通过模块代理。GOPROXY=direct 对所有模块都是如此。GOPRIVATE和GONOPROXY对符合模式列表的模块做此处理。</p>
<h3 id="gomod-file">go.mod file</h3>
<p>The file that defines a module’s path, requirements, and other metadata. Appears in the <a href="https://go.dev/ref/mod#glos-module-root-directory" target="_blank" rel="noopener">module’s root directory</a>. See the section on <a href="https://go.dev/ref/mod#go-mod-file" target="_blank" rel="noopener"><code>go.mod</code> files</a>.</p>
<p>go.mod 文件。定义一个模块的路径、要求和其他元数据的文件。出现在模块的根目录下。参见 go.mod 文件一节。</p>
<h3 id="gowork-file">go.work file</h3>
<p>The file that defines the set of modules to be used in a <a href="https://go.dev/ref/mod#workspaces" target="_blank" rel="noopener">workspace</a>. See the section on <a href="https://go.dev/ref/mod#go-work-file" target="_blank" rel="noopener"><code>go.work</code> files</a></p>
<p>go.work文件：定义工作区中使用的模块集的文件。见go.work文件一节</p>
<h3 id="import-path">import path</h3>
<p>A string used to import a package in a Go source file. Synonymous with <a href="https://go.dev/ref/mod#glos-package-path" target="_blank" rel="noopener">package path</a>.</p>
<p>import路径。用来在 Go 源文件中导入软件包的字符串。与软件包路径同义。</p>
<h3 id="indirect-dependency">indirect dependency</h3>
<p>A package transitively imported by a package or test in the <a href="https://go.dev/ref/mod#glos-main-module" target="_blank" rel="noopener">main module</a>, but whose path does not appear in any <a href="https://go.dev/ref/spec#import_declarations" target="_blank" rel="noopener"><code>import</code> declaration</a> in the main module; or a module that appears in the <a href="https://go.dev/ref/mod#glos-module-graph" target="_blank" rel="noopener">module graph</a> but does not provide any package directly imported by the main module. (Compare <a href="https://go.dev/ref/mod#glos-direct-dependency" target="_blank" rel="noopener">direct dependency</a>.)</p>
<p>间接依赖。一个被主模块中的包或测试间接导入的包，但其路径没有出现在主模块的任何导入声明中；或者一个出现在模块图中的模块，但没有提供任何被主模块直接导入的包。(比较直接依赖）。</p>
<h3 id="lazy-module-loading">lazy module loading</h3>
<p>A change in Go 1.17 that avoids loading the <a href="https://go.dev/ref/mod#glos-module-graph" target="_blank" rel="noopener">module graph</a> for commands that do not need it in modules that specify <code>go 1.17</code> or higher. See <a href="https://go.dev/ref/mod#lazy-loading" target="_blank" rel="noopener">Lazy module loading</a>.</p>
<p>懒惰的模块加载。Go 1.17中的一个变化，在指定go 1.17或更高版本的模块中避免为不需要的命令加载模块图。参见 &ldquo;懒惰模块加载&rdquo;。</p>
<h3 id="main-module">main module</h3>
<p>The module in which the <code>go</code> command is invoked. The main module is defined by a <a href="https://go.dev/ref/mod#glos-go-mod-file" target="_blank" rel="noopener"><code>go.mod</code> file</a> in the current directory or a parent directory. See <a href="https://go.dev/ref/mod#modules-overview" target="_blank" rel="noopener">Modules, packages, and versions</a>.</p>
<p>主模块。调用go命令的模块。主模块由当前目录或父目录中的go.mod文件定义。参见模块、包和版本。</p>
<h3 id="major-version">major version</h3>
<p>The first number in a semantic version (<code>1</code> in <code>v1.2.3</code>). In a release with incompatible changes, the major version must be incremented, and the minor and patch versions must be set to 0. Semantic versions with major version 0 are considered unstable.</p>
<p>主版本。语义版本中的第一个数字（1在v1.2.3中）。在有不兼容变化的版本中，主版本必须被递增，而次版本和补丁版本必须被设置为0。 主版本为0的语义版本被认为是不稳定的。</p>
<h3 id="major-version-subdirectory">major version subdirectory</h3>
<p>A subdirectory within a version control repository matching a module’s <a href="https://go.dev/ref/mod#glos-major-version-suffix" target="_blank" rel="noopener">major version suffix</a> where a module may be defined. For example, the module <code>example.com/mod/v2</code> in the repository with <a href="https://go.dev/ref/mod#glos-repository-root-path" target="_blank" rel="noopener">root path</a> <code>example.com/mod</code> may be defined in the repository root directory or the major version subdirectory <code>v2</code>. See <a href="https://go.dev/ref/mod#vcs-dir" target="_blank" rel="noopener">Module directories within a repository</a>.</p>
<p>major version subdirectory（主要版本子目录）。版本控制库中的一个子目录，与模块的主要版本后缀相匹配，在这里可以定义一个模块。例如，根路径为 example.com/mod 的版本库中的模块 example.com/mod/v2 可以定义在版本库根目录或主要版本子目录 v2 中。参见版本库内的模块目录。</p>
<h3 id="major-version-suffix">major version suffix</h3>
<p>A module path suffix that matches the major version number. For example, <code>/v2</code> in <code>example.com/mod/v2</code>. Major version suffixes are required at <code>v2.0.0</code> and later and are not allowed at earlier versions. See the section on <a href="https://go.dev/ref/mod#major-version-suffixes" target="_blank" rel="noopener">Major version suffixes</a>.</p>
<p>主要版本的后缀。一个与主要版本号相匹配的模块路径后缀。例如，/v2 在 example.com/mod/v2。主要版本后缀在v2.0.0及以后的版本中是必须的，在早期版本中不允许使用。参见主要版本后缀一节。</p>
<h3 id="minimal-version-selection-mvs">minimal version selection (MVS)</h3>
<p>The algorithm used to determine the versions of all modules that will be used in a build. See the section on <a href="https://go.dev/ref/mod#minimal-version-selection" target="_blank" rel="noopener">Minimal version selection</a> for details.</p>
<p>最小版本选择（MVS）。用来确定构建中使用的所有模块的版本的算法。详见最小版本选择一节。</p>
<h3 id="minor-version">minor version</h3>
<p>The second number in a semantic version (<code>2</code> in <code>v1.2.3</code>). In a release with new, backwards compatible functionality, the minor version must be incremented, and the patch version must be set to 0.</p>
<p>次要版本。语义版本中的第二个数字（V1.2.3中为2）。在具有新的、向后兼容的功能的版本中，次要版本必须被递增，而补丁版本必须被设置为0。</p>
<h3 id="module">module</h3>
<p>A collection of packages that are released, versioned, and distributed together.</p>
<p>模块。一组包的集合，它们被一起发布、版本化和分发。</p>
<p><strong>module cache:</strong> A local directory storing downloaded modules, located in <code>GOPATH/pkg/mod</code>. See <a href="https://go.dev/ref/mod#module-cache" target="_blank" rel="noopener">Module cache</a>.</p>
<p>模块缓存。一个存储下载模块的本地目录，位于GOPATH/pkg/mod。参见模块缓存。</p>
<h3 id="module-graph">module graph</h3>
<p>The directed graph of module requirements, rooted at the <a href="https://go.dev/ref/mod#glos-main-module" target="_blank" rel="noopener">main module</a>. Each vertex in the graph is a module; each edge is a version from a <code>require</code> statement in a <code>go.mod</code> file (subject to <code>replace</code> and <code>exclude</code> statements in the main module’s <code>go.mod</code> file).</p>
<p>模块图。模块需求的有向图，以主模块为根。图中的每个顶点都是一个模块；每条边都是来自 go.mod 文件中 require 语句的版本（受主模块的 go.mod 文件中的替换和排除语句制约）。</p>
<h3 id="module-graph-pruning">module graph pruning</h3>
<p>A change in Go 1.17 that reduces the size of the module graph by omitting transitive dependencies of modules that specify <code>go 1.17</code> or higher. See <a href="https://go.dev/ref/mod#graph-pruning" target="_blank" rel="noopener">Module graph pruning</a>.</p>
<p>模块图的修剪。Go 1.17中的一个变化，通过省略指定go 1.17或更高版本的模块的相互依赖关系来减少模块图的大小。参见模块图修剪。</p>
<h3 id="module-path">module path</h3>
<p>A path that identifies a module and acts as a prefix for package import paths within the module. For example, <code>&quot;golang.org/x/net&quot;</code>.</p>
<p>模块路径。一个标识模块的路径，作为模块内包导入路径的前缀。例如，&ldquo;golang.org/x/net&rdquo;。</p>
<h3 id="module-proxy">module proxy</h3>
<p>A web server that implements the <a href="https://go.dev/ref/mod#goproxy-protocol" target="_blank" rel="noopener"><code>GOPROXY</code> protocol</a>. The <code>go</code> command downloads version information, <code>go.mod</code> files, and module zip files from module proxies.</p>
<p>模块代理。一个实现GOPROXY协议的网络服务器。go命令从模块代理处下载版本信息、go.mod文件和模块压缩文件。</p>
<h3 id="module-root-directory">module root directory</h3>
<p>The directory that contains the <code>go.mod</code> file that defines a module.</p>
<p>模块根目录。包含定义模块的go.mod文件的目录。</p>
<h3 id="module-subdirectory">module subdirectory</h3>
<p>The portion of a <a href="https://go.dev/ref/mod#glos-module-path" target="_blank" rel="noopener">module path</a> after the <a href="https://go.dev/ref/mod#glos-repository-root-path" target="_blank" rel="noopener">repository root path</a> that indicates the subdirectory where the module is defined. When non-empty, the module subdirectory is also a prefix for <a href="https://go.dev/ref/mod#glos-semantic-version-tag" target="_blank" rel="noopener">semantic version tags</a>. The module subdirectory does not include the <a href="https://go.dev/ref/mod#glos-major-version-suffix" target="_blank" rel="noopener">major version suffix</a>, if there is one, even if the module is in a <a href="https://go.dev/ref/mod#glos-major-version-subdirectory" target="_blank" rel="noopener">major version subdirectory</a>. See <a href="https://go.dev/ref/mod#module-path" target="_blank" rel="noopener">Module paths</a>.</p>
<p>模块子目录。模块路径在版本库根路径之后的部分，表示定义该模块的子目录。非空时，模块子目录也是语义版本标签的前缀。模块子目录不包括主要版本后缀（如果有的话），即使该模块位于主要版本子目录中。参见模块路径。</p>
<h3 id="package">package</h3>
<p>A collection of source files in the same directory that are compiled together. See the <a href="https://go.dev/ref/spec#Packages" target="_blank" rel="noopener">Packages section</a> in the Go Language Specification.</p>
<p>包。在同一目录下的源文件的集合，这些文件被编译在一起。参见 Go 语言规范中的包部分。</p>
<h3 id="package-path">package path</h3>
<p>The path that uniquely identifies a package. A package path is a <a href="https://go.dev/ref/mod#glos-module-path" target="_blank" rel="noopener">module path</a> joined with a subdirectory within the module. For example <code>&quot;golang.org/x/net/html&quot;</code> is the package path for the package in the module <code>&quot;golang.org/x/net&quot;</code> in the <code>&quot;html&quot;</code> subdirectory. Synonym of <a href="https://go.dev/ref/mod#glos-import-path" target="_blank" rel="noopener">import path</a>.</p>
<p>包路径。唯一标识一个包的路径。包的路径是一个模块的路径与模块内的子目录相连接。例如 &ldquo;golang.org/x/net/html &ldquo;是模块 &ldquo;golang.org/x/net &ldquo;中 &ldquo;html &ldquo;子目录下的包的路径。进口路径的同义词。</p>
<h3 id="patch-version">patch version</h3>
<p>The third number in a semantic version (<code>3</code> in <code>v1.2.3</code>). In a release with no changes to the module’s public interface, the patch version must be incremented.</p>
<p>补丁版本。语义版本中的第三个数字（v1.2.3中为3）。在模块的公共接口没有变化的版本中，补丁版本必须被递增。</p>
<h3 id="pre-release-version">pre-release version</h3>
<p>A version with a dash followed by a series of dot-separated identifiers immediately following the patch version, for example, <code>v1.2.3-beta4</code>. Pre-release versions are considered unstable and are not assumed to be compatible with other versions. A pre-release version sorts before the corresponding release version: <code>v1.2.3-pre</code> comes before <code>v1.2.3</code>. See also <a href="https://go.dev/ref/mod#glos-release-version" target="_blank" rel="noopener">release version</a>.</p>
<p>pre-release version（预发布版本）。在补丁版本后面紧跟着一系列点分隔的标识符，带有破折号的版本，例如，v1.2.3-beta4。预发布版本被认为是不稳定的，不被认为与其他版本兼容。预发布版本会在相应的发布版本之前排序：v1.2.3-pre会在v1.2.3之前。另见发布版本。</p>
<h3 id="pseudo-version">pseudo-version</h3>
<p>A version that encodes a revision identifier (such as a Git commit hash) and a timestamp from a version control system. For example, <code>v0.0.0-20191109021931-daa7c04131f5</code>. Used for <a href="https://go.dev/ref/mod#non-module-compat" target="_blank" rel="noopener">compatibility with non-module repositories</a> and in other situations when a tagged version is not available.</p>
<p>pseudo-version（伪版本）。一个编码了修订标识符（如Git提交哈希值）和版本控制系统的时间戳的版本。例如，v0.0.0-20191109021931-daa7c04131f5。 用于与非模块仓库的兼容性，以及其他无法获得标记版本的情况。</p>
<h3 id="release-version">release version</h3>
<p>A version without a pre-release suffix. For example, <code>v1.2.3</code>, not <code>v1.2.3-pre</code>. See also <a href="https://go.dev/ref/mod#glos-pre-release-version" target="_blank" rel="noopener">pre-release version</a>.</p>
<p>发布版本。一个没有预发布后缀的版本。例如，v1.2.3，而不是v1.2.3-pre。另见预发布版本。</p>
<h3 id="repository-root-path">repository root path</h3>
<p>The portion of a <a href="https://go.dev/ref/mod#glos-module-path" target="_blank" rel="noopener">module path</a> that corresponds to a version control repository’s root directory. See <a href="https://go.dev/ref/mod#module-path" target="_blank" rel="noopener">Module paths</a>.</p>
<p>仓库根路径。模块路径中与版本控制库的根目录相对应的部分。参见模块路径。</p>
<h3 id="retracted-version">retracted version</h3>
<p>A version that should not be depended upon, either because it was published prematurely or because a severe problem was discovered after it was published. See <a href="https://go.dev/ref/mod#go-mod-file-retract" target="_blank" rel="noopener"><code>retract</code> directive</a>.</p>
<p>撤回的版本。一个不应该被依赖的版本，因为它被过早地发布，或者在发布后发现了严重的问题。参见retract指令。</p>
<h3 id="semantic-version-tag">semantic version tag</h3>
<p>A tag in a version control repository that maps a <a href="https://go.dev/ref/mod#glos-version" target="_blank" rel="noopener">version</a> to a specific revision. See <a href="https://go.dev/ref/mod#vcs-version" target="_blank" rel="noopener">Mapping versions to commits</a>.</p>
<p>语义版本标签。版本控制库中的一个标签，将一个版本映射到一个特定的修订版。参见版本与提交的映射。</p>
<h3 id="selected-version">selected version</h3>
<p>The version of a given module chosen by <a href="https://go.dev/ref/mod#minimal-version-selection" target="_blank" rel="noopener">minimal version selection</a>. The selected version is the highest version for the module’s path found in the <a href="https://go.dev/ref/mod#glos-module-graph" target="_blank" rel="noopener">module graph</a>.</p>
<p>选定的版本。通过最小版本选择选择的特定模块的版本。选择的版本是在模块图中发现的该模块路径的最高版本。</p>
<h3 id="vendor-directory">vendor directory</h3>
<p>A directory named <code>vendor</code> that contains packages from other modules needed to build packages in the main module. Maintained with <a href="https://go.dev/ref/mod#go-mod-vendor" target="_blank" rel="noopener"><code>go mod vendor</code></a>. See <a href="https://go.dev/ref/mod#vendoring" target="_blank" rel="noopener">Vendoring</a>.</p>
<p>vendor目录。一个名为vendor的目录，包含了其他模块的包，需要在主模块中构建包。用go mod vendor维护。参看vendoring。</p>
<h3 id="version">version</h3>
<p>An identifier for an immutable snapshot of a module, written as the letter <code>v</code> followed by a semantic version. See the section on <a href="https://go.dev/ref/mod#versions" target="_blank" rel="noopener">Versions</a>.</p>
<p>版本。一个模块的不可改变的快照的标识符，写成字母v，后面是语义版本。参见 &ldquo;版本 &ldquo;一节。</p>
<h3 id="workspace">workspace</h3>
<p>A collection of modules on disk that are used as the main modules when running <a href="https://go.dev/ref/mod#minimal-version-selection" target="_blank" rel="noopener">minimal version selection (MVS)</a>. See the section on <a href="https://go.dev/ref/mod#workspaces" target="_blank" rel="noopener">Workspaces</a></p>
<p>workspace（工作区）。磁盘上的模块集合，在运行最小版本选择（MVS）时被用作主要模块。见关于工作区的章节</p>

</div>



    
	
  



          </main>
        </div>
      </div>
      
<footer class="bg-dark py-5 row d-print-none">
  <div class="container-fluid mx-sm-5">
    <div class="row">
      <div class="col-6 col-sm-4 text-xs-center order-sm-2">
        
        
        
<ul class="list-inline mb-0">
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="User mailing list" aria-label="User mailing list">
    <a class="text-white" target="_blank" rel="noopener" href="https://example.org/mail" aria-label="User mailing list">
      <i class="fa fa-envelope"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Twitter" aria-label="Twitter">
    <a class="text-white" target="_blank" rel="noopener" href="https://example.org/twitter" aria-label="Twitter">
      <i class="fab fa-twitter"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Stack Overflow" aria-label="Stack Overflow">
    <a class="text-white" target="_blank" rel="noopener" href="https://example.org/stack" aria-label="Stack Overflow">
      <i class="fab fa-stack-overflow"></i>
    </a>
  </li>
  
</ul>

        
        
      </div>
      <div class="col-6 col-sm-4 text-right text-xs-center order-sm-3">
        
        
        
<ul class="list-inline mb-0">
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="GitHub" aria-label="GitHub">
    <a class="text-white" target="_blank" rel="noopener" href="https://github.com/google/docsy" aria-label="GitHub">
      <i class="fab fa-github"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Slack" aria-label="Slack">
    <a class="text-white" target="_blank" rel="noopener" href="https://example.org/slack" aria-label="Slack">
      <i class="fab fa-slack"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Developer mailing list" aria-label="Developer mailing list">
    <a class="text-white" target="_blank" rel="noopener" href="https://example.org/mail" aria-label="Developer mailing list">
      <i class="fa fa-envelope"></i>
    </a>
  </li>
  
</ul>

        
        
      </div>
      <div class="col-12 col-sm-4 text-center py-2 order-sm-2">
        <small class="text-white">&copy; 2023 The Docsy Authors </small>
        <small class="ml-1"><a href="https://policies.google.com/privacy" target="_blank" rel="noopener"></a></small>
	
		
	
      </div>
    </div>
  </div>
</footer>


    </div>
    
  <script src="/js/main.min.9069af235eb4d4956fc4dc29e5ca46caef0cdcae593856be4e33c99075bc5ea2.js" integrity="sha256-kGmvI1601JVvxNwp5cpGyu8M3K5ZOFa&#43;TjPJkHW8XqI=" crossorigin="anonymous"></script>
<script src='/js/tabpane-persist.js'></script>
<script src='/js/deal-zero-width-space.js'></script>
  </body>
</html>
